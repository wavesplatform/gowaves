golangci-lint run
cmd/compiler/main.go:33:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println(usage)
		^
cmd/compiler/main.go:38:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Script path is not specified")
		^
cmd/compiler/main.go:45:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Failed to open file: %s", err)
		^
cmd/compiler/main.go:51:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println("Failed to compile script")
		^
cmd/compiler/main.go:53:4: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Printf("\t%v\n", err)
			^
cmd/compiler/main.go:57:2: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Println(base64.StdEncoding.EncodeToString(treeBytes))
	^
cmd/compiler/main.go:13:5: usage is a global variable (gochecknoglobals)
var usage = `
    ^
pkg/util/cancellable/cancellable_test.go:4: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/require"
	"go.uber.org/atomic"
pkg/util/cancellable/cancellable_test.go:14:3: redefines-builtin-id: redefinition of the built-in type bool (revive)
		bool := atomic.NewBool(false)
		^
pkg/util/cancellable/cancellable_test.go:26:3: redefines-builtin-id: redefinition of the built-in type bool (revive)
		bool := atomic.NewBool(false)
		^
pkg/util/cancellable/cancellable_test.go:1:9: package should be `cancellable_test` instead of `cancellable` (testpackage)
package cancellable
        ^
pkg/p2p/peer/handle_test.go:31:15: Error return value is not checked (errcheck)
	connected := (<-parent.InfoCh).Value.(*Connected)
	             ^
pkg/p2p/peer/peer_impl.go:101:10: Error return value is not checked (errcheck)
	addr := a.Connection().Conn().RemoteAddr().(*net.TCPAddr)
	        ^
pkg/p2p/peer/peer_impl.go:48: line is 149 characters (lll)
func NewPeerImpl(handshake proto.Handshake, conn conn.Connection, direction Direction, remote Remote, cancel context.CancelFunc) (*PeerImpl, error) {
pkg/p2p/peer/handle_test.go:48: line is 125 characters (lll)
	_ = (<-parent.InfoCh).Value.(*Connected).Peer.(*peerOnceCloser).Peer // fist message should be notification about connection
pkg/p2p/peer/handle_test.go:70: line is 125 characters (lll)
	_ = (<-parent.InfoCh).Value.(*Connected).Peer.(*peerOnceCloser).Peer // fist message should be notification about connection
pkg/p2p/peer/peer_impl.go:39:6: exported: type name will be used as peer.PeerImpl by other packages, and that stutters; consider calling this Impl (revive)
type PeerImpl struct {
     ^
pkg/p2p/peer/peer.go:18:29: mnd: Magic number: 100, in <argument> detected (gomnd)
		ToCh:   make(chan []byte, 100),
		                          ^
pkg/p2p/peer/peer.go:19:49: mnd: Magic number: 100, in <argument> detected (gomnd)
		FromCh: make(chan *bytebufferpool.ByteBuffer, 100),
		                                              ^
pkg/p2p/peer/peer.go:20:28: mnd: Magic number: 10, in <argument> detected (gomnd)
		ErrCh:  make(chan error, 10),
		                         ^
pkg/p2p/peer/peer.go:32:44: mnd: Magic number: 100, in <argument> detected (gomnd)
		MessageCh:       make(chan ProtoMessage, 100),
		                                         ^
pkg/p2p/peer/peer.go:33:43: mnd: Magic number: 100, in <argument> detected (gomnd)
		InfoCh:          make(chan InfoMessage, 100),
		                                        ^
pkg/p2p/peer/peer_test.go:53:12: shadow: declaration of "err" shadows declaration at line 49 (govet)
				addrP, err := netip.ParseAddrPort(test.addr)
				       ^
pkg/p2p/peer/handle_test.go:1:9: package should be `peer_test` instead of `peer` (testpackage)
package peer
        ^
pkg/p2p/peer/peer_test.go:1:9: package should be `peer_test` instead of `peer` (testpackage)
package peer
        ^
pkg/util/fifo_cache/cache_test.go:23: unnecessary leading newline (whitespace)
func TestFIFOCache(t *testing.T) {

pkg/util/fifo_cache/cache_test.go:45: unnecessary trailing newline (whitespace)

}
cmd/binclient/main.go:37:1: don't use `init` function (gochecknoinits)
func init() {
^
cmd/binclient/main.go:117: line is 131 characters (lll)
	sig, _ := crypto.NewSignatureFromBase58("FSH8eAAzZNqnG8xgTZtz5xuLqXySsXgAjmFEC25hXMbEufiGjqWPnGCZFt6gLiVLJny16ipxRNAkkzjjhqTjBE2")
cmd/binclient/main.go:131: unnecessary trailing newline (whitespace)

}
cmd/binclient/main.go:17:2: wavesNetwork is a global variable (gochecknoglobals)
	wavesNetwork = flag.String("waves-network", "", "Waves network.")
	^
cmd/binclient/main.go:18:2: address is a global variable (gochecknoglobals)
	address      = flag.String("address", "", "Address connect to.")
	^
cmd/binclient/main.go:130:13: mnd: Magic number: 5, in <argument> detected (gomnd)
	time.Sleep(5 * time.Minute)
	           ^
cmd/binclient/main.go:141:24: mnd: Magic number: 4, in <argument> detected (gomnd)
	buf := make([]byte, l+4)
	                      ^
cmd/binclient/main.go:65:17: mnd: Magic number: 0x0, in <assign> detected (gomnd)
		NodeNonce:    0x0,
		              ^
cmd/binclient/main.go:77:6: shadow: declaration of "err" shadows declaration at line 55 (govet)
		if err := conn.Close(); err != nil {
		   ^
cmd/binclient/main.go:102:9: shadow: declaration of "err" shadows declaration at line 55 (govet)
			bts, err := readPacket(conn)
			     ^
cmd/blockcmp/internal/entities.go:90:1: cognitive complexity 28 of func `(issueSorter).Less` is high (> 20) (gocognit)
func (a issueSorter) Less(i, j int) bool {
^
cmd/blockcmp/internal/extractors.go:23:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractDataEntries(inv.GetStateChanges())...)
			    ^
cmd/blockcmp/internal/extractors.go:37:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractTransfers(inv.GetStateChanges(), scheme)...)
			    ^
cmd/blockcmp/internal/extractors.go:51:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractIssues(inv.GetStateChanges())...)
			    ^
cmd/blockcmp/internal/extractors.go:65:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractReissues(inv.GetStateChanges())...)
			    ^
cmd/blockcmp/internal/extractors.go:79:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractBurns(inv.GetStateChanges())...)
			    ^
cmd/blockcmp/internal/extractors.go:93:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractSponsorships(inv.GetStateChanges())...)
			    ^
cmd/blockcmp/internal/extractors.go:107:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractLeases(inv.GetStateChanges(), scheme)...)
			    ^
cmd/blockcmp/internal/extractors.go:121:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, ExtractLeaseCancels(inv.GetStateChanges())...)
			    ^
cmd/blockcmp/internal/entities.go:91:2: `if a[i].AssetID == a[j].AssetID` has complex nested blocks (complexity: 21) (nestif)
	if a[i].AssetID == a[j].AssetID {
	^
cmd/wmd/internal/api.go:469: Function 'candles' has too many statements (56 > 50) (funlen)
func (a *DataFeedAPI) candles(w http.ResponseWriter, r *http.Request) {
cmd/wmd/internal/api.go:550: Function 'candlesRange' has too many statements (57 > 50) (funlen)
func (a *DataFeedAPI) candlesRange(w http.ResponseWriter, r *http.Request) {
cmd/wmd/internal/importer.go:150: Function 'extractTransactions' has too many statements (94 > 50) (funlen)
func (im *Importer) extractTransactions(transactions []proto.Transaction, miner crypto.PublicKey) ([]data.Trade, []data.IssueChange, []data.AssetChange, []data.AccountChange, []data.AliasBind, error) {
cmd/wmd/internal/synchronizer.go:284: Function 'extractTransactions' has too many statements (122 > 50) (funlen)
func (s *Synchronizer) extractTransactions(txs []proto.Transaction, miner crypto.PublicKey) ([]data.Trade, []data.IssueChange, []data.AssetChange, []data.AccountChange, []data.AliasBind, error) {
cmd/wmd/internal/importer.go:61:1: cognitive complexity 57 of func `(*Importer).readBlocks` is high (> 20) (gocognit)
func (im *Importer) readBlocks(f io.Reader) error {
^
cmd/wmd/internal/synchronizer.go:75:1: cognitive complexity 23 of func `(*Synchronizer).synchronize` is high (> 20) (gocognit)
func (s *Synchronizer) synchronize() {
^
cmd/wmd/internal/synchronizer.go:77:2: assignOp: replace `rh = rh - s.lag` with `rh -= s.lag` (gocritic)
	rh = rh - s.lag
	^
cmd/wmd/internal/synchronizer.go:267:9: commentFormatting: put a space between `//` and comment text (gocritic)
		r = 1 //Pretend that we know the genesis block
		      ^
cmd/wmd/internal/api.go:83: line is 144 characters (lll)
func NewDataFeedAPI(interrupt <-chan struct{}, logger *zap.Logger, storage *state.Storage, address string, symbols *data.Symbols) *DataFeedAPI {
cmd/wmd/internal/api.go:140: line is 154 characters (lll)
	r.Get(fmt.Sprintf("/trades/{%s}/{%s}/{%s:\\d+}/{%s:\\d+}", amountAssetPlaceholder, priceAssetPlaceholder, fromPlaceholder, toPlaceholder), a.tradesRange)
cmd/wmd/internal/api.go:141: line is 172 characters (lll)
	r.Get(fmt.Sprintf("/trades/{%s}/{%s}/{%s:[1-9A-Za-z]+}/{%s:\\d+}", amountAssetPlaceholder, priceAssetPlaceholder, addressPlaceHolder, limitPlaceholder), a.tradesByAddress)
cmd/wmd/internal/api.go:142: line is 159 characters (lll)
	r.Get(fmt.Sprintf("/candles/{%s}/{%s}/{%s:\\d+}/{%s:\\d+}", amountAssetPlaceholder, priceAssetPlaceholder, timeFramePlaceholder, limitPlaceholder), a.candles)
cmd/wmd/internal/api.go:143: line is 188 characters (lll)
	r.Get(fmt.Sprintf("/candles/{%s}/{%s}/{%s:\\d+}/{%s:\\d+}/{%s:\\d+}", amountAssetPlaceholder, priceAssetPlaceholder, timeFramePlaceholder, fromPlaceholder, toPlaceholder), a.candlesRange)
cmd/wmd/internal/api.go:329: line is 128 characters (lll)
		http.Error(w, fmt.Sprintf("Bad request: %d is invalid limit value, allowed between 1 and 1000", limit), http.StatusBadRequest)
cmd/wmd/internal/api.go:431: line is 128 characters (lll)
		http.Error(w, fmt.Sprintf("Bad request: %d is invalid limit value, allowed between 1 and 1000", limit), http.StatusBadRequest)
cmd/wmd/internal/api.go:487: line is 148 characters (lll)
		http.Error(w, fmt.Sprintf("Bad request: incorrect time frame %d, allowed values: 5, 15, 30, 60, 240 and 1440 minutes", tf), http.StatusBadRequest)
cmd/wmd/internal/api.go:495: line is 128 characters (lll)
		http.Error(w, fmt.Sprintf("Bad request: %d is invalid limit value, allowed between 1 and 1000", limit), http.StatusBadRequest)
cmd/wmd/internal/api.go:568: line is 148 characters (lll)
		http.Error(w, fmt.Sprintf("Bad request: incorrect time frame %d, allowed values: 5, 15, 30, 60, 240 and 1440 minutes", tf), http.StatusBadRequest)
cmd/wmd/internal/api.go:631: line is 137 characters (lll)
func (a *DataFeedAPI) convertToTradesInfos(trades []data.Trade, amountAssetDecimals, priceAssetDecimals byte) ([]data.TradeInfo, error) {
cmd/wmd/internal/api.go:640: line is 127 characters (lll)
func (a *DataFeedAPI) convertToTickerInfo(aa, pa *data.AssetInfo, aaBalance, paBalance uint64, c data.Candle) data.TickerInfo {
cmd/wmd/internal/importer.go:25: line is 121 characters (lll)
func NewImporter(interrupt <-chan struct{}, scheme byte, storage *state.Storage, matchers []crypto.PublicKey) *Importer {
cmd/wmd/internal/synchronizer.go:33: line is 207 characters (lll)
func NewSynchronizer(interrupt <-chan struct{}, storage *state.Storage, scheme byte, matchers []crypto.PublicKey, node string, interval time.Duration, lag int, symbols *data.Symbols) (*Synchronizer, error) {
cmd/wmd/internal/synchronizer.go:40: line is 166 characters (lll)
	s := Synchronizer{interrupt: interrupt, done: done, conn: conn, storage: storage, scheme: scheme, matchers: matchers, interval: interval, lag: lag, symbols: symbols}
cmd/wmd/internal/synchronizer.go:159: line is 194 characters (lll)
func (s *Synchronizer) recvBlockRange(h int, delta int, stream g.BlocksApi_GetBlockRangeClient, cnv proto.ProtobufConverter) ([]proto.BlockID, []crypto.PublicKey, [][]proto.Transaction, error) {
cmd/wmd/internal/synchronizer.go:185: line is 128 characters (lll)
func (s *Synchronizer) blockRange(start int, end int, ctx context.Context, full bool) (g.BlocksApi_GetBlockRangeClient, error) {
cmd/wmd/internal/synchronizer.go:231: line is 174 characters (lll)
	return g.NewBlocksApiClient(s.conn).GetBlock(ctx, &g.BlockRequest{IncludeTransactions: full, Request: &g.BlockRequest_Height{Height: int32(height)}}, grpc.EmptyCallOption{})
cmd/wmd/internal/synchronizer.go:90:2: `if rh > lh` has complex nested blocks (complexity: 10) (nestif)
	if rh > lh {
	^
cmd/wmd/internal/importer.go:111:4: `if !blockExists` has complex nested blocks (complexity: 6) (nestif)
			if !blockExists {
			^
cmd/wmd/internal/api.go:331: unnecessary trailing newline (whitespace)

	}
cmd/wmd/internal/api.go:433: unnecessary trailing newline (whitespace)

	}
cmd/wmd/internal/api.go:547: unnecessary trailing newline (whitespace)

}
cmd/wmd/internal/api.go:497: unnecessary trailing newline (whitespace)

	}
cmd/wmd/internal/synchronizer.go:154: unnecessary trailing newline (whitespace)

	}
cmd/wmd/internal/importer.go:77:8: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
				if err != io.EOF {
				   ^
cmd/wmd/internal/importer.go:89:8: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
				if err != io.EOF {
				   ^
cmd/wmd/internal/synchronizer.go:194:5: emptyID is a global variable (gochecknoglobals)
var emptyID = proto.BlockID{}
    ^
cmd/wmd/internal/api.go:109:60: mnd: Magic number: 5, in <argument> detected (gomnd)
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		                                                         ^
cmd/wmd/internal/api.go:343:55: mnd: Magic number: 2, in <argument> detected (gomnd)
	ts, err := a.Storage.Trades(amountAsset, priceAsset, 2*limit)
	                                                     ^
cmd/wmd/internal/api.go:510:66: mnd: Magic number: 1000, in <argument> detected (gomnd)
	ttf := data.TimeFrameFromTimestampMS(uint64(time.Now().Unix() * 1000))
	                                                                ^
cmd/wmd/internal/importer.go:64:21: mnd: Magic number: 4, in <argument> detected (gomnd)
	sb := make([]byte, 4)
	                   ^
cmd/wmd/internal/importer.go:65:29: mnd: Magic number: 1024, in <argument> detected (gomnd)
	buf := make([]byte, 2*1024*1024)
	                           ^
cmd/wmd/internal/synchronizer.go:217:59: mnd: Magic number: 30, in <argument> detected (gomnd)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	                                                         ^
cmd/wmd/internal/synchronizer.go:229:59: mnd: Magic number: 30, in <argument> detected (gomnd)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	                                                         ^
cmd/wmd/internal/importer.go:136:19: mnd: Magic number: 10000, in <operation> detected (gomnd)
				th := total / 10000
				              ^
cmd/wmd/internal/synchronizer.go:253:30: mnd: Magic number: 2, in <operation> detected (gomnd)
		middle := (start + stop) / 2
		                           ^
cmd/wmd/internal/api.go:100:3: shadow: declaration of "err" shadows declaration at line 85 (govet)
		err := apiServer.ListenAndServe()
		^
cmd/wmd/internal/api.go:110:3: shadow: declaration of "err" shadows declaration at line 85 (govet)
		err := apiServer.Shutdown(ctx)
		^
cmd/wmd/internal/api.go:183:6: shadow: declaration of "err" shadows declaration at line 176 (govet)
		c, err := a.Storage.DayCandle(m.AmountAsset, m.PriceAsset)
		   ^
cmd/wmd/internal/api.go:228:6: shadow: declaration of "err" shadows declaration at line 221 (govet)
		c, err := a.Storage.DayCandle(m.AmountAsset, m.PriceAsset)
		   ^
cmd/wmd/internal/api.go:645:8: shadow: declaration of "ok" shadows declaration at line 642 (govet)
		pat, ok := a.Symbols.Token(pa.ID)
		     ^
cmd/wmd/internal/importer.go:112:15: shadow: declaration of "err" shadows declaration at line 75 (govet)
				validSig, err := b.VerifySignature(im.scheme)
				          ^
cmd/wmd/internal/synchronizer.go:92:7: shadow: declaration of "err" shadows declaration at line 76 (govet)
		ch, err := s.findLastCommonHeight(1, lh)
		    ^
cmd/wmd/internal/synchronizer.go:98:20: shadow: declaration of "err" shadows declaration at line 92 (govet)
			rollbackHeight, err := s.storage.SafeRollbackHeight(ch)
			                ^
cmd/wmd/internal/data/decimal.go:150:6: `InfiniteDecimal` should be annotated with the `json` tag as it is passed to `json.Encoder.Encode` at cmd/wmd/internal/api.go:303:8 (musttag)
type InfiniteDecimal struct {
     ^
pkg/metrics/metrics.go:178: line is 142 characters (lll)
	f := emptyFields().blockID(block.BlockID()).referenceID(block.Parent).source(source).blockTS(block.Timestamp).genPK(block.GeneratorPublicKey)
pkg/metrics/metrics.go:223: line is 130 characters (lll)
	f := emptyFields().blockID(microblock.TotalBlockID).referenceID(microblock.Reference).signature(microblock.TotalResBlockSigField)
pkg/metrics/metrics.go:232: line is 141 characters (lll)
	f := emptyFields().blockID(microblock.TotalBlockID).referenceID(microblock.Reference).signature(microblock.TotalResBlockSigField).error(err)
pkg/metrics/metrics.go:241: line is 130 characters (lll)
	f := emptyFields().blockID(microblock.TotalBlockID).referenceID(microblock.Reference).signature(microblock.TotalResBlockSigField)
pkg/metrics/metrics.go:71:19: var-declaration: should drop = nil from declaration of var rep; it is the zero value (revive)
	rep  *reporter = nil
	                 ^
pkg/metrics/metrics.go:70:2: once is a global variable (gochecknoglobals)
	once sync.Once
	^
pkg/metrics/metrics_test.go:1:9: package should be `metrics_test` instead of `metrics` (testpackage)
package metrics
        ^
pkg/util/byte_helpers/messages.go:13:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/util/byte_helpers/transactions.go:200:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/util/byte_helpers/transactions.go:627:28: Comment should end in a period (godot)
// SetAssetScriptWithProofs
                           ^
pkg/util/byte_helpers/transactions.go:652:26: Comment should end in a period (godot)
// InvokeScriptWithProofs
                         ^
pkg/util/byte_helpers/transactions.go:309: line is 149 characters (lll)
	t := proto.NewUnsignedIssueWithProofs(2, pk, "name", "description", 1000, 4, false, []byte("script"), proto.NewTimestampFromTime(time.Now()), 10000)
pkg/util/byte_helpers/transactions.go:484: line is 164 characters (lll)
	t := proto.NewUnsignedMassTransferWithProofs(1, pk, *proto.NewOptionalAssetFromDigest(d), []proto.MassTransferEntry{entry}, 10000, TIMESTAMP, []byte("attachment"))
pkg/util/byte_helpers/transferv1_test.go:1:9: var-naming: don't use an underscore in package name (revive)
package byte_helpers
        ^
pkg/util/byte_helpers/messages.go:1:9: var-naming: don't use an underscore in package name (revive)
package byte_helpers
        ^
pkg/util/byte_helpers/transactions.go:1:9: var-naming: don't use an underscore in package name (revive)
package byte_helpers
        ^
pkg/util/byte_helpers/transferv1.go:1:9: var-naming: don't use an underscore in package name (revive)
package byte_helpers
        ^
pkg/util/byte_helpers/transactions_test.go:1:9: var-naming: don't use an underscore in package name (revive)
package byte_helpers
        ^
pkg/util/byte_helpers/transactions.go:274: unnecessary trailing newline (whitespace)

}
pkg/util/byte_helpers/transactions.go:277: unnecessary leading newline (whitespace)
func initIssueWithSig() {

pkg/util/byte_helpers/transactions.go:305: unnecessary leading newline (whitespace)
func initIssueWithProofs() {

pkg/util/byte_helpers/transactions.go:371: unnecessary leading newline (whitespace)
func initReissueWithSig() {

pkg/util/byte_helpers/transactions.go:420: unnecessary leading newline (whitespace)
func initBurnWithSig() {

pkg/util/byte_helpers/transferv1.go:20: unnecessary trailing newline (whitespace)

}
pkg/util/byte_helpers/messages.go:11:5: GetPeersMessage is a global variable (gochecknoglobals)
var GetPeersMessage GetPeersMessageStruct
    ^
pkg/util/byte_helpers/transactions.go:12:5: Digest is a global variable (gochecknoglobals)
var Digest = crypto.MustDigestFromBase58("WmryL34P6UwwUphNbhjBRwiCWxX15Nf5D8T7AmQY7yx")
    ^
pkg/util/byte_helpers/transactions.go:20:5: Genesis is a global variable (gochecknoglobals)
var Genesis GenesisStruct
    ^
pkg/util/byte_helpers/transactions.go:28:5: Payment is a global variable (gochecknoglobals)
var Payment PaymentStruct
    ^
pkg/util/byte_helpers/transactions.go:36:5: ReissueWithSig is a global variable (gochecknoglobals)
var ReissueWithSig ReissueWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:44:5: ReissueWithProofs is a global variable (gochecknoglobals)
var ReissueWithProofs ReissueWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:52:5: TransferWithSig is a global variable (gochecknoglobals)
var TransferWithSig TransferWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:60:5: BurnWithSig is a global variable (gochecknoglobals)
var BurnWithSig BurnWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:68:5: BurnWithProofs is a global variable (gochecknoglobals)
var BurnWithProofs BurnWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:76:5: TransferWithProofs is a global variable (gochecknoglobals)
var TransferWithProofs TransferWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:84:5: IssueWithSig is a global variable (gochecknoglobals)
var IssueWithSig IssueWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:92:5: IssueWithProofs is a global variable (gochecknoglobals)
var IssueWithProofs IssueWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:100:5: MassTransferWithProofs is a global variable (gochecknoglobals)
var MassTransferWithProofs MassTransferWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:108:5: ExchangeWithSig is a global variable (gochecknoglobals)
var ExchangeWithSig ExchangeWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:116:5: ExchangeWithProofs is a global variable (gochecknoglobals)
var ExchangeWithProofs ExchangeWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:124:5: SetAssetScriptWithProofs is a global variable (gochecknoglobals)
var SetAssetScriptWithProofs SetAssetScriptWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:132:5: InvokeScriptWithProofs is a global variable (gochecknoglobals)
var InvokeScriptWithProofs InvokeScriptWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:140:5: LeaseWithSig is a global variable (gochecknoglobals)
var LeaseWithSig LeaseWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:148:5: LeaseWithProofs is a global variable (gochecknoglobals)
var LeaseWithProofs LeaseWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:156:5: LeaseCancelWithSig is a global variable (gochecknoglobals)
var LeaseCancelWithSig LeaseCancelWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:164:5: LeaseCancelWithProofs is a global variable (gochecknoglobals)
var LeaseCancelWithProofs LeaseCancelWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:172:5: DataWithProofs is a global variable (gochecknoglobals)
var DataWithProofs DataWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:180:5: SponsorshipWithProofs is a global variable (gochecknoglobals)
var SponsorshipWithProofs SponsorshipWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:188:5: CreateAliasWithSig is a global variable (gochecknoglobals)
var CreateAliasWithSig CreateAliasWithSigStruct
    ^
pkg/util/byte_helpers/transactions.go:196:5: CreateAliasWithProofs is a global variable (gochecknoglobals)
var CreateAliasWithProofs CreateAliasWithProofsStruct
    ^
pkg/util/byte_helpers/transactions.go:198:5: sk is a global variable (gochecknoglobals)
var sk, pk, _ = crypto.GenerateKeyPair([]byte("test"))
    ^
pkg/util/byte_helpers/transactions.go:241:8: publicKey is a global variable (gochecknoglobals)
var _, publicKey, _ = crypto.GenerateKeyPair([]byte("test"))
       ^
pkg/util/byte_helpers/transactions.go:242:5: address is a global variable (gochecknoglobals)
var address, _ = proto.NewAddressFromPublicKey(proto.MainNetScheme, publicKey)
    ^
pkg/util/byte_helpers/transactions.go:251:3: mnd: Magic number: 2, in <argument> detected (gomnd)
		2,
		^
pkg/util/byte_helpers/transactions.go:256:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:257:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:285:3: mnd: Magic number: 1000, in <argument> detected (gomnd)
		1000,
		^
pkg/util/byte_helpers/transactions.go:286:3: mnd: Magic number: 4, in <argument> detected (gomnd)
		4,
		^
pkg/util/byte_helpers/transactions.go:289:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000)
		^
pkg/util/byte_helpers/transactions.go:331:38: mnd: Magic number: 100000, in <argument> detected (gomnd)
	t := proto.NewUnsignedGenesis(addr, 100000, TIMESTAMP)
	                                    ^
pkg/util/byte_helpers/transactions.go:352:42: mnd: Magic number: 100000, in <argument> detected (gomnd)
	t := proto.NewUnsignedPayment(pk, addr, 100000, 10000, TIMESTAMP)
	                                        ^
pkg/util/byte_helpers/transactions.go:378:46: mnd: Magic number: 100000, in <argument> detected (gomnd)
	t := proto.NewUnsignedReissueWithSig(pk, d, 100000, true, TIMESTAMP, 10000)
	                                            ^
pkg/util/byte_helpers/transactions.go:402:42: mnd: Magic number: 2, in <argument> detected (gomnd)
	t := proto.NewUnsignedReissueWithProofs(2, pk, d, 100000, true, TIMESTAMP, 10000)
	                                        ^
pkg/util/byte_helpers/transactions.go:427:43: mnd: Magic number: 100000, in <argument> detected (gomnd)
	t := proto.NewUnsignedBurnWithSig(pk, d, 100000, TIMESTAMP, 10000)
	                                         ^
pkg/util/byte_helpers/transactions.go:451:39: mnd: Magic number: 2, in <argument> detected (gomnd)
	t := proto.NewUnsignedBurnWithProofs(2, pk, d, 100000, TIMESTAMP, 10000)
	                                     ^
pkg/util/byte_helpers/transactions.go:515:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:516:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:519:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000)
		^
pkg/util/byte_helpers/transactions.go:529:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:530:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:533:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000)
		^
pkg/util/byte_helpers/transactions.go:540:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:541:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:542:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:543:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:544:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:577:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:578:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:581:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000)
		^
pkg/util/byte_helpers/transactions.go:591:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:592:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:595:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000)
		^
pkg/util/byte_helpers/transactions.go:600:3: mnd: Magic number: 2, in <argument> detected (gomnd)
		2,
		^
pkg/util/byte_helpers/transactions.go:603:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:604:3: mnd: Magic number: 100000, in <argument> detected (gomnd)
		100000,
		^
pkg/util/byte_helpers/transactions.go:605:3: mnd: Magic number: 10000, in <argument> detected (gomnd)
		10000,
		^
pkg/util/byte_helpers/transactions.go:245:2: shadow: declaration of "sk" shadows declaration at line 198 (govet)
	sk, pk, _ := crypto.GenerateKeyPair([]byte("test"))
	^
pkg/util/byte_helpers/transactions.go:279:2: shadow: declaration of "sk" shadows declaration at line 198 (govet)
	sk, pk, _ := crypto.GenerateKeyPair([]byte("test"))
	^
pkg/util/byte_helpers/transactions.go:307:2: shadow: declaration of "sk" shadows declaration at line 198 (govet)
	sk, pk, _ := crypto.GenerateKeyPair([]byte("test"))
	^
pkg/util/byte_helpers/transactions.go:326:2: shadow: declaration of "sk" shadows declaration at line 198 (govet)
	sk, pk, _ := crypto.GenerateKeyPair([]byte("test"))
	^
pkg/util/byte_helpers/transactions.go:347:2: shadow: declaration of "sk" shadows declaration at line 198 (govet)
	sk, pk, _ := crypto.GenerateKeyPair([]byte("test"))
	^
pkg/crypto/internal/edwards25519.go:571: 571-630 lines are duplicate of `pkg/crypto/internal/edwards25519.go:632-691` (dupl)
func fePow22523(out, z *FieldElement) {
	var t0, t1, t2 FieldElement
	var i int

	FeSquare(&t0, z)
	for i = 1; i < 1; i++ {
		FeSquare(&t0, &t0)
	}
	FeSquare(&t1, &t0)
	for i = 1; i < 2; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t1, z, &t1)
	FeMul(&t0, &t0, &t1)
	FeSquare(&t0, &t0)
	for i = 1; i < 1; i++ {
		FeSquare(&t0, &t0)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t1, &t0)
	for i = 1; i < 5; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t1, &t0)
	for i = 1; i < 10; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t1, &t1, &t0)
	FeSquare(&t2, &t1)
	for i = 1; i < 20; i++ {
		FeSquare(&t2, &t2)
	}
	FeMul(&t1, &t2, &t1)
	FeSquare(&t1, &t1)
	for i = 1; i < 10; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t1, &t0)
	for i = 1; i < 50; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t1, &t1, &t0)
	FeSquare(&t2, &t1)
	for i = 1; i < 100; i++ {
		FeSquare(&t2, &t2)
	}
	FeMul(&t1, &t2, &t1)
	FeSquare(&t1, &t1)
	for i = 1; i < 50; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t0, &t0)
	for i = 1; i < 2; i++ {
		FeSquare(&t0, &t0)
	}
	FeMul(out, &t0, z)
}
pkg/crypto/internal/edwards25519.go:632: 632-691 lines are duplicate of `pkg/crypto/internal/edwards25519.go:571-630` (dupl)
func FePow22523(out, z *FieldElement) {
	var t0, t1, t2 FieldElement
	var i int

	FeSquare(&t0, z)
	for i = 1; i < 1; i++ {
		FeSquare(&t0, &t0)
	}
	FeSquare(&t1, &t0)
	for i = 1; i < 2; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t1, z, &t1)
	FeMul(&t0, &t0, &t1)
	FeSquare(&t0, &t0)
	for i = 1; i < 1; i++ {
		FeSquare(&t0, &t0)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t1, &t0)
	for i = 1; i < 5; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t1, &t0)
	for i = 1; i < 10; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t1, &t1, &t0)
	FeSquare(&t2, &t1)
	for i = 1; i < 20; i++ {
		FeSquare(&t2, &t2)
	}
	FeMul(&t1, &t2, &t1)
	FeSquare(&t1, &t1)
	for i = 1; i < 10; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t1, &t0)
	for i = 1; i < 50; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t1, &t1, &t0)
	FeSquare(&t2, &t1)
	for i = 1; i < 100; i++ {
		FeSquare(&t2, &t2)
	}
	FeMul(&t1, &t2, &t1)
	FeSquare(&t1, &t1)
	for i = 1; i < 50; i++ {
		FeSquare(&t1, &t1)
	}
	FeMul(&t0, &t1, &t0)
	FeSquare(&t0, &t0)
	for i = 1; i < 2; i++ {
		FeSquare(&t0, &t0)
	}
	FeMul(out, &t0, z)
}
pkg/crypto/internal/edwards25519.go:914: 914-928 lines are duplicate of `pkg/crypto/internal/edwards25519.go:930-944` (dupl)
func geAdd(r *CompletedGroupElement, p *ExtendedGroupElement, q *CachedGroupElement) {
	var t0 FieldElement

	FeAdd(&r.X, &p.Y, &p.X)
	FeSub(&r.Y, &p.Y, &p.X)
	FeMul(&r.Z, &r.X, &q.yPlusX)
	FeMul(&r.Y, &r.Y, &q.yMinusX)
	FeMul(&r.T, &q.T2d, &p.T)
	FeMul(&r.X, &p.Z, &q.Z)
	FeAdd(&t0, &r.X, &r.X)
	FeSub(&r.X, &r.Z, &r.Y)
	FeAdd(&r.Y, &r.Z, &r.Y)
	FeAdd(&r.Z, &t0, &r.T)
	FeSub(&r.T, &t0, &r.T)
}
pkg/crypto/internal/edwards25519.go:930: 930-944 lines are duplicate of `pkg/crypto/internal/edwards25519.go:914-928` (dupl)
func geSub(r *CompletedGroupElement, p *ExtendedGroupElement, q *CachedGroupElement) {
	var t0 FieldElement

	FeAdd(&r.X, &p.Y, &p.X)
	FeSub(&r.Y, &p.Y, &p.X)
	FeMul(&r.Z, &r.X, &q.yMinusX)
	FeMul(&r.Y, &r.Y, &q.yPlusX)
	FeMul(&r.T, &q.T2d, &p.T)
	FeMul(&r.X, &p.Z, &q.Z)
	FeAdd(&t0, &r.X, &r.X)
	FeSub(&r.X, &r.Z, &r.Y)
	FeAdd(&r.Y, &r.Z, &r.Y)
	FeSub(&r.Z, &t0, &r.T)
	FeAdd(&r.T, &t0, &r.T)
}
pkg/crypto/internal/edwards25519.go:946: 946-959 lines are duplicate of `pkg/crypto/internal/edwards25519.go:961-974` (dupl)
func geMixedAdd(r *CompletedGroupElement, p *ExtendedGroupElement, q *PreComputedGroupElement) {
	var t0 FieldElement

	FeAdd(&r.X, &p.Y, &p.X)
	FeSub(&r.Y, &p.Y, &p.X)
	FeMul(&r.Z, &r.X, &q.yPlusX)
	FeMul(&r.Y, &r.Y, &q.yMinusX)
	FeMul(&r.T, &q.xy2d, &p.T)
	FeAdd(&t0, &p.Z, &p.Z)
	FeSub(&r.X, &r.Z, &r.Y)
	FeAdd(&r.Y, &r.Z, &r.Y)
	FeAdd(&r.Z, &t0, &r.T)
	FeSub(&r.T, &t0, &r.T)
}
pkg/crypto/internal/edwards25519.go:961: 961-974 lines are duplicate of `pkg/crypto/internal/edwards25519.go:946-959` (dupl)
func geMixedSub(r *CompletedGroupElement, p *ExtendedGroupElement, q *PreComputedGroupElement) {
	var t0 FieldElement

	FeAdd(&r.X, &p.Y, &p.X)
	FeSub(&r.Y, &p.Y, &p.X)
	FeMul(&r.Z, &r.X, &q.yMinusX)
	FeMul(&r.Y, &r.Y, &q.yPlusX)
	FeMul(&r.T, &q.xy2d, &p.T)
	FeAdd(&t0, &p.Z, &p.Z)
	FeSub(&r.X, &r.Z, &r.Y)
	FeAdd(&r.Y, &r.Z, &r.Y)
	FeSub(&r.Z, &t0, &r.T)
	FeAdd(&r.T, &t0, &r.T)
}
pkg/crypto/internal/edwards25519.go:132: Function 'FeToBytes' has too many statements (74 > 50) (funlen)
func FeToBytes(s *[32]byte, h *FieldElement) {
pkg/crypto/internal/edwards25519.go:1161: Function 'ScMulAdd' has too many statements (398 > 50) (funlen)
func ScMulAdd(s, a, b, c *[32]byte) {
pkg/crypto/internal/edwards25519.go:1594: Function 'ScReduce' has too many statements (293 > 50) (funlen)
func ScReduce(out *[32]byte, s *[64]byte) {
pkg/crypto/internal/edwards25519.go:976:1: cognitive complexity 33 of func `slide` is high (> 20) (gocognit)
func slide(r *[256]int8, a *[32]byte) {
^
pkg/crypto/internal/edwards25519.go:1010:72: captLocal: `A' should not be capitalized (gocritic)
func GeDoubleScalarMultVartime(r *ProjectiveGroupElement, a *[32]byte, A *ExtendedGroupElement, b *[32]byte) {
                                                                       ^
pkg/crypto/internal/edwards25519.go:1012:6: captLocal: `Ai' should not be capitalized (gocritic)
	var Ai [8]CachedGroupElement // A,3A,5A,7A,9A,11A,13A,15A
	    ^
pkg/crypto/internal/edwards25519.go:1014:9: captLocal: `A2' should not be capitalized (gocritic)
	var u, A2 ExtendedGroupElement
	       ^
pkg/crypto/internal/edwards25519.go:985:6: ifElseChain: rewrite if-else to switch statement (gocritic)
					if r[i]+(r[i+b]<<uint(b)) <= 15 {
					^
pkg/crypto/internal/edwards25519.go:1920:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if v > order[i] {
		^
pkg/crypto/internal/extra25519.go:93:57: captLocal: `A' should not be capitalized (gocritic)
func GeScalarMult(r *ExtendedGroupElement, a *[32]byte, A *ExtendedGroupElement) {
                                                        ^
pkg/crypto/internal/edwards25519.go:1932:77: Comment should end in a period (godot)
// ScClamp Sets and clears bits to make a random 32 bytes into a private key
                                                                            ^
pkg/crypto/internal/extra25519.go:3:54: Comment should end in a period (godot)
// FeMontgomeryXToEdwardsY compare to fe_montx_to_edy
                                                     ^
pkg/crypto/internal/extra25519.go:131:23: Comment should end in a period (godot)
// returns 0 otherwise
                      ^
pkg/crypto/internal/extra25519.go:194:54: Comment should end in a period (godot)
// representativeToMontgomeryX consumes the rr2 input
                                                     ^
pkg/crypto/internal/const.go:85: line is 121 characters (lll)
			FieldElement{-12815894, -12976347, -21581243, 11784320, -25355658, -2750717, -11717903, -3814571, -358445, -10211303},
pkg/crypto/internal/const.go:199: line is 121 characters (lll)
			FieldElement{31947069, -14366651, -4640583, -15339921, -15125977, -6039709, -14756777, -16411740, 19072640, -9511060},
pkg/crypto/internal/const.go:269: line is 121 characters (lll)
			FieldElement{-1580388, -11729417, -25979658, -11445023, -17411874, -10912854, 9291594, -16247779, -12154742, 6048605},
pkg/crypto/internal/const.go:283: line is 123 characters (lll)
			FieldElement{-19443170, -15512900, -20797467, -12445323, -29824447, 10229461, -27444329, -15000531, -5996870, 15664672},
pkg/crypto/internal/const.go:380: line is 121 characters (lll)
			FieldElement{-160783, -10326257, -22855316, -4304997, -20861367, -13621002, -32810901, -11181622, -15545091, 4387441},
pkg/crypto/internal/const.go:427: line is 121 characters (lll)
			FieldElement{-21911077, -5927941, -4611316, -5560156, -31744103, -10785293, 24123614, 15193618, -21652117, -16739389},
pkg/crypto/internal/const.go:468: line is 123 characters (lll)
			FieldElement{-29265967, -14186805, -13538216, -12117373, -19457059, -10655384, -31462369, -2948985, 24018831, 15026644},
pkg/crypto/internal/const.go:530: line is 121 characters (lll)
			FieldElement{-22751231, -5303997, -12907607, -12768866, -15811511, -7797053, -14839018, -16554220, -1867018, 8398970},
pkg/crypto/internal/const.go:596: line is 121 characters (lll)
			FieldElement{-6122061, -14866665, -28614905, 14569919, -10857999, -3591829, 10343412, -6976290, -29828287, -10815811},
pkg/crypto/internal/const.go:685: line is 121 characters (lll)
			FieldElement{29210088, -9419337, -5919792, -4952785, 10834811, -13327726, -16512102, -10820713, -27162222, -14030531},
pkg/crypto/internal/const.go:727: line is 121 characters (lll)
			FieldElement{14609123, -8954470, -6000566, -16622781, -14577387, -7743898, -26745169, 10942115, -25888931, -14884697},
pkg/crypto/internal/const.go:888: line is 121 characters (lll)
			FieldElement{12076899, -14301286, -8785001, -11848922, -25012791, 16400684, -17591495, -12899438, 3480665, -15182815},
pkg/crypto/internal/const.go:915: line is 121 characters (lll)
			FieldElement{18171223, -11934626, -12500402, 15197122, -11038147, -15230035, -19172240, -16046376, 8764035, 12309598},
pkg/crypto/internal/const.go:964: line is 121 characters (lll)
			FieldElement{-2453894, 15725973, -20436342, -10410672, -5803908, -11040220, -7135870, -11642895, 18047436, -15281743},
pkg/crypto/internal/const.go:967: line is 122 characters (lll)
			FieldElement{-25173001, -11307165, 29759956, 11776784, -22262383, -15820455, 10993114, -12850837, -17620701, -9408468},
pkg/crypto/internal/const.go:984: line is 121 characters (lll)
			FieldElement{-31241838, -15415700, -2994250, 8939346, 11562230, -12840670, -26064365, -11621720, -15405155, 11020693},
pkg/crypto/internal/const.go:1010: line is 121 characters (lll)
			FieldElement{22833440, 9293594, -32649448, -13618667, -9136966, 14756819, -22928859, -13970780, -10479804, -16197962},
pkg/crypto/internal/const.go:1083: line is 121 characters (lll)
			FieldElement{-28888365, 3510803, -28103278, -1158478, -11238128, -10631454, -15441463, -14453128, -1625486, -6494814},
pkg/crypto/internal/const.go:1109: line is 123 characters (lll)
			FieldElement{13669248, -16095482, -12481974, -10203039, -14569770, -11893198, -24995986, 11293807, -28588204, -9421832},
pkg/crypto/internal/const.go:1145: line is 122 characters (lll)
			FieldElement{-25817338, -3107312, -13494599, -3182506, 30896459, -13921729, -32251644, -12707869, -19464434, -3340243},
pkg/crypto/internal/const.go:1203: line is 121 characters (lll)
			FieldElement{11038231, -11582396, -27310482, -7316562, -10498527, -16307831, -23479533, -9371869, -21393143, 2465074},
pkg/crypto/internal/const.go:1236: line is 121 characters (lll)
			FieldElement{21426655, -5650218, -13648287, -5347537, -28812189, -4920970, -18275391, -14621414, 13040862, -12112948},
pkg/crypto/internal/edwards25519.go:982:3: `if r[i] != 0` has complex nested blocks (complexity: 8) (nestif)
		if r[i] != 0 {
		^
pkg/crypto/internal/const.go:11:5: d is a global variable (gochecknoglobals)
var d = FieldElement{
    ^
pkg/crypto/internal/const.go:16:5: d2 is a global variable (gochecknoglobals)
var d2 = FieldElement{
    ^
pkg/crypto/internal/const.go:21:5: SqrtM1 is a global variable (gochecknoglobals)
var SqrtM1 = FieldElement{
    ^
pkg/crypto/internal/const.go:26:5: A is a global variable (gochecknoglobals)
var A = FieldElement{
    ^
pkg/crypto/internal/const.go:32:5: bi is a global variable (gochecknoglobals)
var bi = [8]PreComputedGroupElement{
    ^
pkg/crypto/internal/const.go:77:5: base is a global variable (gochecknoglobals)
var base = [32][8]PreComputedGroupElement{
    ^
pkg/crypto/internal/edwards25519.go:18:5: zero is a global variable (gochecknoglobals)
var zero FieldElement
    ^
pkg/crypto/internal/edwards25519.go:1913:5: order is a global variable (gochecknoglobals)
var order = [4]uint64{0x5812631a5cf5d3ed, 0x14def9dea2f79cd6, 0, 0x1000000000000000}
    ^
pkg/crypto/internal/extra25519.go:37:5: lMinus1 is a global variable (gochecknoglobals)
var lMinus1 = [32]byte{0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
    ^
pkg/crypto/internal/edwards25519.go:1024:6: shadow: declaration of "i" shadows declaration at line 1015 (govet)
	for i := 0; i < 7; i++ {
	    ^
pkg/crypto/internal/extra25519.go:133:6: shadow: declaration of "zero" shadows declaration at line 18 (govet)
	var zero FieldElement
	    ^
pkg/crypto/internal/edwards25519.go:837:8: unusedwrite: unused write to array index 31:int - t59 (govet)
			tmp2[31-i] = v
			    ^
pkg/crypto/internal/edwards25519.go:884:8: unusedwrite: unused write to array index 31:int - t56 (govet)
			tmp2[31-i] = v
			    ^
pkg/crypto/internal/edwards25519.go:469:2: naked return in func `feSquare` with 37 lines of code (nakedret)
	return
	^
pkg/crypto/internal/edwards25519.go:433:1: named return "h0" with type "int64" found (nonamedreturns)
func feSquare(f *FieldElement) (h0, h1, h2, h3, h4, h5, h6, h7, h8, h9 int64) {
^
pkg/crypto/internal/edwards25519.go:1302:2: assigned to s23, but never used afterwards (wastedassign)
	s23 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1310:2: assigned to s22, but never used afterwards (wastedassign)
	s22 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1318:2: assigned to s21, but never used afterwards (wastedassign)
	s21 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1326:2: assigned to s20, but never used afterwards (wastedassign)
	s20 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1334:2: assigned to s19, but never used afterwards (wastedassign)
	s19 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1342:2: assigned to s18, but never used afterwards (wastedassign)
	s18 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1385:2: assigned to s17, but never used afterwards (wastedassign)
	s17 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1393:2: assigned to s16, but never used afterwards (wastedassign)
	s16 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1401:2: assigned to s15, but never used afterwards (wastedassign)
	s15 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1409:2: assigned to s14, but never used afterwards (wastedassign)
	s14 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1417:2: assigned to s13, but never used afterwards (wastedassign)
	s13 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1516:2: assigned to s12, but never used afterwards (wastedassign)
	s12 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1626:2: assigned to s23, but never used afterwards (wastedassign)
	s23 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1634:2: assigned to s22, but never used afterwards (wastedassign)
	s22 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1642:2: assigned to s21, but never used afterwards (wastedassign)
	s21 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1650:2: assigned to s20, but never used afterwards (wastedassign)
	s20 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1658:2: assigned to s19, but never used afterwards (wastedassign)
	s19 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1666:2: assigned to s18, but never used afterwards (wastedassign)
	s18 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1711:2: assigned to s17, but never used afterwards (wastedassign)
	s17 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1719:2: assigned to s16, but never used afterwards (wastedassign)
	s16 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1727:2: assigned to s15, but never used afterwards (wastedassign)
	s15 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1735:2: assigned to s14, but never used afterwards (wastedassign)
	s14 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1743:2: assigned to s13, but never used afterwards (wastedassign)
	s13 = 0 //nolint:golint,ineffassign
	^
pkg/crypto/internal/edwards25519.go:1842:2: assigned to s12, but never used afterwards (wastedassign)
	s12 = 0 //nolint:golint,ineffassign
	^
pkg/libs/ordered_blocks/optimistic_load.go:53:35: Comment should end in a period (godot)
// true - added, false - not added
                                  ^
pkg/libs/ordered_blocks/optimistic_load.go:68:34: Comment should end in a period (godot)
// blocks count available for pop
                                 ^
pkg/libs/ordered_blocks/optimistic_load.go:1:9: var-naming: don't use an underscore in package name (revive)
package ordered_blocks
        ^
cmd/retransmitter/retransmit/behaviour_test.go:17:58: Comment should end in a period (godot)
// if we send again same transaction, nothing will arrive
                                                         ^
cmd/retransmitter/retransmit/behaviour_test.go:64: unnecessary trailing newline (whitespace)

}
pkg/node/state_fsm/tasks/tasks.go:46:2: var-naming: don't use underscores in Go names; struct field type_ should be type (revive)
	type_ int
	^
pkg/node/state_fsm/tasks/tasks_test.go:1:9: package should be `tasks_test` instead of `tasks` (testpackage)
package tasks
        ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:46:7: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
			if err == io.EOF {
			   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:34:7: shadow: declaration of "err" shadows declaration at line 22 (govet)
			if err := dec.Decode(v); err != nil {
			   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:45:4: shadow: declaration of "err" shadows declaration at line 22 (govet)
			err := dec.Decode(&p)
			^
pkg/crypto/internal/groth16/bn256/verifying_key.go:63:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(&vk.G1.Alpha); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:66:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(&emptyG1Field); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:69:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(&vk.G2.Beta); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:72:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(&vk.G2.Gamma); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:75:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(&emptyG1Field); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:78:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(&vk.G2.Delta); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:83:5: shadow: declaration of "err" shadows declaration at line 59 (govet)
	if err := enc.Encode(vk.G1.Ic); err != nil {
	   ^
pkg/crypto/internal/groth16/bn256/verifying_key.go:56:2: naked return in func `ReadFrom` with 35 lines of code (nakedret)
	return
	^
pkg/crypto/internal/groth16/bn256/verifying_key.go:22:1: named return "n" with type "int64" found (nonamedreturns)
func (vk *BellmanVerifyingKeyBn256) ReadFrom(r io.Reader) (n int64, err error) {
^
pkg/crypto/internal/groth16/bn256/verifying_key.go:59:1: named return "n" with type "int64" found (nonamedreturns)
func (vk *BellmanVerifyingKeyBn256) WriteTo(w io.Writer) (n int64, err error) {
^
pkg/node/blocks_applier/blocks_applier_test.go:61:93: Comment should end in a period (godot)
// Emulate new blocks have error, so we can't accept them, and rollbacked blocks apply again
                                                                                            ^
pkg/node/blocks_applier/blocks_applier.go:1:9: var-naming: don't use an underscore in package name (revive)
package blocks_applier
        ^
pkg/node/blocks_applier/node_mocks.go:1:9: var-naming: don't use an underscore in package name (revive)
package blocks_applier
        ^
pkg/node/blocks_applier/blocks_applier_test.go:1:9: var-naming: don't use an underscore in package name (revive)
package blocks_applier
        ^
pkg/node/blocks_applier/node_mocks_test.go:1:9: var-naming: don't use an underscore in package name (revive)
package blocks_applier
        ^
pkg/node/blocks_applier/blocks_applier_test.go:16:5: var-naming: var genesisId should be genesisID (revive)
var genesisId = proto.NewBlockIDFromSignature(genesisSign)
    ^
pkg/node/blocks_applier/node_mocks.go:19:2: var-naming: don't use underscores in Go names; struct field Peers_ should be Peers (revive)
	Peers_          []proto.TCPAddr
	^
pkg/node/blocks_applier/node_mocks.go:230:28: var-naming: method ProvidesExtendedApi should be ProvidesExtendedAPI (revive)
func (a *MockStateManager) ProvidesExtendedApi() (bool, error) {
                           ^
pkg/node/blocks_applier/node_mocks.go:333:28: var-naming: method StartProvidingExtendedApi should be StartProvidingExtendedAPI (revive)
func (a *MockStateManager) StartProvidingExtendedApi() error {
                           ^
pkg/node/blocks_applier/blocks_applier_test.go:17:5: genesis is a global variable (gochecknoglobals)
var genesis = &proto.Block{
    ^
pkg/node/blocks_applier/blocks_applier.go:83:6: shadow: declaration of "err" shadows declaration at line 41 (govet)
		_, err := storage.AddDeserializedBlocks(blocks)
		   ^
pkg/node/blocks_applier/blocks_applier.go:98:10: shadow: declaration of "err" shadows declaration at line 41 (govet)
		block, err := storage.BlockByHeight(parentHeight + i)
		       ^
pkg/node/blocks_applier/node_mocks_test.go:13:2: shadow: declaration of "genesis" shadows declaration at line 17 (govet)
	genesis := &proto.Block{
	^
pkg/node/blocks_applier/node_mocks_test.go:29:2: shadow: declaration of "genesis" shadows declaration at line 17 (govet)
	genesis := &proto.Block{
	^
pkg/node/blocks_applier/node_mocks_test.go:59:2: shadow: declaration of "genesis" shadows declaration at line 17 (govet)
	genesis := &proto.Block{
	^
pkg/node/blocks_applier/node_mocks_test.go:76:2: shadow: declaration of "genesis" shadows declaration at line 17 (govet)
	genesis := &proto.Block{
	^
pkg/importer/importer.go:79:1: cognitive complexity 26 of func `ApplyFromFile` is high (> 20) (gocognit)
func ApplyFromFile(st State, blockchainPath string, nBlocks, startHeight uint64) error {
^
pkg/importer/importer.go:50:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if speed > prevSpeed && increasingSize {
	^
pkg/importer/importer.go:86:6: shadow: declaration of "err" shadows declaration at line 80 (govet)
		if err := blockchain.Close(); err != nil {
		   ^
pkg/importer/importer.go:99:9: shadow: declaration of "err" shadows declaration at line 80 (govet)
		if _, err := blockchain.ReadAt(sb, readPos); err != nil {
		      ^
pkg/importer/importer.go:113:9: shadow: declaration of "err" shadows declaration at line 80 (govet)
		if _, err := blockchain.ReadAt(block, readPos); err != nil {
		      ^
pkg/importer/importer.go:123:6: shadow: declaration of "err" shadows declaration at line 80 (govet)
		if err := st.AddBlocks(blocks[:blocksIndex]); err != nil {
		   ^
pkg/importer/importer.go:132:6: shadow: declaration of "err" shadows declaration at line 80 (govet)
		if err := maybePersistTxs(st); err != nil {
		   ^
pkg/importer/importer.go:151:5: shadow: declaration of "err" shadows declaration at line 139 (govet)
	if err := jsonParser.Decode(&state); err != nil {
	   ^
pkg/importer/importer.go:163:9: shadow: declaration of "err" shadows declaration at line 139 (govet)
		addr, err := proto.NewAddressFromString(addrStr)
		      ^
pkg/importer/importer.go:139:1: named return "err" with type "error" found (nonamedreturns)
func CheckBalances(st State, balancesPath string) (err error) {
^
pkg/libs/microblock_cache/microblock_cache.go:1:9: var-naming: don't use an underscore in package name (revive)
package microblock_cache
        ^
cmd/retransmitter/retransmit/utils/active_peers.go:10:16: Comment should end in a period (godot)
// Active peers
               ^
cmd/retransmitter/retransmit/utils/active_peers.go:24:32: Comment should end in a period (godot)
// check address already exists
                               ^
cmd/retransmitter/retransmit/utils/active_peers.go:32:29: Comment should end in a period (godot)
// add address to known list
                            ^
cmd/retransmitter/retransmit/utils/active_peers.go:41:27: Comment should end in a period (godot)
// get all known addresses
                          ^
cmd/retransmitter/retransmit/utils/active_peers.go:52:38: Comment should end in a period (godot)
// execute function with each address
                                     ^
cmd/retransmitter/retransmit/utils/active_peers.go:61:50: Comment should end in a period (godot)
// returns *PeerInfo by address, nil if not found
                                                 ^
cmd/retransmitter/retransmit/utils/active_peers.go:71:18: Comment should end in a period (godot)
// delete address
                 ^
cmd/retransmitter/retransmit/utils/counter.go:40:70: Comment should end in a period (godot)
// collect how many transaction we send (or tried to send) in an hour
                                                                     ^
cmd/retransmitter/retransmit/utils/counter.go:50:51: Comment should end in a period (godot)
// collect how many unique transaction we received
                                                  ^
cmd/retransmitter/retransmit/utils/spawned_peers_test.go:3: File is not `goimports`-ed (goimports)
import (
cmd/retransmitter/retransmit/utils/known_peers.go:26:6: var-naming: type JsonKnowPeerRow should be JSONKnowPeerRow (revive)
type JsonKnowPeerRow struct {
     ^
cmd/retransmitter/retransmit/utils/counter.go:45:2: increment-decrement: should replace cnt.TransactionsSend += 1 with cnt.TransactionsSend++ (revive)
	cnt.TransactionsSend += 1
	^
cmd/retransmitter/retransmit/utils/counter.go:55:2: increment-decrement: should replace cnt.UniqueTransaction += 1 with cnt.UniqueTransaction++ (revive)
	cnt.UniqueTransaction += 1
	^
cmd/retransmitter/retransmit/utils/known_peers.go:78:48: unnecessary conversion (unconvert)
		rs, err := proto.NewPeerInfoFromString(string(addr))
		                                             ^
cmd/retransmitter/retransmit/utils/active_peers_test.go:1:9: package should be `utils_test` instead of `utils` (testpackage)
package utils
        ^
cmd/retransmitter/retransmit/utils/counter_test.go:1:9: package should be `utils_test` instead of `utils` (testpackage)
package utils
        ^
cmd/retransmitter/retransmit/utils/known_peers_storage_test.go:1:9: package should be `utils_test` instead of `utils` (testpackage)
package utils
        ^
cmd/retransmitter/retransmit/utils/spawned_peers_test.go:1:9: package should be `utils_test` instead of `utils` (testpackage)
package utils
        ^
pkg/node/metrics.go:44:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/node/node.go:130:1: cognitive complexity 43 of func `(*Node).Run` is high (> 20) (gocognit)
func (a *Node) Run(ctx context.Context, p peer.Parent, internalMessageCh <-chan messages.InternalMessage) {
^
pkg/node/actions_by_type.go:82:58: Comment should end in a period (godot)
// SignaturesAction receives requested earlier signatures
                                                         ^
pkg/node/actions_by_type.go:92:53: Comment should end in a period (godot)
// GetSignaturesAction replies to signature requests
                                                    ^
pkg/node/actions_by_type_test.go:4: File is not `goimports`-ed (goimports)
	"github.com/wavesplatform/gowaves/pkg/node/peer_manager/storage"
pkg/node/metrics.go:13:2: Metric: messages_peers Error: counter metrics should have "_total" suffix (promlinter)
	prometheus.CounterOpts{
	^
pkg/node/metrics.go:21:2: Metric: messages_get_peers Error: counter metrics should have "_total" suffix (promlinter)
	prometheus.CounterOpts{
	^
pkg/node/metrics.go:29:2: Metric: messages_block Error: counter metrics should have "_total" suffix (promlinter)
	prometheus.CounterOpts{
	^
pkg/node/metrics.go:37:2: Metric: messages_get_block Error: counter metrics should have "_total" suffix (promlinter)
	prometheus.CounterOpts{
	^
pkg/node/helpers_test.go:5:25: unused-parameter: parameter 't' seems to be unused, consider removing or renaming it as _ (revive)
func TestSendSignatures(t *testing.T) {
                        ^
pkg/node/helpers.go:13:6: var-naming: func MaybeEnableExtendedApi should be MaybeEnableExtendedAPI (revive)
func MaybeEnableExtendedApi(state state.State, time types.Time) error {
     ^
pkg/node/helpers.go:18:6: var-naming: type startProvidingExtendedApi should be startProvidingExtendedAPI (revive)
type startProvidingExtendedApi interface {
     ^
pkg/node/helpers.go:22:6: var-naming: func maybeEnableExtendedApi should be maybeEnableExtendedAPI (revive)
func maybeEnableExtendedApi(state startProvidingExtendedApi, lastBlock *proto.Block, now proto.Timestamp) error {
     ^
pkg/node/node.go:122:14: type switch on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	switch e := err.(type) {
	            ^
pkg/node/metrics.go:5:5: metricInternalChannelSize is a global variable (gochecknoglobals)
var metricInternalChannelSize = prometheus.NewGauge(
    ^
pkg/node/metrics.go:12:5: metricPeersMessage is a global variable (gochecknoglobals)
var metricPeersMessage = prometheus.NewCounter(
    ^
pkg/node/metrics.go:20:5: metricGetPeersMessage is a global variable (gochecknoglobals)
var metricGetPeersMessage = prometheus.NewCounter(
    ^
pkg/node/metrics.go:28:5: metricBlockMessage is a global variable (gochecknoglobals)
var metricBlockMessage = prometheus.NewCounter(
    ^
pkg/node/metrics.go:36:5: metricGetBlockMessage is a global variable (gochecknoglobals)
var metricGetBlockMessage = prometheus.NewCounter(
    ^
pkg/node/actions_by_type.go:118:6: shadow: declaration of "err" shadows declaration at line 106 (govet)
		b, err := services.State.HeaderByHeight(height + uint64(i))
		   ^
pkg/node/actions_by_type.go:146:6: shadow: declaration of "err" shadows declaration at line 134 (govet)
		b, err := services.State.HeaderByHeight(height + uint64(i))
		   ^
pkg/node/node.go:96:6: shadow: declaration of "err" shadows declaration at line 91 (govet)
		if err := l.Close(); err != nil {
		   ^
pkg/node/node.go:103:9: shadow: declaration of "err" shadows declaration at line 91 (govet)
		conn, err := l.Accept()
		      ^
pkg/node/node.go:113:7: shadow: declaration of "err" shadows declaration at line 103 (govet)
			if err := a.peers.SpawnIncomingConnection(ctx, conn); err != nil {
			   ^
pkg/node/node.go:106:5: error is not nil (line 105) but it returns nil (nilerr)
				return nil
				^
pkg/node/actions_by_type_test.go:1:9: package should be `node_test` instead of `node` (testpackage)
package node
        ^
pkg/node/helpers_test.go:1:9: package should be `node_test` instead of `node` (testpackage)
package node
        ^
pkg/node/peer_manager/peer_manager.go:256:1: cognitive complexity 23 of func `(*PeerManagerImpl).SpawnOutgoingConnections` is high (> 20) (gocognit)
func (a *PeerManagerImpl) SpawnOutgoingConnections(ctx context.Context) {
^
pkg/node/peer_manager/peer_manager.go:286:10: elseif: can replace 'else {if cond {}}' with 'else if cond {}' (gocritic)
		} else {
		       ^
pkg/node/peer_manager/peer_manager.go:344:10: elseif: can replace 'else {if cond {}}' with 'else if cond {}' (gocritic)
		} else {
		       ^
pkg/node/peer_manager/spawner.go:49:41: captLocal: `WavesNetwork' should not be capitalized (gocritic)
func NewPeerSpawner(parent peer.Parent, WavesNetwork string, declAddr proto.TCPAddr, nodeName string, nodeNonce uint64, version proto.Version) *PeerSpawnerImpl {
                                        ^
pkg/node/peer_manager/peer_manager.go:447:19: Comment should end in a period (godot)
// non thread safe
                  ^
pkg/node/peer_manager/active_peers_test.go:1:9: var-naming: don't use an underscore in package name (revive)
package peer_manager
        ^
pkg/node/peer_manager/peer_storage_test.go:1:9: var-naming: don't use an underscore in package name (revive)
package peer_manager
        ^
pkg/node/peer_manager/active_peers.go:1:9: var-naming: don't use an underscore in package name (revive)
package peer_manager
        ^
pkg/node/peer_manager/peer_storage.go:1:9: var-naming: don't use an underscore in package name (revive)
package peer_manager
        ^
pkg/node/peer_manager/spawner.go:1:9: var-naming: don't use an underscore in package name (revive)
package peer_manager
        ^
pkg/node/peer_manager/peer_manager.go:1:9: var-naming: don't use an underscore in package name (revive)
package peer_manager
        ^
pkg/node/peer_manager/peer_manager.go:267:5: increment-decrement: should replace outCnt += 1 with outCnt++ (revive)
				outCnt += 1
				^
pkg/node/peer_manager/peer_manager.go:502:4: increment-decrement: should replace out += 1 with out++ (revive)
			out += 1
			^
pkg/node/peer_manager/peer_manager.go:504:4: increment-decrement: should replace in += 1 with in++ (revive)
			in += 1
			^
pkg/node/peer_manager/peer_manager.go:79: unnecessary leading newline (whitespace)
	blackListDuration time.Duration) *PeerManagerImpl {

pkg/node/peer_manager/peer_manager.go:316: unnecessary trailing newline (whitespace)

		}(ipPort)
pkg/node/peer_manager/peer_manager.go:113:3: shadow: declaration of "err" shadows declaration at line 95 (govet)
		err := errors.Errorf(
		^
pkg/node/peer_manager/peer_manager.go:124:3: shadow: declaration of "err" shadows declaration at line 95 (govet)
		err := errors.Errorf("peer '%s' has the invalid network name '%s', required '%s'",
		^
pkg/node/peer_manager/peer_manager.go:95:1: named return "err" with type "error" found (nonamedreturns)
func (a *PeerManagerImpl) NewConnection(p peer.Peer) (err error) {
^
pkg/ride/meta/meta.go:272:2: assignOp: replace `t = t ^ byte(list)` with `t ^= byte(list)` (gocritic)
	t = t ^ byte(list)
	^
itests/docker/docker.go:33:2: var-naming: const GrpcApiPort should be GrpcAPIPort (revive)
	GrpcApiPort = "6870"
	^
itests/docker/docker.go:53:2: var-naming: struct field RestApiPort should be RestAPIPort (revive)
	RestApiPort string
	^
itests/docker/docker.go:151: unnecessary trailing newline (whitespace)

		}
itests/docker/docker.go:254:15: shadow: declaration of "err" shadows declaration at line 180 (govet)
		nodeClient, err := client.NewClient(client.Options{
		            ^
itests/utilities/common_tx_utility.go:414:1: cognitive complexity 26 of func `GetTxIdsInBlockchain` is high (> 20) (gocognit)
func GetTxIdsInBlockchain(suite *f.BaseSuite, ids map[string]*crypto.Digest) map[string]string {
^
itests/utilities/common_tx_utility.go:182:9: appendAssign: append result not assigned to the same slice (gocritic)
	sum := append(binary, protobuf...)
	       ^
itests/utilities/common_tx_utility.go:206:20: G404: Use of weak random number generator (math/rand instead of crypto/rand) (gosec)
		b[j] = symbolSet[rand.Intn(len(symbolSet))]
		                 ^
itests/utilities/common_tx_utility.go:156:31: var-naming: func parameter txId should be txID (revive)
func NewConsideredTransaction(txId crypto.Digest, respGo, respScala *client.Response,
                              ^
itests/utilities/common_tx_utility.go:211:6: var-naming: func GetTransactionJsonOrErrMsg should be GetTransactionJSONOrErrMsg (revive)
func GetTransactionJsonOrErrMsg(tx proto.Transaction) string {
     ^
itests/utilities/common_tx_utility.go:320:50: var-naming: func parameter chainId should be chainID (revive)
func GetAddressWithNewSchema(suite *f.BaseSuite, chainId proto.Scheme, address proto.WavesAddress) proto.WavesAddress {
                                                 ^
itests/utilities/common_tx_utility.go:349:39: var-naming: func parameter assetId should be assetID (revive)
func GetAssetInfo(suite *f.BaseSuite, assetId crypto.Digest) *client.AssetsDetail {
                                      ^
itests/utilities/common_tx_utility.go:376:45: var-naming: func parameter assetId should be assetID (revive)
func GetAssetInfoGrpcGo(suite *f.BaseSuite, assetId crypto.Digest) *g.AssetInfoResponse {
                                            ^
itests/utilities/common_tx_utility.go:380:48: var-naming: func parameter assetId should be assetID (revive)
func GetAssetInfoGrpcScala(suite *f.BaseSuite, assetId crypto.Digest) *g.AssetInfoResponse {
                                               ^
itests/utilities/common_tx_utility.go:384:43: var-naming: func parameter assetId should be assetID (revive)
func GetAssetInfoGrpc(suite *f.BaseSuite, assetId crypto.Digest) (*g.AssetInfoResponse, *g.AssetInfoResponse) {
                                          ^
itests/utilities/common_tx_utility.go:388:72: var-naming: func parameter assetId should be assetID (revive)
func GetAssetBalanceGo(suite *f.BaseSuite, address proto.WavesAddress, assetId crypto.Digest) int64 {
                                                                       ^
itests/utilities/common_tx_utility.go:392:75: var-naming: func parameter assetId should be assetID (revive)
func GetAssetBalanceScala(suite *f.BaseSuite, address proto.WavesAddress, assetId crypto.Digest) int64 {
                                                                          ^
itests/utilities/common_tx_utility.go:396:70: var-naming: func parameter assetId should be assetID (revive)
func GetAssetBalance(suite *f.BaseSuite, address proto.WavesAddress, assetId crypto.Digest) (int64, int64) {
                                                                     ^
itests/utilities/common_tx_utility.go:468:9: indent-error-flow: if block ends with a return statement, so drop this else and outdent its block (revive)
	} else {
		return &proto.TransactionMessage{Transaction: bts}
	}
itests/utilities/common_tx_utility.go:496:35: var-declaration: should drop = nil from declaration of var respScala; it is the zero value (revive)
	var respScala *client.Response = nil
	                                 ^
itests/utilities/common_tx_utility.go:471: unnecessary trailing newline (whitespace)

}
pkg/proto/proto.go:1827: 1827-1897 lines are duplicate of `pkg/proto/proto.go:1923-1995` (dupl)
func (m *GetBlockIdsMessage) MarshalBinary() ([]byte, error) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(len(m.Blocks)))
	for _, bl := range m.Blocks {
		b := bl.Bytes()
		idLen := len(b)
		body = append(body, byte(idLen))
		body = append(body, b...)
	}

	var h Header
	h.Length = maxHeaderLength + uint32(len(body)) - 4
	h.Magic = headerMagic
	h.ContentID = ContentIDGetBlockIds
	h.PayloadLength = uint32(len(body))
	dig, err := crypto.FastHash(body)
	if err != nil {
		return nil, err
	}
	copy(h.PayloadChecksum[:], dig[:4])

	hdr, err := h.MarshalBinary()
	if err != nil {
		return nil, err
	}

	body = append(hdr, body...)

	return body, nil
}

func (m *GetBlockIdsMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 17 {
		return errors.New("GetBlockIdsMessage UnmarshalBinary: invalid data size")
	}
	var h Header
	if err := h.UnmarshalBinary(data); err != nil {
		return err
	}
	if h.Magic != headerMagic {
		return fmt.Errorf("wrong magic in Header: %x", h.Magic)
	}
	if h.ContentID != ContentIDGetBlockIds {
		return fmt.Errorf("wrong ContentID in Header: %x", h.ContentID)
	}
	data = data[17:]
	if len(data) < 4 {
		return fmt.Errorf("message too short %v", len(data))
	}
	blockCount := binary.BigEndian.Uint32(data[0:4])
	data = data[4:]
	pos := 0
	for i := uint32(0); i < blockCount; i++ {
		if len(data) < pos+1 {
			return fmt.Errorf("message too short %v", len(data))
		}
		idLen := int(data[pos])
		pos += 1
		if len(data[pos:]) < idLen {
			return fmt.Errorf("message too short %v", len(data))
		}
		id, err := NewBlockIDFromBytes(data[pos : pos+idLen])
		if err != nil {
			return errors.Wrap(err, "bad block id bytes")
		}
		m.Blocks = append(m.Blocks, id)
		pos += idLen
	}

	return nil
}
pkg/proto/proto.go:1923: 1923-1995 lines are duplicate of `pkg/proto/proto.go:1827-1897` (dupl)
func (m *BlockIdsMessage) MarshalBinary() ([]byte, error) {
	body := make([]byte, 4)
	binary.BigEndian.PutUint32(body[0:4], uint32(len(m.Blocks)))
	for _, bl := range m.Blocks {
		b := bl.Bytes()
		idLen := len(b)
		body = append(body, byte(idLen))
		body = append(body, b...)
	}

	var h Header
	h.Length = maxHeaderLength + uint32(len(body)) - 4
	h.Magic = headerMagic
	h.ContentID = ContentIDBlockIds
	h.PayloadLength = uint32(len(body))
	dig, err := crypto.FastHash(body)
	if err != nil {
		return nil, err
	}
	copy(h.PayloadChecksum[:], dig[:4])

	hdr, err := h.MarshalBinary()
	if err != nil {
		return nil, err
	}

	body = append(hdr, body...)

	return body, nil
}

func (m *BlockIdsMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 17 {
		return errors.New("BlockIdsMessage UnmarshalBinary: invalid data size")
	}
	var h Header

	if err := h.UnmarshalBinary(data); err != nil {
		return err
	}
	if h.Magic != headerMagic {
		return fmt.Errorf("wrong magic in Header: %x", h.Magic)
	}
	if h.ContentID != ContentIDBlockIds {
		return fmt.Errorf("wrong ContentID in Header: %x", h.ContentID)
	}
	data = data[17:]
	if len(data) < 4 {
		return fmt.Errorf("message too short %v", len(data))
	}
	idsCount := binary.BigEndian.Uint32(data[0:4])
	data = data[4:]

	offset := 0
	for i := uint32(0); i < idsCount; i++ {
		if len(data) < offset+1 {
			return fmt.Errorf("message too short: %v", len(data))
		}
		idLen := int(data[offset])
		offset += 1
		if len(data[offset:]) < idLen {
			return fmt.Errorf("message too short: %v", len(data))
		}
		id, err := NewBlockIDFromBytes(data[offset : offset+idLen])
		if err != nil {
			return errors.Wrap(err, "bad block id bytes")
		}
		m.Blocks = append(m.Blocks, id)
		offset += idLen
	}

	return nil
}
pkg/proto/transactions_with_proofs.go:3659: 3659-3687 lines are duplicate of `pkg/proto/transactions_with_proofs.go:4252-4280` (dupl)
func (tx *SetScriptWithProofs) UnmarshalBinary(data []byte, scheme Scheme) error {
	if l := len(data); l < setScriptWithProofsMinLen {
		return errors.Errorf("not enough data for SetScriptWithProofs transaction, expected not less then %d, received %d", setScriptWithProofsMinLen, l)
	}
	if v := data[0]; v != 0 {
		return errors.Errorf("unexpected first byte value %d, expected 0", v)
	}
	data = data[1:]
	err := tx.bodyUnmarshalBinary(data, scheme)
	if err != nil {
		return errors.Wrap(err, "failed to unmarshal SetScriptWithProofs transaction from bytes")
	}
	sl := 0
	if tx.NonEmptyScript() {
		sl = len(tx.Script) + 2
	}
	bl := setScriptWithProofsFixedBodyLen + sl
	data = data[bl:]
	var p ProofsV1
	err = p.UnmarshalBinary(data)
	if err != nil {
		return errors.Wrap(err, "failed to unmarshal SetScriptWithProofs transaction from bytes")
	}
	tx.Proofs = &p
	if err := tx.GenerateID(scheme); err != nil {
		return err
	}
	return nil
}
pkg/proto/transactions_with_proofs.go:4252: 4252-4280 lines are duplicate of `pkg/proto/transactions_with_proofs.go:3659-3687` (dupl)
func (tx *SetAssetScriptWithProofs) UnmarshalBinary(data []byte, scheme Scheme) error {
	if l := len(data); l < setAssetScriptWithProofsMinLen {
		return errors.Errorf("not enough data for SetAssetScriptWithProofs transaction, expected not less then %d, received %d", setAssetScriptWithProofsMinLen, l)
	}
	if v := data[0]; v != 0 {
		return errors.Errorf("unexpected first byte value %d, expected 0", v)
	}
	data = data[1:]
	err := tx.bodyUnmarshalBinary(data, scheme)
	if err != nil {
		return errors.Wrap(err, "failed to unmarshal SetAssetScriptWithProofs transaction from bytes")
	}
	sl := 0
	if tx.NonEmptyScript() {
		sl = len(tx.Script) + 2
	}
	bl := setAssetScriptWithProofsFixedBodyLen + sl
	data = data[bl:]
	var p ProofsV1
	err = p.UnmarshalBinary(data)
	if err != nil {
		return errors.Wrap(err, "failed to unmarshal SetAssetScriptWithProofs transaction from bytes")
	}
	tx.Proofs = &p
	if err := tx.GenerateID(scheme); err != nil {
		return err
	}
	return nil
}
pkg/proto/protobuf_converters.go:734: Function 'Transaction' has too many statements (104 > 50) (funlen)
func (c *ProtobufConverter) Transaction(tx *g.Transaction) (Transaction, error) {
pkg/proto/protobuf_converters.go:1138: Function 'signedTransaction' has too many statements (124 > 50) (funlen)
func (c *ProtobufConverter) signedTransaction(stx *g.SignedTransaction) (Transaction, error) {
pkg/proto/transactions_with_proofs.go:1421: Function 'Validate' has too many statements (51 > 50) (funlen)
func (tx *ExchangeWithProofs) Validate(_ Scheme) (Transaction, error) {
pkg/proto/eth_typed_data.go:159:1: cognitive complexity 38 of func `(*ethereumTypedData).EncodeData` is high (> 20) (gocognit)
func (typedData *ethereumTypedData) EncodeData(primaryType string, data map[string]interface{}, depth int) ([]byte, error) {
^
pkg/proto/eth_typed_data.go:340:1: cognitive complexity 30 of func `(*ethereumTypedData).EncodePrimitiveValue` is high (> 20) (gocognit)
func (typedData *ethereumTypedData) EncodePrimitiveValue(encType string, encValue interface{}, depth int) ([]byte, error) {
^
pkg/proto/actions_validator.go:269:1: cognitive complexity 29 of func `ValidateActions` is high (> 20) (gocognit)
func ValidateActions(
^
pkg/proto/transactions_with_sig.go:1154:1: cognitive complexity 27 of func `(*ExchangeWithSig).Validate` is high (> 20) (gocognit)
func (tx *ExchangeWithSig) Validate(_ Scheme) (Transaction, error) {
^
pkg/proto/eth_typed_data.go:553:1: cognitive complexity 26 of func `(ethereumTypedDataTypes).validate` is high (> 20) (gocognit)
func (t ethereumTypedDataTypes) validate() error {
^
pkg/proto/transactions.go:329:1: cognitive complexity 26 of func `GuessTransactionType` is high (> 20) (gocognit)
func GuessTransactionType(t *TransactionTypeVersion) (Transaction, error) {
^
pkg/proto/eth_typed_data.go:249:1: cognitive complexity 22 of func `parseInteger` is high (> 20) (gocognit)
func parseInteger(encType string, encValue interface{}) (*big.Int, error) {
^
pkg/proto/transactions_test.go:5213:1: cognitive complexity 21 of func `TestDataWithProofsProtobufRoundTrip` is high (> 20) (gocognit)
func TestDataWithProofsProtobufRoundTrip(t *testing.T) {
^
pkg/proto/transactions_test.go:5313:1: cognitive complexity 21 of func `TestDataWithProofsBinaryRoundTrip` is high (> 20) (gocognit)
func TestDataWithProofsBinaryRoundTrip(t *testing.T) {
^
pkg/proto/types.go:2211:10: string `boolean` has 4 occurrences, make it a constant (goconst)
		return "boolean"
		       ^
pkg/proto/addresses.go:498:10: string `null` has 12 occurrences, but such constant `jsonNull` already exists (goconst)
	if s == "null" {
	        ^
pkg/proto/types.go:2209:10: string `integer` has 4 occurrences, make it a constant (goconst)
		return "integer"
		       ^
pkg/proto/eth_typed_data.go:366:7: string `string` has 5 occurrences, make it a constant (goconst)
	case "string":
	     ^
pkg/proto/types.go:2213:10: string `binary` has 4 occurrences, make it a constant (goconst)
		return "binary"
		       ^
pkg/proto/addresses.go:183:4: assignOp: replace `hashByte = hashByte >> 4` with `hashByte >>= 4` (gocritic)
			hashByte = hashByte >> 4
			^
pkg/proto/addresses.go:191:9: unslice: could simplify buf[:] to buf (gocritic)
	return buf[:]
	       ^
pkg/proto/block.go:87:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if len(data) == crypto.SignatureSize {
	^
pkg/proto/eth_signer.go:385:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//panic("Unsupported transaction type: %d", tx.typ)
		^
pkg/proto/eth_signer.go:488:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//panic("Unsupported transaction type: %d", tx.typ)
		^
pkg/proto/eth_transaction.go:685:19: captLocal: `V' should not be capitalized (gocritic)
func isProtectedV(V *big.Int) bool {
                  ^
pkg/proto/eth_typed_data.go:178:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if encType[len(encType)-1:] == "]" {
		^
pkg/proto/microblock.go:480:31: captLocal: `PublicKey' should not be capitalized (gocritic)
func NewUnsignedMicroblockInv(PublicKey crypto.PublicKey, TotalBlockID BlockID, Reference BlockID) *MicroBlockInv {
                              ^
pkg/proto/proto.go:919:9: appendAssign: append result not assigned to the same slice (gocritic)
	out := append(hdr, buf.Bytes()...)
	       ^
pkg/proto/proto.go:354:2: assignOp: replace `ip = ip | uint64(a.Port)` with `ip |= uint64(a.Port)` (gocritic)
	ip = ip | uint64(a.Port)
	^
pkg/proto/proto.go:1012:2: captLocal: `Peers' should not be capitalized (gocritic)
	Peers := make([]PeerInfo, length)
	^
pkg/proto/proto.go:1250:31: captLocal: `ContentID' should not be capitalized (gocritic)
func parsePacket(data []byte, ContentID PeerMessageID, name string, f func(payload []byte) error) error {
                              ^
pkg/proto/proto.go:995:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//packet, nn, err := readPacket(r)
	^
pkg/proto/proto.go:296:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if a < b {
		^
pkg/proto/proto.go:307:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if x < 0 {
	^
pkg/proto/proto.go:310:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if y < 0 {
		^
pkg/proto/transactions_with_proofs.go:1985:13: commentFormatting: put a space between `//` and comment text (gocritic)
	buf[2] = 0 //Always zero, reserved for future extension of leasing assets.
	           ^
pkg/proto/types.go:31:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//WavesAssetName is the default name for basic WAVES asset.
	^
pkg/proto/proto_test.go:31:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//comparable
	^
pkg/proto/proto_test.go:165:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:177:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:182:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:187:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:192:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:197:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:202:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:207:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:212:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:217:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:222:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//P. Len |    Magic | ContentID | Payload Length | PayloadChecksum | Payload
		^
pkg/proto/proto_test.go:230:15: wrapperFunc: use strings.ReplaceAll method in `strings.Replace(v.testEncoded, " ", "", -1)` (gocritic)
			trimmed := strings.Replace(v.testEncoded, " ", "", -1)
			           ^
pkg/proto/transactions_test.go:5107:34: commentFormatting: put a space between `//` and comment text (gocritic)
		assert.Error(t, err, "#%d", i) //, tc.err, fmt.Sprintf("expected: %s", tc.err))
		                               ^
pkg/proto/transactions_test.go:5108:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//assert.EqualError(t, err, tc.err, fmt.Sprintf("expected: %s", tc.err))
		^
pkg/proto/types_test.go:90:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//waves, err := NewOptionalAssetFromString("WAVES")
	^
pkg/proto/types_test.go:113:3: commentFormatting: put a space between `//` and comment text (gocritic)
		//{*aa, *waves, Buy, math.MaxInt64, MaxOrderAmount, 1000, 1, 1, "spend amount is too large"},
		^
pkg/proto/types_test.go:338:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//waves, err := NewOptionalAssetFromString("WAVES")
	^
pkg/proto/block.go:161:68: Comment should end in a period (godot)
// BlockHeader contains Block meta-information without transactions
                                                                   ^
pkg/proto/block.go:419:38: Comment should end in a period (godot)
// Block is a block of the blockchain
                                     ^
pkg/proto/block.go:512:46: Comment should end in a period (godot)
// MarshalBinary encodes Block to binary form
                                             ^
pkg/proto/block.go:647:50: Comment should end in a period (godot)
// UnmarshalBinary decodes Block from binary form
                                                 ^
pkg/proto/block.go:771:70: Comment should end in a period (godot)
// BlockGetSignature get signature from block without deserialization
                                                                     ^
pkg/proto/eth_hash.go:11:65: Comment should end in a period (godot)
	// EthereumHashSize is the expected length of the hash in bytes
	                                                               ^
pkg/proto/eth_math.go:8:34: Comment should end in a period (godot)
// Common big integers often used
                                 ^
pkg/proto/eth_math.go:23:33: Comment should end in a period (godot)
	// number of bits in a big.Word
	                               ^
pkg/proto/eth_math.go:25:34: Comment should end in a period (godot)
	// number of bytes in a big.Word
	                                ^
pkg/proto/eth_math.go:32:52: Comment should end in a period (godot)
// newHexOrDecimal256 creates a new hexOrDecimal256
                                                   ^
pkg/proto/eth_signer.go:170:88: Comment should end in a period (godot)
// londonSigner is a main signer after the London hardfork (hardfork date - 05.08.2021)
                                                                                       ^
pkg/proto/eth_signer.go:242:17: Comment should end in a period (godot)
// BERLIN signer
                ^
pkg/proto/eth_transaction.go:18:94: Comment should end in a period (godot)
// EthereumGasPrice is a constant GasPrice which equals 10GWei according to the specification
                                                                                             ^
pkg/proto/eth_transaction.go:229:83: Comment should end in a period (godot)
// NewEthereumTransaction is a utility function which should be used ONLY in tests
                                                                                  ^
pkg/proto/eth_transaction.go:288:52: Comment should end in a period (godot)
// For basic transaction checks use Validate method
                                                   ^
pkg/proto/eth_transaction.go:303:100: Comment should end in a period (godot)
// This method doesn't include signature verification. Use Verify method for signature verification
                                                                                                   ^
pkg/proto/eth_transaction_signing.go:7:65: Comment should end in a period (godot)
// deriveChainId derives the chain id from the given v parameter
                                                                ^
pkg/proto/eth_typed_data.go:27:32: Comment should end in a period (godot)
// this method returns 'Person'
                               ^
pkg/proto/eth_typed_data.go:81:81: Comment should end in a period (godot)
// HashStructMap generates a keccak256 hash of the encoding of the provided data
                                                                                ^
pkg/proto/eth_typed_data.go:92:94: Comment should end in a period (godot)
// Dependencies returns an array of custom types ordered by their hierarchical reference tree
                                                                                             ^
pkg/proto/eth_typed_data.go:123:99: Comment should end in a period (godot)
// each member is written as `type ‖ " " ‖ name` encodings cascade down and are sorted by name
                                                                                                  ^
pkg/proto/eth_typed_data.go:150:52: Comment should end in a period (godot)
// TypeHash creates the keccak256 hash  of the data
                                                   ^
pkg/proto/eth_typed_data.go:158:39: Comment should end in a period (godot)
// each encoded member is 32-byte long
                                      ^
pkg/proto/eth_typed_data.go:339:42: Comment should end in a period (godot)
// while searching through the typed data
                                         ^
pkg/proto/eth_typed_data.go:409:30: Comment should end in a period (godot)
// the provided type and data
                             ^
pkg/proto/eth_typed_data.go:414:43: Comment should end in a period (godot)
// validate makes sure the types are sound
                                          ^
pkg/proto/eth_typed_data.go:425:49: Comment should end in a period (godot)
// Map generates a map version of the typed data
                                                ^
pkg/proto/eth_typed_data.go:546:42: Comment should end in a period (godot)
// Checks if the primitive value is valid
                                         ^
pkg/proto/block.go:312:9: append to slice `res` with non-zero initialized length (makezero)
		res = append(res, buf...)
		      ^
pkg/proto/block.go:318:9: append to slice `res` with non-zero initialized length (makezero)
		res = append(res, fb...)
		      ^
pkg/proto/block.go:322:10: append to slice `res` with non-zero initialized length (makezero)
			res = append(res, rvb...)
			      ^
pkg/proto/block.go:325:9: append to slice `res` with non-zero initialized length (makezero)
		res = append(res, byte(b.TransactionCount))
		      ^
pkg/proto/block.go:327:8: append to slice `res` with non-zero initialized length (makezero)
	res = append(res, b.GeneratorPublicKey[:]...)
	      ^
pkg/proto/block.go:328:8: append to slice `res` with non-zero initialized length (makezero)
	res = append(res, b.BlockSignature[:]...)
	      ^
pkg/proto/proto.go:1833:10: append to slice `body` with non-zero initialized length (makezero)
		body = append(body, byte(idLen))
		       ^
pkg/proto/proto.go:1834:10: append to slice `body` with non-zero initialized length (makezero)
		body = append(body, b...)
		       ^
pkg/proto/proto.go:1929:10: append to slice `body` with non-zero initialized length (makezero)
		body = append(body, byte(idLen))
		       ^
pkg/proto/proto.go:1930:10: append to slice `body` with non-zero initialized length (makezero)
		body = append(body, b...)
		       ^
pkg/proto/transactions_test.go:4832:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, t)
			    ^
pkg/proto/transactions_test.go:6083:8: append to slice `r` with non-zero initialized length (makezero)
			r = append(r, arg)
			    ^
pkg/proto/block.go:675:2: `if b.Version >= NgBlockVersion` has complex nested blocks (complexity: 7) (nestif)
	if b.Version >= NgBlockVersion {
	^
pkg/proto/transactions.go:276:2: `if tx[0] == 0` has complex nested blocks (complexity: 7) (nestif)
	if tx[0] == 0 {
	^
pkg/proto/types_test.go:189:3: `if assert.NoError(t, err)` has complex nested blocks (complexity: 7) (nestif)
		if err := o.Sign(TestNetScheme, sk); assert.NoError(t, err) {
		^
pkg/proto/scripting_test.go:182:3: `if assert.NoError(t, err)` has complex nested blocks (complexity: 6) (nestif)
		if msg, err := test.ToProtobuf(); assert.NoError(t, err) {
		^
pkg/proto/transactions_test.go:496:2: `if assert.NoError(t, err)` has complex nested blocks (complexity: 6) (nestif)
	if s, err := base58.Decode("3TUPTbbpiM5UmZDhMmzdsKKNgMvyHwZQncKWfJrxk3bc"); assert.NoError(t, err) {
	^
pkg/proto/actions_validator.go:151:2: `if restrictions.DisableSelfTransfers` has complex nested blocks (complexity: 5) (nestif)
	if restrictions.DisableSelfTransfers {
	^
pkg/proto/actions_validator.go:206:2: `if restrictions.DisableSelfTransfers` has complex nested blocks (complexity: 5) (nestif)
	if restrictions.DisableSelfTransfers {
	^
pkg/proto/block.go:359:2: `if b.Version >= NgBlockVersion` has complex nested blocks (complexity: 5) (nestif)
	if b.Version >= NgBlockVersion {
	^
pkg/proto/microblock.go:411:2: `if hashId` has complex nested blocks (complexity: 5) (nestif)
	if hashId {
	^
pkg/proto/transactions_test.go:417:3: `if assert.NoError(t, err)` has complex nested blocks (complexity: 5) (nestif)
		if assert.NoError(t, err) {
		^
pkg/proto/eth_signer.go:497:34: `decodeSignature` - `legacyV` always receives `true` (unparam)
func decodeSignature(sig []byte, legacyV bool) (r, s, v *big.Int, err error) {
                                 ^
pkg/proto/protobuf_converters.go:108:47: `(*ProtobufConverter).byte` - `context` always receives `nil` (unparam)
func (c *ProtobufConverter) byte(value int32, context ...string) byte {
                                              ^
pkg/proto/scripting_test.go:449:30: `mustRecipientFromString` - `s` always receives `"3Me8JF8fhugSSa2Kx4w7v2tX377sTVtKSU5"` (unparam)
func mustRecipientFromString(s string) Recipient {
                             ^
pkg/proto/transactions.go:803:50: (*Payment).bodyMarshalBinary - result 0 (error) is always nil (unparam)
func (tx *Payment) bodyMarshalBinary(buf []byte) error {
                                                 ^
pkg/proto/transactions.go:1058:41: (Issue).marshalBinary - result 1 (error) is always nil (unparam)
func (i Issue) marshalBinary() ([]byte, error) {
                                        ^
pkg/proto/transactions.go:1377:44: (*Reissue).marshalBinary - result 1 (error) is always nil (unparam)
func (r *Reissue) marshalBinary() ([]byte, error) {
                                           ^
pkg/proto/transactions.go:1463:41: (*Burn).marshalBinary - result 1 (error) is always nil (unparam)
func (b *Burn) marshalBinary() ([]byte, error) {
                                        ^
pkg/proto/transactions.go:1663:49: (*LeaseCancel).marshalBinary - result 1 (error) is always nil (unparam)
func (lc *LeaseCancel) marshalBinary() ([]byte, error) {
                                                ^
pkg/proto/eth_typed_data.go:83: unnecessary leading newline (whitespace)
	data map[string]interface{}) (EthereumHash, error) {

pkg/proto/eth_typed_data.go:405: unnecessary trailing newline (whitespace)

}
pkg/proto/proto.go:1570: unnecessary trailing newline (whitespace)

}
pkg/proto/proto.go:1819: unnecessary trailing newline (whitespace)

}
pkg/proto/transactions_with_proofs.go:2245: unnecessary trailing newline (whitespace)

	}
pkg/proto/transactions_with_sig.go:1831: unnecessary trailing newline (whitespace)

	}
pkg/proto/addresses_test.go:253: unnecessary trailing newline (whitespace)

}
pkg/proto/transactions_test.go:427: unnecessary trailing newline (whitespace)

				}
pkg/proto/types_test.go:1231: unnecessary trailing newline (whitespace)

}
pkg/proto/errors.go:5:6: the type name `InfoMsg` should conform to the `XxxError` format (errname)
type InfoMsg struct {
     ^
pkg/proto/eth_signer.go:478:2: missing cases in switch of type proto.EthereumTxType: proto.UndefinedTxType (exhaustive)
	switch tx.EthereumTxType() {
	^
pkg/proto/eth_transaction.go:33:2: missing cases in switch of type proto.EthereumTxType: proto.UndefinedTxType (exhaustive)
	switch e {
	^
pkg/proto/eth_transaction.go:649:2: missing cases in switch of type proto.EthereumTxType: proto.EthereumLegacyTxType, proto.UndefinedTxType (exhaustive)
	switch txType, rlpData := canonicalData[0], canonicalData[1:]; EthereumTxType(txType) {
	^
pkg/proto/transactions.go:172:2: missing cases in switch of type proto.TransactionType: proto.GenesisTransaction, proto.PaymentTransaction, proto.IssueTransaction, proto.ReissueTransaction, proto.BurnTransaction, proto.ExchangeTransaction, proto.LeaseTransaction, proto.LeaseCancelTransaction, proto.CreateAliasTransaction, proto.MassTransferTransaction, proto.DataTransaction, proto.SetScriptTransaction, proto.SponsorshipTransaction, proto.SetAssetScriptTransaction, proto.InvokeScriptTransaction, proto.UpdateAssetInfoTransaction, proto.EthereumMetamaskTransaction, proto.InvokeExpressionTransaction (exhaustive)
	switch a.Type {
	^
pkg/proto/transactions.go:331:2: missing cases in switch of type proto.TransactionType: proto.InvokeExpressionTransaction (exhaustive)
	switch t.Type {
	^
pkg/proto/transactions_with_proofs.go:3244:3: missing cases in switch of type proto.DataValueType: proto.DataDelete (exhaustive)
		switch t {
		^
pkg/proto/types.go:580:2: missing cases in switch of type proto.OrderPriceMode: proto.OrderPriceModeFixedDecimals, proto.OrderPriceModeAssetDecimals (exhaustive)
	switch m {
	^
pkg/proto/types.go:3145:2: missing cases in switch of type proto.ArgumentValueType: proto.ArgumentValueTrue, proto.ArgumentValueFalse (exhaustive)
	switch vt {
	^
pkg/proto/types.go:3276:3: missing cases in switch of type proto.ArgumentValueType: proto.ArgumentBoolean (exhaustive)
		switch ArgumentValueType(data[0]) {
		^
pkg/proto/transactions_test.go:5231:4: missing cases in switch of type proto.DataValueType: proto.DataDelete (exhaustive)
			switch DataValueType(tc.types[i]) {
			^
pkg/proto/transactions_test.go:5289:4: missing cases in switch of type proto.DataValueType: proto.DataDelete (exhaustive)
			switch DataValueType(tc.types[i]) {
			^
pkg/proto/transactions_test.go:5331:4: missing cases in switch of type proto.DataValueType: proto.DataDelete (exhaustive)
			switch DataValueType(tc.types[i]) {
			^
pkg/proto/transactions_test.go:5405:4: missing cases in switch of type proto.DataValueType: proto.DataDelete (exhaustive)
			switch DataValueType(tc.types[i]) {
			^
pkg/proto/transactions.go:103:26: missing keys in map of key type proto.TransactionType: proto.GenesisTransaction, proto.PaymentTransaction, proto.MassTransferTransaction, proto.UpdateAssetInfoTransaction, proto.EthereumMetamaskTransaction, proto.InvokeExpressionTransaction (exhaustive)
	bytesToTransactionsV2 = map[TransactionType]reflect.Type{
	                        ^
pkg/proto/transactions.go:119:26: missing keys in map of key type proto.TransactionType: proto.DataTransaction, proto.SetScriptTransaction, proto.SponsorshipTransaction, proto.SetAssetScriptTransaction, proto.InvokeScriptTransaction, proto.UpdateAssetInfoTransaction, proto.EthereumMetamaskTransaction, proto.InvokeExpressionTransaction (exhaustive)
	bytesToTransactionsV1 = map[TransactionType]reflect.Type{
	                        ^
pkg/proto/eth_crypto.go:13:2: secp256k1N is a global variable (gochecknoglobals)
	secp256k1N, _  = new(big.Int).SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)
	^
pkg/proto/eth_crypto.go:14:2: secp256k1halfN is a global variable (gochecknoglobals)
	secp256k1halfN = new(big.Int).Div(secp256k1N, big2)
	^
pkg/proto/types.go:2003:6: `ProofsV1` should be annotated with the `json` tag as it is passed to `json.Unmarshal` at pkg/proto/transactions_with_proofs.go:698:12 (musttag)
type ProofsV1 struct {
     ^
pkg/proto/types.go:285:6: `OptionalAsset` should be annotated with the `json` tag as it is passed to `json.Unmarshal` at pkg/proto/transactions_with_sig.go:556:12 (musttag)
type OptionalAsset struct {
     ^
pkg/proto/eth_transaction.go:221:6: `EthereumTransaction` should be annotated with the `json` tag as it is passed to `json.Unmarshal` at pkg/proto/eth_transaction_test.go:103:9 (musttag)
type EthereumTransaction struct {
     ^
pkg/proto/proto.go:733:6: `PeerInfo` should be annotated with the `json` tag as it is passed to `json.Marshal` at pkg/proto/proto_test.go:269:13 (musttag)
type PeerInfo struct {
     ^
pkg/proto/addresses.go:437:6: `Alias` should be annotated with the `json` tag as it is passed to `json.Unmarshal` at pkg/proto/transactions_test.go:4554:10 (musttag)
type Alias struct {
     ^
pkg/proto/types.go:4006:6: `StateHash` should be annotated with the `json` tag as it is passed to `json.Unmarshal` at pkg/proto/types_test.go:2095:10 (musttag)
type StateHash struct {
     ^
pkg/proto/eth_typed_data.go:76:3: error is not nil (line 74) but it returns nil (nilerr)
		return EthereumHash{}, nil
		^
pkg/proto/addresses.go:218:1: named return "text" with type "[]byte" found (nonamedreturns)
func (a WavesAddress) MarshalText() (text []byte, err error) {
^
pkg/proto/addresses.go:427:1: named return "cs" with type "[wavesAddressChecksumSize]byte" found (nonamedreturns)
func addressChecksum(b []byte) (cs [wavesAddressChecksumSize]byte, err error) {
^
pkg/proto/addresses.go:666:1: named return "data" with type "[]byte" found (nonamedreturns)
func (r *aliasRecipient) MarshalBinary() (data []byte, err error) {
^
pkg/proto/addresses.go:721:1: named return "data" with type "[]byte" found (nonamedreturns)
func (r *wavesAddressRecipient) MarshalBinary() (data []byte, err error) {
^
pkg/proto/eth_access_list_tx.go:257:1: named return "v" with type "*big.Int" found (nonamedreturns)
func (tx *EthereumAccessListTx) rawSignatureValues() (v, r, s *big.Int) {
^
pkg/proto/eth_crypto.go:68:1: named return "ethSig" with type "EthereumSignature" found (nonamedreturns)
func NewEthereumSignatureFromHexString(hexString string) (ethSig EthereumSignature, err error) {
^
pkg/proto/eth_crypto.go:76:1: named return "ethSig" with type "EthereumSignature" found (nonamedreturns)
func NewEthereumSignatureFromBytes(b []byte) (ethSig EthereumSignature, err error) {
^
pkg/proto/eth_crypto.go:94:1: named return "v" with type "byte" found (nonamedreturns)
func (es *EthereumSignature) AsVRS() (v byte, r, s *big.Int) {
^
pkg/proto/eth_crypto.go:118:1: named return "data" with type "[]byte" found (nonamedreturns)
func (es *EthereumSignature) MarshalBinary() (data []byte, err error) {
^
pkg/proto/eth_dynamic_fee_tx.go:178:1: named return "v" with type "*big.Int" found (nonamedreturns)
func (tx *EthereumDynamicFeeTx) rawSignatureValues() (v, r, s *big.Int) {
^
pkg/proto/eth_legacy_tx.go:153:1: named return "v" with type "*big.Int" found (nonamedreturns)
func (tx *EthereumLegacyTx) rawSignatureValues() (v, r, s *big.Int) {
^
pkg/proto/eth_signer.go:84:1: named return "data" with type "[]byte" found (nonamedreturns)
func (epk *EthereumPublicKey) MarshalBinary() (data []byte, err error) {
^
pkg/proto/eth_signer.go:209:1: named return "r" with type "*big.Int" found (nonamedreturns)
func (ls londonSigner) SignatureValues(tx *EthereumTransaction, sig []byte) (r, s, v *big.Int, err error) {
^
pkg/proto/eth_signer.go:278:1: named return "r" with type "*big.Int" found (nonamedreturns)
func (es eip2930Signer) SignatureValues(tx *EthereumTransaction, sig []byte) (r, s, v *big.Int, err error) {
^
pkg/proto/eth_signer.go:363:1: named return "r" with type "*big.Int" found (nonamedreturns)
func (es eip155Signer) SignatureValues(tx *EthereumTransaction, sig []byte) (r, s, v *big.Int, err error) {
^
pkg/proto/eth_signer.go:410:1: named return "r" with type "*big.Int" found (nonamedreturns)
func (hs HomesteadSigner) SignatureValues(tx *EthereumTransaction, sig []byte) (r, s, v *big.Int, err error) {
^
pkg/proto/eth_signer.go:459:1: named return "r" with type "*big.Int" found (nonamedreturns)
func (fs FrontierSigner) SignatureValues(tx *EthereumTransaction, sig []byte) (r, s, v *big.Int, err error) {
^
pkg/proto/eth_transaction.go:144:1: named return "argument" with type "Argument" found (nonamedreturns)
func ethABIDataTypeToArgument(dataType ethabi.DataType) (argument Argument, _ error) {
^
pkg/proto/eth_transaction.go:586:1: named return "v" with type "*big.Int" found (nonamedreturns)
func (tx *EthereumTransaction) RawSignatureValues() (v, r, s *big.Int) {
^
pkg/proto/eth_utils.go:49:1: named return "v" with type "big.Int" found (nonamedreturns)
func unmarshalSignatureValuesFastRLP(vValue, rValue, sValue *fastrlp.Value) (v, r, s big.Int, err error) {
^
pkg/proto/microblock.go:282:1: named return "n" with type "int64" found (nonamedreturns)
func (a *MicroBlockInvMessage) ReadFrom(_ io.Reader) (n int64, err error) {
^
pkg/proto/microblock.go:286:1: named return "n" with type "int64" found (nonamedreturns)
func (a *MicroBlockInvMessage) WriteTo(w io.Writer) (n int64, err error) {
^
pkg/proto/microblock.go:325:1: named return "n" with type "int64" found (nonamedreturns)
func (a *MicroBlockRequestMessage) ReadFrom(_ io.Reader) (n int64, err error) {
^
pkg/proto/proto.go:2018:1: named return "n" with type "int64" found (nonamedreturns)
func (BulkMessage) ReadFrom(_ io.Reader) (n int64, err error) {
^
pkg/proto/proto.go:2022:1: named return "n" with type "int64" found (nonamedreturns)
func (BulkMessage) WriteTo(_ io.Writer) (n int64, err error) {
^
pkg/proto/proto.go:2030:1: named return "data" with type "[]byte" found (nonamedreturns)
func (a BulkMessage) MarshalBinary() (data []byte, err error) {
^
pkg/proto/transactions.go:416:1: named return "err" with type "error" found (nonamedreturns)
func UnmarshalTransactionFromJSON(data []byte, scheme Scheme, tx Transaction) (err error) {
^
pkg/proto/transactions_with_proofs.go:1756:1: named return "err" with type "error" found (nonamedreturns)
func (tx *ExchangeWithProofs) UnmarshalJSON(data []byte) (err error) {
^
pkg/proto/transactions_with_proofs.go:1765:30: named return "order" with type "Order" found (nonamedreturns)
	guessOrderVersionAndType := func(orderInfo orderRecognizer) (order Order, err error) {
	                            ^
pkg/proto/types.go:690:1: named return "data" with type "[]byte" found (nonamedreturns)
func MarshalOrderBody(scheme Scheme, o Order) (data []byte, err error) {
^
pkg/proto/types.go:1910:1: named return "err" with type "error" found (nonamedreturns)
func (o *EthereumOrderV4) EthereumSign(scheme Scheme, sk *EthereumPrivateKey) (err error) {
^
pkg/proto/proto_test.go:25:6: type comparable has same name as predeclared identifier (predeclared)
type comparable interface {
     ^
pkg/proto/transactions_test.go:2462:3: ST1003: struct field buyTs should be buyTS (stylecheck)
		buyTs          uint64
		^
pkg/proto/transactions_test.go:2470:3: ST1003: struct field sellTs should be sellTS (stylecheck)
		sellTs         uint64
		^
pkg/proto/transactions_test.go:2818:3: ST1003: struct field buyTs should be buyTS (stylecheck)
		buyTs          uint64
		^
pkg/proto/transactions_test.go:2826:3: ST1003: struct field sellTs should be sellTS (stylecheck)
		sellTs         uint64
		^
pkg/proto/addresses_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/block_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/common_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/eth_access_list_tx_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/eth_legacy_tx_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/eth_transaction_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/keypair_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/microblock_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/proto_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/scripting_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/transactions_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/types_test.go:1:9: package should be `proto_test` instead of `proto` (testpackage)
package proto
        ^
pkg/proto/eth_typed_data.go:259:3: assigned to lengthStr, but reassigned without using the value (wastedassign)
		lengthStr := ""
		^
pkg/proto/types.go:3413:2: assigned to buf, but reassigned without using the value (wastedassign)
	buf := byte(0)
	^
cmd/blockcmp/blockcmp.go:304: 304-326 lines are duplicate of `cmd/blockcmp/blockcmp.go:328-350` (dupl)
func addDataDiff(sb *strings.Builder, a, b []internal.DataEntry) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tData Entries:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:328: 328-350 lines are duplicate of `cmd/blockcmp/blockcmp.go:352-374` (dupl)
func addTransfersDiff(sb *strings.Builder, a, b []internal.Transfer) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tTransfers:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:352: 352-374 lines are duplicate of `cmd/blockcmp/blockcmp.go:376-398` (dupl)
func addIssuesDiff(sb *strings.Builder, a, b []internal.Issue) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tIssues:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:376: 376-398 lines are duplicate of `cmd/blockcmp/blockcmp.go:400-422` (dupl)
func addReissuesDiff(sb *strings.Builder, a, b []internal.Reissue) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tReissues:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:400: 400-422 lines are duplicate of `cmd/blockcmp/blockcmp.go:424-446` (dupl)
func addBurnsDiff(sb *strings.Builder, a, b []internal.Burn) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tBurns:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:424: 424-446 lines are duplicate of `cmd/blockcmp/blockcmp.go:448-470` (dupl)
func addSponsorFeesDiff(sb *strings.Builder, a, b []internal.Sponsorship) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tSponsorships:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:448: 448-470 lines are duplicate of `cmd/blockcmp/blockcmp.go:472-494` (dupl)
func addLeasesDiff(sb *strings.Builder, a, b []internal.Lease) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tLeases:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:472: 472-494 lines are duplicate of `cmd/blockcmp/blockcmp.go:304-326` (dupl)
func addLeaseCancelsDiff(sb *strings.Builder, a, b []internal.LeaseCancel) {
	la := len(a)
	lb := len(b)
	min, max := minmax(la, lb)
	lsb := new(strings.Builder)
	for i := 0; i < min; i++ {
		if !a[i].Equal(b[i]) {
			lsb.WriteString(fmt.Sprintf("\t-%s\n", a[i].String()))
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	for i := min; i < max; i++ {
		if la > lb {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", a[i].String()))
		} else {
			lsb.WriteString(fmt.Sprintf("\t+%s\n", b[i].String()))
		}
	}
	if lsb.Len() > 0 {
		sb.WriteString("\tLease Cancels:\n")
		sb.WriteString(lsb.String())
	}
}
cmd/blockcmp/blockcmp.go:145:2: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Println(rep.String())
	^
cmd/blockcmp/blockcmp.go:270:1: cognitive complexity 33 of func `resultDiff` is high (> 20) (gocognit)
func resultDiff(a, b *waves.InvokeScriptResult, scheme byte) string {
^
cmd/blockcmp/blockcmp.go:12:2: import of package `github.com/golang/protobuf/ptypes/empty` is blocked because the module is in the blocked modules list. `google.golang.org/protobuf` is a recommended module. see https://developers.google.com/protocol-buffers/docs/reference/go/faq#modules. (gomodguard)
	"github.com/golang/protobuf/ptypes/empty"
	^
cmd/blockcmp/blockcmp.go:149:46: parseNodesList - result 1 (error) is always nil (unparam)
func parseNodesList(nodes string) ([]string, error) {
                                             ^
itests/issue_smart_asset_test.go:42: unnecessary trailing newline (whitespace)

}
itests/issue_tx_test.go:38: unnecessary trailing newline (whitespace)

}
itests/transfer_tx_api_test.go:201: unnecessary trailing newline (whitespace)

			})
itests/transfer_with_sponsorship_api_test.go:96: unnecessary trailing newline (whitespace)

			})
itests/transfer_with_sponsorship_test.go:401: unnecessary trailing newline (whitespace)

			})
itests/transfer_with_sponsorship_test.go:484: unnecessary trailing newline (whitespace)

			})
itests/alias_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/alias_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/burn_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/burn_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/init_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/issue_smart_asset_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/issue_smart_asset_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/issue_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/issue_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/reissue_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/reissuie_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/set_asset_script_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/set_asset_script_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/sponsorship_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/sponsorship_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/transfer_tx_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/transfer_tx_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/transfer_with_sponsorship_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/transfer_with_sponsorship_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/update_asset_info_api_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
itests/update_asset_info_test.go:1:9: package should be `itests_test` instead of `itests` (testpackage)
package itests
        ^
pkg/client/transactions_info.go:44:1: cognitive complexity 26 of func `guessTransactionInfoType` is high (> 20) (gocognit)
func guessTransactionInfoType(t *proto.TransactionTypeVersion) (TransactionInfo, error) {
^
pkg/client/assets.go:5: File is not `goimports`-ed (goimports)
	"fmt"
pkg/client/utils_test.go:4: File is not `goimports`-ed (goimports)
	"context"
pkg/client/wallet_test.go:4: File is not `goimports`-ed (goimports)
	"context"
pkg/client/client.go:151:2: `if v != nil` has complex nested blocks (complexity: 6) (nestif)
	if v != nil {
	^
pkg/client/addresses.go:221: unnecessary leading newline (whitespace)
	ctx context.Context, address proto.WavesAddress, confirmations uint64) (*BalanceAfterConfirmations, *Response, error) {

pkg/client/transactions_test.go:149: unnecessary trailing newline (whitespace)

}
pkg/client/client.go:127:32: response body must be closed (bodyclose)
	resp, err := options.Client.Do(req)
	                              ^
pkg/client/transactions_info.go:46:2: missing cases in switch of type proto.TransactionType: proto.InvokeExpressionTransaction (exhaustive)
	switch t.Type {
	^
pkg/client/transactions.go:108:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/utils.go:129:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/blocks.go:287:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/wallet.go:28:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/debug.go:122:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/transactions.go:87:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/transactions.go:144:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/addresses.go:281:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", u.String(), nil)
	                           ^
pkg/client/transactions.go:34:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/debug.go:221:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url.String(), bytes.NewBuffer(bts))
	                           ^
pkg/client/peers.go:179:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url.String(), bytes.NewReader(bts))
	                           ^
pkg/client/transactions.go:178:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url.String(), bytes.NewReader(bts))
	                           ^
pkg/client/assets.go:139:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/utils.go:108:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/peers.go:205:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url.String(), nil)
	                           ^
pkg/client/utils.go:28:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/blocks.go:263:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("GET", url.String(), nil)
	                           ^
pkg/client/addresses.go:335:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", u.String(), b)
	                           ^
pkg/client/utils.go:166:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url.String(), strings.NewReader(code))
	                           ^
pkg/client/utils.go:196:29: should rewrite http.NewRequestWithContext or add (*Request).WithContext (noctx)
	req, err := http.NewRequest("POST", url.String(), strings.NewReader(base64code))
	                           ^
pkg/client/addresses_test.go:1:9: package should be `client_test` instead of `client` (testpackage)
package client
        ^
pkg/client/alias_test.go:1:9: package should be `client_test` instead of `client` (testpackage)
package client
        ^
pkg/client/assets_test.go:1:9: package should be `client_test` instead of `client` (testpackage)
package client
        ^
pkg/client/blocks_test.go:1:9: package should be `client_test` instead of `client` (testpackage)
package client
        ^
pkg/client/client_test.go:1:9: package should be `client_test` instead of `client` (testpackage)
package client
        ^
pkg/client/debug_test.go:1:9: package should be `client_test` instead of `client` (testpackage)
package client
        ^
pkg/client/addresses.go:39:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:68:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:100:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:120:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:145:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:171:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:195:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:228:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/addresses.go:301:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", u.String(), nil)
	                            ^
pkg/client/alias.go:27:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/alias.go:49:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/assets.go:44:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/assets.go:71:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/assets.go:105:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/assets.go:163:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:34:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:53:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:103:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:123:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:143:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:197:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:216:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/blocks.go:239:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/debug.go:62:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/debug.go:95:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/debug.go:144:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/debug.go:162:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/debug.go:193:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/leasing.go:29:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/node_info.go:27:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/peers.go:41:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/peers.go:80:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/peers.go:112:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/peers.go:143:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/transactions.go:66:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url.String(), nil)
	                            ^
pkg/client/utils.go:56:30: "POST" can be replaced by http.MethodPost (usestdlibvars)
	req, err := http.NewRequest("POST", url.String(), strings.NewReader(message))
	                            ^
pkg/client/utils.go:82:30: "POST" can be replaced by http.MethodPost (usestdlibvars)
	req, err := http.NewRequest("POST", url.String(), strings.NewReader(message))
	                            ^
pkg/client/client_test.go:52:28: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, _ := http.NewRequest("GET", "https://google.com", nil)
	                          ^
pkg/client/client_test.go:62:30: "GET" can be replaced by http.MethodGet (usestdlibvars)
	req, err := http.NewRequest("GET", url, nil)
	                            ^
cmd/wmd/internal/data/updates.go:135: 135-166 lines are duplicate of `cmd/wmd/internal/data/updates.go:168-199` (dupl)
func FromTransferWithSig(scheme byte, tx *proto.TransferWithSig, miner crypto.PublicKey) ([]AccountChange, error) {
	r := make([]AccountChange, 0, 4)
	if tx.AmountAsset.Present {
		ch1 := AccountChange{Asset: tx.AmountAsset.ID, Out: tx.Amount}
		err := ch1.Account.SetFromPublicKey(scheme, tx.SenderPK)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithSig to Change")
		}
		ch2 := AccountChange{Asset: tx.AmountAsset.ID, In: tx.Amount}
		err = ch2.Account.SetFromRecipient(tx.Recipient)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithSig to Change")
		}
		r = append(r, ch1)
		r = append(r, ch2)
	}
	if tx.FeeAsset.Present {
		ch1 := AccountChange{Asset: tx.FeeAsset.ID, Out: tx.Fee}
		err := ch1.Account.SetFromPublicKey(scheme, tx.SenderPK)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithSig to Change")
		}
		ch2 := AccountChange{Asset: tx.FeeAsset.ID, In: tx.Fee, MinersReward: true}
		err = ch2.Account.SetFromPublicKey(scheme, miner)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithSig to Change")
		}
		r = append(r, ch1)
		r = append(r, ch2)
	}
	return r, nil
}
cmd/wmd/internal/data/updates.go:168: 168-199 lines are duplicate of `cmd/wmd/internal/data/updates.go:135-166` (dupl)
func FromTransferWithProofs(scheme byte, tx *proto.TransferWithProofs, miner crypto.PublicKey) ([]AccountChange, error) {
	r := make([]AccountChange, 0, 4)
	if tx.AmountAsset.Present {
		ch1 := AccountChange{Asset: tx.AmountAsset.ID, Out: tx.Amount}
		err := ch1.Account.SetFromPublicKey(scheme, tx.SenderPK)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithProofs to Change")
		}
		ch2 := AccountChange{Asset: tx.AmountAsset.ID, In: tx.Amount}
		err = ch2.Account.SetFromRecipient(tx.Recipient)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithProofs to Change")
		}
		r = append(r, ch1)
		r = append(r, ch2)
	}
	if tx.FeeAsset.Present {
		ch1 := AccountChange{Asset: tx.FeeAsset.ID, Out: tx.Fee}
		err := ch1.Account.SetFromPublicKey(scheme, tx.SenderPK)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithSig to Change")
		}
		ch2 := AccountChange{Asset: tx.FeeAsset.ID, In: tx.Fee, MinersReward: true}
		err = ch2.Account.SetFromPublicKey(scheme, miner)
		if err != nil {
			return nil, errors.Wrap(err, "failed to convert TransferWithSig to Change")
		}
		r = append(r, ch1)
		r = append(r, ch2)
	}
	return r, nil
}
cmd/wmd/internal/data/candle.go:5: File is not `goimports`-ed (goimports)
	"github.com/pkg/errors"
cmd/wmd/internal/data/candle_test.go:4: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/assert"
cmd/wmd/internal/data/symbols.go:164:5: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err != io.EOF {
	   ^
cmd/wmd/internal/data/trade.go:71:2: assigned to ap, but reassigned without using the value (wastedassign)
	ap, ba, buyTS, err := extractOrderParameters(scheme, bo)
	^
pkg/node/peer_manager/storage/cbor.go:68:1: cognitive complexity 28 of func `newCBORStorageInDir` is high (> 20) (gocognit)
func newCBORStorageInDir(storageDir string, now time.Time, currVersion int) (*CBORStorage, error) {
^
pkg/node/peer_manager/storage/cbor.go:99:7: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	case err == io.EOF:
	     ^
pkg/node/peer_manager/storage/cbor.go:120:76: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err := unmarshalCborFromFile(knownFile, &storage.known); err != nil && err != io.EOF {
	                                                                          ^
pkg/node/peer_manager/storage/cbor.go:123:84: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err := unmarshalCborFromFile(suspendedFile, &storage.suspended); err != nil && err != io.EOF {
	                                                                                  ^
pkg/node/peer_manager/storage/cbor.go:126:84: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err := unmarshalCborFromFile(blackListFile, &storage.blackList); err != nil && err != io.EOF {
	                                                                                  ^
pkg/node/peer_manager/storage/cbor.go:550:7: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	case err == io.EOF:
	     ^
pkg/node/peer_manager/storage/cbor_test.go:117:2: ST1003: var setPeersTs should be setPeersTS (stylecheck)
	setPeersTs := func(m knownPeers, list []KnownPeer, ts int64) {
	^
pkg/node/peer_manager/storage/cbor_test.go:134:21: ST1003: range var expectedTs should be expectedTS (stylecheck)
		for expectedPeer, expectedTs := range known {
		                  ^
pkg/node/peer_manager/storage/cbor_test.go:164:3: ST1003: var newTs should be newTS (stylecheck)
		newTs := time.Now()
		^
pkg/settings/node_settings.go:4: File is not `goimports`-ed (goimports)
	"github.com/pkg/errors"
pkg/settings/node_settings_test.go:4: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/require"
pkg/settings/blockchain_settings.go:166:2: missing cases in switch of type settings.BlockchainType: settings.Custom (exhaustive)
	switch blockchain {
	^
pkg/api/metamask/service.go:229: unnecessary leading newline (whitespace)
func ethCall(state state.State, scheme proto.Scheme, params ethCallParams) ([]byte, error) {

pkg/api/metamask/service.go:130:3: return both the `nil` error and invalid value: use a sentinel error instead (nilnil)
		return nil, nil // according to the scala node implementation
		^
pkg/api/metamask/service.go:440:3: return both the `nil` error and invalid value: use a sentinel error instead (nilnil)
		return nil, nil
		^
pkg/api/metamask/service.go:521:3: return both the `nil` error and invalid value: use a sentinel error instead (nilnil)
		return nil, nil
		^
pkg/ride/vm_test.go:387:8: Error return value is not checked (errcheck)
		r := res.(ScriptResult)
		     ^
pkg/ride/vm_test.go:417:8: Error return value is not checked (errcheck)
		r := res.(ScriptResult)
		     ^
pkg/ride/tree_estimation_test.go:205:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println(test.comment, ":", time.Since(start))
		^
pkg/ride/converters.go:14: Function 'transactionToObject' has too many statements (57 > 50) (funlen)
func transactionToObject(ver ast.LibraryVersion, scheme proto.Scheme, consensusImprovementsActivated bool, tx proto.Transaction) (rideType, error) {
pkg/ride/converters.go:909: Function 'ethereumTransactionToObject' is too long (123 > 100) (funlen)
func ethereumTransactionToObject(ver ast.LibraryVersion, scheme proto.Scheme, tx *proto.EthereumTransaction) (rideType, error) {
pkg/ride/converters.go:1377: Function 'convertToAction' has too many statements (153 > 50) (funlen)
func convertToAction(env environment, obj rideType) (proto.ScriptAction, error) {
pkg/ride/environment.go:362: Function 'validateAsset' has too many statements (56 > 50) (funlen)
func (ws *WrappedState) validateAsset(action proto.ScriptAction, asset proto.OptionalAsset, env environment) (bool, error) {
pkg/ride/environment.go:711: Function 'ApplyToState' has too many statements (153 > 50) (funlen)
func (ws *WrappedState) ApplyToState(
pkg/ride/functions_bigint.go:294: Function 'fractionBigIntLikeInScala' has too many statements (60 > 50) (funlen)
func fractionBigIntLikeInScala(v, n, d *big.Int, roundingMode decimal.RoundingMode) (*big.Int, error) {
pkg/ride/functions_proto.go:115: Function 'performInvoke' has too many statements (126 > 50) (funlen)
func performInvoke(invocation invocation, env environment, args ...rideType) (rideType, error) {
pkg/ride/tree_estimation.go:16: Function 'EstimateTree' has too many statements (53 > 50) (funlen)
func EstimateTree(tree *ast.Tree, v int) (TreeEstimation, error) {
pkg/ride/tree_estimatorV1.go:171: Function 'walk' has too many statements (74 > 50) (funlen)
func (e *treeEstimatorV1) walk(node ast.Node) (int, error) {
pkg/ride/tree_estimatorV2.go:175: Function 'walk' has too many statements (87 > 50) (funlen)
func (e *treeEstimatorV2) walk(node ast.Node) (int, error) {
pkg/ride/tree_estimatorV3.go:241: Function 'walk' has too many statements (102 > 50) (funlen)
func (e *treeEstimatorV3) walk(node ast.Node) (int, bool, error) {
pkg/ride/tree_estimatorV4.go:110: Function 'walk' has too many statements (97 > 50) (funlen)
func (e *treeEstimatorV4) walk(node ast.Node) (int, bool, error) {
pkg/ride/tree_evaluator.go:318: Function 'walk' has too many statements (92 > 50) (funlen)
func (e *treeEvaluator) walk(node ast.Node) (rideType, error) {
pkg/ride/vm.go:41: Function 'run' has too many statements (108 > 50) (funlen)
func (m *vm) run() (Result, error) {
pkg/ride/test_helpers_test.go:119:1: cognitive complexity 66 of func `newTestEnv` is high (> 20) (gocognit)
func newTestEnv(t *testing.T) *testEnv {
^
pkg/ride/functions_list.go:466:1: cognitive complexity 33 of func `findFirstEntry` is high (> 20) (gocognit)
func findFirstEntry(list rideList, key rideString, expectedValueType string) rideType {
^
pkg/ride/converters.go:1299:1: cognitive complexity 29 of func `objectToActions` is high (> 20) (gocognit)
func objectToActions(env environment, obj rideType) ([]proto.ScriptAction, error) {
^
pkg/ride/vm_test.go:120:1: cognitive complexity 25 of func `TestFunctions` is high (> 20) (gocognit)
func TestFunctions(t *testing.T) {
^
pkg/ride/environment.go:1038:1: cognitive complexity 24 of func `NewEnvironmentWithWrappedState` is high (> 20) (gocognit)
func NewEnvironmentWithWrappedState(
^
pkg/ride/compiler.go:81:1: cognitive complexity 21 of func `(*compiler).compileDAppScript` is high (> 20) (gocognit)
func (c *compiler) compileDAppScript(tree *ast.Tree) (*DAppScript, error) {
^
pkg/ride/tree_estimatorV3.go:168:1: cognitive complexity 21 of func `(*treeEstimatorV3).estimate` is high (> 20) (gocognit)
func (e *treeEstimatorV3) estimate() (int, int, map[string]int, error) {
^
pkg/ride/tree_estimatorV4.go:35:1: cognitive complexity 21 of func `(*treeEstimatorV4).estimate` is high (> 20) (gocognit)
func (e *treeEstimatorV4) estimate() (int, int, map[string]int, error) {
^
pkg/ride/environment.go:488:3: `if payment.Asset.Present` has complex nested blocks (complexity: 7) (nestif)
		if payment.Asset.Present {
		^
pkg/ride/environment.go:531:2: `if res.Asset.Present` has complex nested blocks (complexity: 5) (nestif)
	if res.Asset.Present {
	^
pkg/ride/environment.go:1055:3: `if payment.Asset.Present` has complex nested blocks (complexity: 5) (nestif)
		if payment.Asset.Present {
		^
pkg/ride/tree_evaluator.go:458:2: `if tree.IsDApp()` has complex nested blocks (complexity: 5) (nestif)
	if tree.IsDApp() {
	^
pkg/ride/converters.go:152:74: genesisToObject - result 1 (error) is always nil (unparam)
func genesisToObject(_ byte, tx *proto.Genesis) (rideGenesisTransaction, error) {
                                                                         ^
pkg/ride/environment.go:394: unnecessary leading newline (whitespace)
	switch res := action.(type) {

pkg/ride/environment.go:432: unnecessary trailing newline (whitespace)

	}
pkg/ride/functions_int_test.go:418: unnecessary trailing newline (whitespace)

	}
pkg/ride/functions_strings_test.go:559: unnecessary trailing newline (whitespace)

	}
pkg/ride/functions_strings_test.go:585: unnecessary trailing newline (whitespace)

	}
pkg/ride/tree_evaluation_test.go:5502: unnecessary leading newline (whitespace)
func TestThrowComplexity(t *testing.T) {

pkg/ride/errors.go:48:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if ee, ok := err.(evaluationError); ok {
	             ^
pkg/ride/errors.go:55:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if ee, ok := err.(evaluationError); ok {
	             ^
pkg/ride/errors.go:62:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if ee, ok := err.(evaluationError); ok {
	             ^
pkg/ride/errors.go:69:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if ee, ok := err.(evaluationError); ok {
	             ^
pkg/ride/errors.go:77:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if ee, ok := err.(evaluationError); ok {
	             ^
pkg/ride/constraints.go:22:2: missing cases in switch of type ast.LibraryVersion: ast.LibV1, ast.LibV2 (exhaustive)
	switch version {
	^
pkg/ride/converters.go:113:2: missing cases in switch of type ast.LibraryVersion: ast.LibV7 (exhaustive)
	switch v {
	^
pkg/ride/converters.go:842:2: missing cases in switch of type ast.LibraryVersion: ast.LibV4, ast.LibV5, ast.LibV6, ast.LibV7 (exhaustive)
	switch ver {
	^
pkg/ride/converters.go:988:3: missing cases in switch of type ast.LibraryVersion: ast.LibV4, ast.LibV5, ast.LibV6, ast.LibV7 (exhaustive)
		switch ver {
		^
pkg/ride/converters.go:1140:3: missing cases in switch of type ast.LibraryVersion: ast.LibV4, ast.LibV5, ast.LibV6, ast.LibV7 (exhaustive)
		switch rideVersion {
		^
pkg/ride/converters.go:1165:2: missing cases in switch of type ast.LibraryVersion: ast.LibV5, ast.LibV6, ast.LibV7 (exhaustive)
	switch rideVersion {
	^
pkg/ride/converters.go:1209:2: missing cases in switch of type ast.LibraryVersion: ast.LibV5, ast.LibV6, ast.LibV7 (exhaustive)
	switch rideVersion {
	^
pkg/ride/environment.go:442:2: missing cases in switch of type ast.LibraryVersion: ast.LibV4, ast.LibV5, ast.LibV6, ast.LibV7 (exhaustive)
	switch tree.LibVersion {
	^
pkg/ride/converters.go:1539:4: error is not nil (line 1534) but it returns nil (nilerr)
			return &proto.TransferScriptAction{
			^
pkg/ride/functions_bigint.go:535:3: error is not nil (line 533) but it returns nil (nilerr)
		return newUnit(env), nil
		^
pkg/ride/functions_proto.go:408:3: error is not nil (line 406) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:480:4: error is not nil (line 478) but it returns nil (nilerr)
			return rideInt(0), nil // according to the scala node implementation
			^
pkg/ride/functions_proto.go:506:3: error is not nil (line 504) but it returns nil (nilerr)
		return rideInt(0), nil // according to the scala node implementation
		^
pkg/ride/functions_proto.go:518:3: error is not nil (line 516) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:522:3: error is not nil (line 520) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:530:3: error is not nil (line 528) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:539:3: error is not nil (line 537) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:547:3: error is not nil (line 545) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:551:3: error is not nil (line 549) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:559:3: error is not nil (line 557) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:568:3: error is not nil (line 566) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:576:3: error is not nil (line 574) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:580:3: error is not nil (line 578) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:588:3: error is not nil (line 586) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:597:3: error is not nil (line 595) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:605:3: error is not nil (line 603) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:609:3: error is not nil (line 607) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:617:3: error is not nil (line 615) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:626:3: error is not nil (line 624) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:676:3: error is not nil (line 674) but it returns nil (nilerr)
		return rideBoolean(false), nil
		^
pkg/ride/functions_proto.go:680:3: error is not nil (line 678) but it returns nil (nilerr)
		return rideBoolean(false), nil
		^
pkg/ride/functions_proto.go:739:3: error is not nil (line 737) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:809:3: error is not nil (line 807) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:813:3: error is not nil (line 811) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:825:3: error is not nil (line 823) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:829:3: error is not nil (line 827) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/functions_proto.go:962:3: error is not nil (line 960) but it returns nil (nilerr)
		return rideBoolean(false), nil
		^
pkg/ride/functions_proto.go:1215:3: error is not nil (line 1213) but it returns nil (nilerr)
		return rideAddressLike(b), nil
		^
pkg/ride/functions_strings.go:257:3: error is not nil (line 255) but it returns nil (nilerr)
		return rideUnit{}, nil
		^
pkg/ride/diff_state.go:220:45: param new has same name as predeclared identifier (predeclared)
func (ds *diffState) replaceChangedAccounts(new changedAccounts) changedAccounts {
                                            ^
cmd/chaincmp/chaincmp.go:76:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("chaincmp %s\n", version)
		^
cmd/chaincmp/chaincmp.go:55: Function 'run' has too many statements (97 > 50) (funlen)
func run() error {
cmd/chaincmp/sigterm.go:11:1: don't use `init` function (gochecknoinits)
func init() {
^
cmd/chaincmp/chaincmp.go:39:3: switch on an error will fail on wrapped errors. Use errors.Is to check for specific errors (errorlint)
		switch err {
		^
cmd/importer/importer.go:42: Function 'main' has too many statements (69 > 50) (funlen)
func main() {
cmd/importer/importer.go:1:1: the average complexity for the package main is 23.000000, max is 10.000000 (cyclop)
package main
^
cmd/wmd/wmd.go:32: Function 'run' has too many statements (133 > 50) (funlen)
func run() error {
cmd/wmd/sigterm.go:11:1: don't use `init` function (gochecknoinits)
func init() {
^
cmd/wmd/shutdown.go:4: File is not `goimports`-ed (goimports)
	"go.uber.org/zap"
cmd/wmd/wmd.go:56:20: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
		if err != nil && err == os.ErrInvalid {
		                 ^
pkg/errs/tx_validation_errors.go:5:6: the type name `TooBigArray` should conform to the `XxxError` format (errname)
type TooBigArray struct {
     ^
pkg/errs/tx_validation_errors.go:26:6: the type name `NonPositiveAmount` should conform to the `XxxError` format (errname)
type NonPositiveAmount struct {
     ^
pkg/errs/tx_validation_errors.go:47:6: the type name `InvalidName` should conform to the `XxxError` format (errname)
type InvalidName struct {
     ^
pkg/errs/tx_validation_errors.go:89:6: the type name `ToSelf` should conform to the `XxxError` format (errname)
type ToSelf struct {
     ^
pkg/errs/tx_validation_errors.go:133:6: the type name `AssetIsNotReissuable` should conform to the `XxxError` format (errname)
type AssetIsNotReissuable struct {
     ^
pkg/errs/tx_validation_errors.go:155:6: the type name `AliasTaken` should conform to the `XxxError` format (errname)
type AliasTaken struct {
     ^
pkg/errs/tx_validation_errors.go:177:6: the type name `Mistiming` should conform to the `XxxError` format (errname)
type Mistiming struct {
     ^
pkg/errs/tx_validation_errors.go:199:6: the type name `EmptyDataKey` should conform to the `XxxError` format (errname)
type EmptyDataKey struct {
     ^
pkg/errs/tx_validation_errors.go:221:6: the type name `DuplicatedDataKeys` should conform to the `XxxError` format (errname)
type DuplicatedDataKeys struct {
     ^
pkg/errs/tx_validation_errors.go:242:6: the type name `UnknownAsset` should conform to the `XxxError` format (errname)
type UnknownAsset struct {
     ^
pkg/errs/tx_validation_errors.go:263:6: the type name `AssetIssuedByOtherAddress` should conform to the `XxxError` format (errname)
type AssetIssuedByOtherAddress struct {
     ^
pkg/errs/tx_validation_errors.go:286:6: the type name `FeeValidation` should conform to the `XxxError` format (errname)
type FeeValidation struct {
     ^
pkg/errs/tx_validation_errors.go:309:6: the type name `AssetUpdateInterval` should conform to the `XxxError` format (errname)
type AssetUpdateInterval struct {
     ^
pkg/errs/tx_validation_errors.go:332:6: the type name `TransactionNotAllowedByScript` should conform to the `XxxError` format (errname)
type TransactionNotAllowedByScript struct {
     ^
pkg/errs/extend.go:14:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if ex, ok := err.(IExtend); ok {
	             ^
pkg/errs/tx_validation_errors.go:22:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(TooBigArray)
	         ^
pkg/errs/tx_validation_errors.go:43:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(NonPositiveAmount)
	         ^
pkg/errs/tx_validation_errors.go:64:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(InvalidName)
	         ^
pkg/errs/tx_validation_errors.go:85:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(AccountBalanceError)
	         ^
pkg/errs/tx_validation_errors.go:106:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(ToSelf)
	         ^
pkg/errs/tx_validation_errors.go:129:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(TxValidationError)
	         ^
pkg/errs/tx_validation_errors.go:151:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(AssetIsNotReissuable)
	         ^
pkg/errs/tx_validation_errors.go:173:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(AliasTaken)
	         ^
pkg/errs/tx_validation_errors.go:195:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(Mistiming)
	         ^
pkg/errs/tx_validation_errors.go:217:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(EmptyDataKey)
	         ^
pkg/errs/tx_validation_errors.go:238:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(DuplicatedDataKeys)
	         ^
pkg/errs/tx_validation_errors.go:259:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(UnknownAsset)
	         ^
pkg/errs/tx_validation_errors.go:282:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(AssetIssuedByOtherAddress)
	         ^
pkg/errs/tx_validation_errors.go:305:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(FeeValidation)
	         ^
pkg/errs/tx_validation_errors.go:328:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(AssetUpdateInterval)
	         ^
pkg/errs/tx_validation_errors.go:361:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := target.(TransactionNotAllowedByScript)
	         ^
pkg/errs/validation_error.go:14:11: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	_, ok := err.(ValidationError)
	         ^
pkg/libs/serializer/serializer_test.go:6: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/require"
cmd/forkdetector/forkdetector.go:56:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println("Invalid parameters:", err)
		^
cmd/forkdetector/forkdetector.go:53: Function 'run' has too many statements (72 > 50) (funlen)
func run() error {
cmd/forkdetector/sigterm.go:11:1: don't use `init` function (gochecknoinits)
func init() {
^
itests/config/base_target_calculating_test.go:3: File is not `goimports`-ed (goimports)
import (
itests/config/genesis_settings.go:52:6: `GenesisSettings` should be annotated with the `json` tag as it is passed to `json.Decoder.Decode` at itests/config/genesis_settings.go:84:11 (musttag)
type GenesisSettings struct {
     ^
pkg/proto/ethabi/unpack.go:371: Function 'toDataType' has too many statements (67 > 50) (funlen)
func toDataType(index int, t Type, output []byte) (_ DataType, slotsReadTotal int, _ error) {
pkg/proto/ethabi/unpack.go:138: unnecessary trailing newline (whitespace)

}
pkg/proto/ethabi/data_types_test.go:34: unnecessary trailing newline (whitespace)

}
pkg/proto/ethabi/data_types.go:30:1: named return "slot" with type "[abiSlotSize]byte" found (nonamedreturns)
func (i Int) encodeToABISlot() (slot [abiSlotSize]byte) {
^
pkg/proto/ethabi/function_signature.go:119:1: named return "text" with type "[]byte" found (nonamedreturns)
func (itb intTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:134:1: named return "text" with type "[]byte" found (nonamedreturns)
func (fbtb fixedBytesTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:143:1: named return "text" with type "[]byte" found (nonamedreturns)
func (btb bytesTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:149:1: named return "text" with type "[]byte" found (nonamedreturns)
func (btb booleanTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:155:1: named return "text" with type "[]byte" found (nonamedreturns)
func (stb stringTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:163:1: named return "text" with type "[]byte" found (nonamedreturns)
func (stb sliceTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:173:1: named return "text" with type "[]byte" found (nonamedreturns)
func (ttb tupleTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:187:1: named return "text" with type "[]byte" found (nonamedreturns)
func (ptb paymentTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/function_signature.go:211:1: named return "text" with type "[]byte" found (nonamedreturns)
func (ftb functionTextBuilder) MarshalText() (text []byte, err error) {
^
pkg/proto/ethabi/type.go:110:1: named return "abiT" with type "Type" found (nonamedreturns)
func AbiTypeFromRideTypeMeta(metaT meta.Type) (abiT Type, err error) {
^
pkg/proto/ethabi/unpack.go:91:1: named return "slotsReadTotal" with type "int" found (nonamedreturns)
func forEachUnpackRideList(t Type, output []byte, start, size int) (_ List, slotsReadTotal int, err error) {
^
pkg/proto/ethabi/unpack.go:123:1: named return "slotsRead" with type "int" found (nonamedreturns)
func extractIndexFromFirstElemOfTuple(index int, t Type, output []byte) (_ int64, slotsRead int, _ error) {
^
pkg/proto/ethabi/unpack.go:141:1: named return "slotsReadTotal" with type "int" found (nonamedreturns)
func forUnionTupleUnpackToDataType(t Type, output []byte) (_ DataType, slotsReadTotal int, _ error) {
^
cmd/node/node.go:140: Function 'main' has too many statements (165 > 50) (funlen)
func main() {
cmd/node/node.go:9:2: ST1019: package "net/http" is being imported more than once (stylecheck)
	"net/http"
	^
cmd/node/node.go:10:2: ST1019(related information): other import of "net/http" (stylecheck)
	_ "net/http"
	^
pkg/ride/compiler/ast_parser.go:132:13: Error return value is not checked (errcheck)
		txType := p.stdTypes["Transaction"].(s.UnionType)
		          ^
pkg/ride/compiler/ast_parser.go:282:13: Error return value is not checked (errcheck)
				cond := decls[i].(*ast.ConditionalNode)
				        ^
pkg/ride/compiler/ast_parser.go:457:10: Error return value is not checked (errcheck)
	decl := exprs[0].(*ast.AssignmentNode)
	        ^
pkg/ride/compiler/ast_parser.go:604:12: Error return value is not checked (errcheck)
		tuple := T.(s.TupleType)
		         ^
pkg/ride/compiler/ast_parser.go:1519:13: Error return value is not checked (errcheck)
				cond := decls[i].(*ast.ConditionalNode)
				        ^
pkg/ride/compiler/ast_parser.go:1831:7: Error return value is not checked (errcheck)
	f := expr.(*ast.FunctionDeclarationNode)
	     ^
pkg/ride/compiler/ast_parser.go:1896:13: Error return value is not checked (errcheck)
		txType := p.stdTypes["Transaction"].(s.UnionType)
		          ^
pkg/ride/compiler/compaction.go:50:8: Error return value is not checked (errcheck)
		f := n.(*ast.FunctionDeclarationNode)
		     ^
pkg/ride/compiler/compaction.go:67:8: Error return value is not checked (errcheck)
		v := c.tree.Verifier.(*ast.FunctionDeclarationNode)
		     ^
pkg/ride/compiler/compaction.go:71:15: Error return value is not checked (errcheck)
		newVFunc := newV.(*ast.FunctionDeclarationNode)
		            ^
pkg/ride/compiler/compaction.go:112:8: Error return value is not checked (errcheck)
		f := n.(*ast.FunctionDeclarationNode)
		     ^
pkg/ride/compiler/compaction.go:264:8: Error return value is not checked (errcheck)
		f := n.(*ast.FunctionDeclarationNode)
		     ^
pkg/ride/compiler/compaction.go:268:8: Error return value is not checked (errcheck)
		v := tree.Verifier.(*ast.FunctionDeclarationNode)
		     ^
pkg/ride/compiler/ast_parser.go:314: Function 'ruleDirectiveHandler' has too many statements (62 > 50) (funlen)
func (p *astParser) ruleDirectiveHandler(node *node32, directiveCnt map[string]int) {
pkg/ride/compiler/ast_parser.go:807: Function 'ruleListGroupOpAtomHandler' is too long (115 > 100) (funlen)
func (p *astParser) ruleListGroupOpAtomHandler(node *node32) (ast.Node, s.Type) {
pkg/ride/compiler/ast_parser.go:1219: Function 'ruleGettableExprHandler' has too many statements (81 > 50) (funlen)
func (p *astParser) ruleGettableExprHandler(node *node32) (ast.Node, s.Type) {
pkg/ride/compiler/ast_parser.go:510:1: cognitive complexity 35 of func `(*astParser).tupleRefDeclaration` is high (> 20) (gocognit)
func (p *astParser) tupleRefDeclaration(node *node32) ([]ast.Node, []s.Type) {
^
pkg/ride/compiler/ast_parser.go:2100:1: cognitive complexity 32 of func `(*astParser).ruleObjectPatternHandler` is high (> 20) (gocognit)
func (p *astParser) ruleObjectPatternHandler(node *node32, matchName string, possibleTypes s.UnionType) (ast.Node, []ast.Node) {
^
pkg/ride/compiler/ast_parser.go:1769:1: cognitive complexity 29 of func `(*astParser).loadMetaBeforeV6` is high (> 20) (gocognit)
func (p *astParser) loadMetaBeforeV6(name string, argsTypes []s.Type) error {
^
pkg/ride/compiler/ast_parser.go:1819:1: cognitive complexity 28 of func `(*astParser).ruleAnnotatedFunc` is high (> 20) (gocognit)
func (p *astParser) ruleAnnotatedFunc(node *node32) {
^
pkg/ride/compiler/ast_parser.go:2032:1: cognitive complexity 28 of func `(*astParser).ruleValuePatternHandler` is high (> 20) (gocognit)
func (p *astParser) ruleValuePatternHandler(node *node32, matchName string, possibleTypes s.UnionType) (ast.Node, ast.Node) {
^
pkg/ride/compiler/ast_parser.go:925:1: cognitive complexity 27 of func `(*astParser).ruleMultGroupOpAtomHandler` is high (> 20) (gocognit)
func (p *astParser) ruleMultGroupOpAtomHandler(node *node32) (ast.Node, s.Type) {
^
pkg/ride/compiler/ast_parser.go:760:1: cognitive complexity 26 of func `(*astParser).ruleSumGroupOpAtomHandler` is high (> 20) (gocognit)
func (p *astParser) ruleSumGroupOpAtomHandler(node *node32) (ast.Node, s.Type) {
^
pkg/ride/compiler/parser_test.go:46:1: cognitive complexity 22 of func `checkAST` is high (> 20) (gocognit)
func checkAST(t *testing.T, expected string, ast *node32, buffer string) {
^
pkg/ride/compiler/ast_parser.go:704:1: cognitive complexity 21 of func `(*astParser).ruleCompareGroupOpAtomHandler` is high (> 20) (gocognit)
func (p *astParser) ruleCompareGroupOpAtomHandler(node *node32) (ast.Node, s.Type) {
^
pkg/ride/compiler/ast_parser.go:1906:1: cognitive complexity 21 of func `(*astParser).ruleMatchHandler` is high (> 20) (gocognit)
func (p *astParser) ruleMatchHandler(node *node32) (ast.Node, s.Type) {
^
pkg/ride/compiler/ast_parser.go:1854:7: string `Verifier` has 3 occurrences, make it a constant (goconst)
	case "Verifier":
	     ^
pkg/ride/compiler/ast_parser.go:1834:7: string `Callable` has 3 occurrences, make it a constant (goconst)
	case "Callable":
	     ^
pkg/ride/compiler/ast_parser.go:867:4: `if ok` has complex nested blocks (complexity: 17) (nestif)
			if l1, ok := varType.(s.ListType); ok {
			^
pkg/ride/compiler/ast_parser.go:536:2: `if !ok` has complex nested blocks (complexity: 11) (nestif)
	if !ok {
	^
pkg/ride/compiler/ast_parser_test.go:33:2: `if !fail` has complex nested blocks (complexity: 7) (nestif)
	if !fail {
	^
pkg/ride/compiler/parser_test.go:59:3: `if !ok` has complex nested blocks (complexity: 7) (nestif)
		if _, ok := discovered[n]; !ok {
		^
pkg/ride/compiler/ast_parser.go:843:4: `if !ok` has complex nested blocks (complexity: 6) (nestif)
			if _, ok := varType.(s.ListType); !ok {
			^
pkg/ride/compiler/ast_parser.go:1340:4: `if okU` has complex nested blocks (complexity: 6) (nestif)
			if u, okU := varType.(s.UnionType); okU {
			^
pkg/ride/compiler/ast_parser.go:726:3: `if s.BigIntType.Equal(varType)` has complex nested blocks (complexity: 5) (nestif)
		if s.BigIntType.Equal(varType) {
		^
pkg/ride/compiler/ast_parser.go:431:85: (*astParser).ruleDeclarationHandler - result 1 ([]github.com/wavesplatform/gowaves/pkg/ride/compiler/stdlib.Type) is never used (unparam)
func (p *astParser) ruleDeclarationHandler(node *node32, isBlock bool) ([]ast.Node, []s.Type) {
                                                                                    ^
pkg/ride/compiler/parser_test.go:12:41: `buildAST` - `pretty` always receives `false` (unparam)
func buildAST(t *testing.T, src string, pretty bool) (*node32, []rune, error) {
                                        ^
pkg/ride/compiler/ast_parser.go:397: unnecessary trailing newline (whitespace)

}
pkg/ride/compiler/ast_parser.go:1495: unnecessary trailing newline (whitespace)

}
pkg/ride/compiler/ast_parser.go:2167: unnecessary trailing newline (whitespace)

}
pkg/ride/compiler/ast_parser_test.go:343: unnecessary leading newline (whitespace)
	} {

pkg/ride/compiler/stack_test.go:1:1: the average complexity for the package compiler is 10.105263, max is 10.000000 (cyclop)
package compiler
^
pkg/ride/compiler/ast_parser.go:155:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch node.pegRule {
	^
pkg/ride/compiler/ast_parser.go:383:5: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
				switch curNode.pegRule {
				^
pkg/ride/compiler/ast_parser.go:432:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch node.pegRule {
	^
pkg/ride/compiler/ast_parser.go:475:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:741:3: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
		switch operator {
		^
pkg/ride/compiler/ast_parser.go:776:3: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
		switch operator {
		^
pkg/ride/compiler/ast_parser.go:833:3: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
		switch operator {
		^
pkg/ride/compiler/ast_parser.go:938:3: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
		switch operator {
		^
pkg/ride/compiler/ast_parser.go:982:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:995:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch unaryOp {
	^
pkg/ride/compiler/ast_parser.go:1026:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:1062:3: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
		switch curNode.pegRule {
		^
pkg/ride/compiler/ast_parser.go:1107:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch node.up.pegRule {
	^
pkg/ride/compiler/ast_parser.go:1196:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:1205:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:1223:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlockWithoutPar, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:1241:3: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef (exhaustive)
		switch curNode.pegRule {
		^
pkg/ride/compiler/ast_parser.go:1251:4: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
			switch asPegType {
			^
pkg/ride/compiler/ast_parser.go:1309:5: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
				switch listNode.pegRule {
				^
pkg/ride/compiler/ast_parser.go:1627:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleExpr, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:1977:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleIdentifier, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.ruleTupleValuesPattern, compiler.ruleObjectFieldsPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch statementNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:2179:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleParExpr, compiler.ruleGettableExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.rulePlaceholder, compiler.ruleValuePattern, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:2301:2: missing cases in switch of type compiler.pegRule: compiler.ruleUnknown, compiler.ruleCode, compiler.ruleDAppRoot, compiler.ruleScriptRoot, compiler.ruleWS, compiler.ruleEOL, compiler.ruleComment, compiler.rule_, compiler.ruleEOF, compiler.ruleDirectiveName, compiler.ruleUpperCaseString, compiler.ruleIntString, compiler.rulePathString, compiler.rulePaths, compiler.ruleDirective, compiler.ruleDeclaration, compiler.ruleVariable, compiler.ruleStrictVariable, compiler.ruleFunc, compiler.ruleFuncArgSeq, compiler.ruleFuncArg, compiler.ruleAnnotatedFunc, compiler.ruleAnnotation, compiler.ruleIdentifierSeq, compiler.ruleAnnotationSeq, compiler.ruleOrOp, compiler.ruleAndOp, compiler.ruleEqGroupOp, compiler.ruleEqOp, compiler.ruleNeOp, compiler.ruleCompareGroupOp, compiler.ruleGtOp, compiler.ruleGeOp, compiler.ruleLtOp, compiler.ruleLeOp, compiler.ruleListGroupOp, compiler.ruleConsOp, compiler.ruleConcatOp, compiler.ruleAppendOp, compiler.ruleSumGroupOp, compiler.ruleSumOp, compiler.ruleSubOp, compiler.ruleMultGroupOp, compiler.ruleMulOp, compiler.ruleDivOp, compiler.ruleModOp, compiler.ruleUnaryOp, compiler.rulePositiveOp, compiler.ruleNegativeOp, compiler.ruleNotOp, compiler.ruleReservedWords, compiler.ruleConst, compiler.ruleType, compiler.ruleGenericType, compiler.ruleTupleType, compiler.ruleTypes, compiler.ruleBase16, compiler.ruleBase58, compiler.ruleBase64, compiler.ruleByteVector, compiler.ruleBoolean, compiler.ruleString, compiler.ruleUnicodeChar, compiler.ruleEscapedChar, compiler.ruleChar, compiler.ruleInteger, compiler.ruleList, compiler.ruleExprSeq, compiler.ruleAtomExpr, compiler.ruleMultGroupOpAtom, compiler.ruleSumGroupOpAtom, compiler.ruleListGroupOpAtom, compiler.ruleCompareGroupOpAtom, compiler.ruleEqualityGroupOpAtom, compiler.ruleAndOpAtom, compiler.ruleOrOpAtom, compiler.ruleParExpr, compiler.ruleFunctionCallAccess, compiler.ruleIdentifierAccess, compiler.ruleListAccess, compiler.ruleAsType, compiler.ruleAsString, compiler.ruleExactAsString, compiler.ruleBlock, compiler.ruleBlockWithoutPar, compiler.ruleFunctionCall, compiler.ruleFoldMacro, compiler.ruleIfWithError, compiler.ruleIf, compiler.ruleFailedIfWithoutElse, compiler.ruleMatch, compiler.ruleCase, compiler.ruleTupleValuesPattern, compiler.ruleTuplePattern, compiler.ruleObjectFieldsPattern, compiler.ruleObjectPattern, compiler.ruleTuple, compiler.ruleTupleRef, compiler.ruleTupleAccess (exhaustive)
	switch curNode.pegRule {
	^
pkg/ride/compiler/ast_parser.go:277:2: assigned to expr, but reassigned without using the value (wastedassign)
	expr := block
	^
pkg/ride/compiler/ast_parser.go:1254:5: assigned to varType, but reassigned without using the value (wastedassign)
				varType = s.UnionType{Types: []s.Type{t, s.SimpleType{Type: "Unit"}}}
				^
pkg/ride/serialization/parsing.go:93: Function 'parseDApp' has too many statements (52 > 50) (funlen)
func (p *parser) parseDApp() (*ast.Tree, error) {
pkg/ride/serialization/parsing.go:179: Function 'parseNext' has too many statements (90 > 50) (funlen)
func (p *parser) parseNext() (ast.Node, error) {
pkg/ride/serialization/serialization.go:181: Function 'walk' has too many statements (90 > 50) (funlen)
func (s *serializer) walk(node ast.Node) error {
pkg/miner/miner.go:73:7: Error return value is not checked (errcheck)
	b := bi.(*proto.Block)
	     ^
pkg/miner/micro_miner.go:34: Function 'Micro' is too long (146 > 100) (funlen)
func (a *MicroMiner) Micro(minedBlock *proto.Block, rest proto.MiningLimits, keyPair proto.KeyPair) (*proto.Block, *proto.MicroBlock, proto.MiningLimits, error) {
pkg/miner/features_test.go:24: unnecessary trailing newline (whitespace)

}
pkg/state/transaction_differ.go:1282: 1282-1306 lines are duplicate of `pkg/state/transaction_differ.go:1308-1332` (dupl)
func (td *transactionDiffer) createDiffDataWithProofs(transaction proto.Transaction, info *differInfo) (txBalanceChanges, error) {
	tx, ok := transaction.(*proto.DataWithProofs)
	if !ok {
		return txBalanceChanges{}, errors.New("failed to convert interface to DataWithProofs transaction")
	}
	diff := newTxDiff()
	senderAddr, err := proto.NewAddressFromPublicKey(td.settings.AddressSchemeCharacter, tx.SenderPK)
	if err != nil {
		return txBalanceChanges{}, err
	}
	// Append sender diff.
	senderFeeKey := wavesBalanceKey{address: senderAddr.ID()}
	senderFeeBalanceDiff := -int64(tx.Fee)
	if err := diff.appendBalanceDiff(senderFeeKey.bytes(), newBalanceDiff(senderFeeBalanceDiff, 0, 0, false)); err != nil {
		return txBalanceChanges{}, err
	}
	if info.hasMiner() {
		if err := td.minerPayoutInWaves(diff, tx.Fee, info); err != nil {
			return txBalanceChanges{}, errors.Wrap(err, "failed to append miner payout")
		}
	}
	addresses := []proto.WavesAddress{senderAddr}
	changes := newTxBalanceChanges(addresses, diff)
	return changes, nil
}
pkg/state/transaction_differ.go:1308: 1308-1332 lines are duplicate of `pkg/state/transaction_differ.go:1334-1358` (dupl)
func (td *transactionDiffer) createDiffSponsorshipWithProofs(transaction proto.Transaction, info *differInfo) (txBalanceChanges, error) {
	tx, ok := transaction.(*proto.SponsorshipWithProofs)
	if !ok {
		return txBalanceChanges{}, errors.New("failed to convert interface to SponsorshipWithProofs transaction")
	}
	diff := newTxDiff()
	senderAddr, err := proto.NewAddressFromPublicKey(td.settings.AddressSchemeCharacter, tx.SenderPK)
	if err != nil {
		return txBalanceChanges{}, err
	}
	// Append sender diff.
	senderFeeKey := wavesBalanceKey{address: senderAddr.ID()}
	senderFeeBalanceDiff := -int64(tx.Fee)
	if err := diff.appendBalanceDiff(senderFeeKey.bytes(), newBalanceDiff(senderFeeBalanceDiff, 0, 0, false)); err != nil {
		return txBalanceChanges{}, err
	}
	if info.hasMiner() {
		if err := td.minerPayoutInWaves(diff, tx.Fee, info); err != nil {
			return txBalanceChanges{}, errors.Wrap(err, "failed to append miner payout")
		}
	}
	addresses := []proto.WavesAddress{senderAddr}
	changes := newTxBalanceChanges(addresses, diff)
	return changes, nil
}
pkg/state/transaction_differ.go:1334: 1334-1358 lines are duplicate of `pkg/state/transaction_differ.go:1360-1384` (dupl)
func (td *transactionDiffer) createDiffSetScriptWithProofs(transaction proto.Transaction, info *differInfo) (txBalanceChanges, error) {
	tx, ok := transaction.(*proto.SetScriptWithProofs)
	if !ok {
		return txBalanceChanges{}, errors.New("failed to convert interface to SetScriptWithProofs transaction")
	}
	diff := newTxDiff()
	senderAddr, err := proto.NewAddressFromPublicKey(td.settings.AddressSchemeCharacter, tx.SenderPK)
	if err != nil {
		return txBalanceChanges{}, err
	}
	// Append sender diff.
	senderFeeKey := wavesBalanceKey{address: senderAddr.ID()}
	senderFeeBalanceDiff := -int64(tx.Fee)
	if err := diff.appendBalanceDiff(senderFeeKey.bytes(), newBalanceDiff(senderFeeBalanceDiff, 0, 0, false)); err != nil {
		return txBalanceChanges{}, err
	}
	if info.hasMiner() {
		if err := td.minerPayoutInWaves(diff, tx.Fee, info); err != nil {
			return txBalanceChanges{}, errors.Wrap(err, "failed to append miner payout")
		}
	}
	addresses := []proto.WavesAddress{senderAddr}
	changes := newTxBalanceChanges(addresses, diff)
	return changes, nil
}
pkg/state/transaction_differ.go:1360: 1360-1384 lines are duplicate of `pkg/state/transaction_differ.go:1282-1306` (dupl)
func (td *transactionDiffer) createDiffSetAssetScriptWithProofs(transaction proto.Transaction, info *differInfo) (txBalanceChanges, error) {
	tx, ok := transaction.(*proto.SetAssetScriptWithProofs)
	if !ok {
		return txBalanceChanges{}, errors.New("failed to convert interface to SetAssetScriptWithProofs transaction")
	}
	diff := newTxDiff()
	senderAddr, err := proto.NewAddressFromPublicKey(td.settings.AddressSchemeCharacter, tx.SenderPK)
	if err != nil {
		return txBalanceChanges{}, err
	}
	// Append sender diff.
	senderFeeKey := wavesBalanceKey{address: senderAddr.ID()}
	senderFeeBalanceDiff := -int64(tx.Fee)
	if err := diff.appendBalanceDiff(senderFeeKey.bytes(), newBalanceDiff(senderFeeBalanceDiff, 0, 0, false)); err != nil {
		return txBalanceChanges{}, err
	}
	if info.hasMiner() {
		if err := td.minerPayoutInWaves(diff, tx.Fee, info); err != nil {
			return txBalanceChanges{}, errors.Wrap(err, "failed to append miner payout")
		}
	}
	addresses := []proto.WavesAddress{senderAddr}
	changes := newTxBalanceChanges(addresses, diff)
	return changes, nil
}
pkg/state/transaction_checker.go:640: 640-665 lines are duplicate of `pkg/state/transaction_checker.go:711-737` (dupl)
func (tc *transactionChecker) checkReissueWithProofs(transaction proto.Transaction, info *checkerInfo) ([]crypto.Digest, error) {
	tx, ok := transaction.(*proto.ReissueWithProofs)
	if !ok {
		return nil, errors.New("failed to convert interface to ReissueWithProofs transaction")
	}
	allAssets := []proto.OptionalAsset{*proto.NewOptionalAssetFromDigest(tx.AssetID)}
	smartAssets, err := tc.smartAssets(allAssets)
	if err != nil {
		return nil, err
	}
	assets := &txAssets{feeAsset: proto.NewOptionalAssetWaves(), smartAssets: smartAssets}
	if err := tc.checkFee(transaction, assets, info); err != nil {
		return nil, err
	}
	activated, err := tc.stor.features.newestIsActivated(int16(settings.SmartAccounts))
	if err != nil {
		return nil, err
	}
	if !activated {
		return nil, errors.New("SmartAccounts feature has not been activated yet")
	}
	if err := tc.checkReissue(&tx.Reissue, info); err != nil {
		return nil, err
	}
	return smartAssets, nil
}
pkg/state/transaction_checker.go:711: 711-737 lines are duplicate of `pkg/state/transaction_checker.go:640-665` (dupl)
func (tc *transactionChecker) checkBurnWithProofs(transaction proto.Transaction, info *checkerInfo) ([]crypto.Digest, error) {
	tx, ok := transaction.(*proto.BurnWithProofs)
	if !ok {
		return nil, errors.New("failed to convert interface to BurnWithProofs transaction")
	}
	allAssets := []proto.OptionalAsset{*proto.NewOptionalAssetFromDigest(tx.AssetID)}
	smartAssets, err := tc.smartAssets(allAssets)
	if err != nil {
		return nil, err
	}

	assets := &txAssets{feeAsset: proto.NewOptionalAssetWaves(), smartAssets: smartAssets}
	if err := tc.checkFee(transaction, assets, info); err != nil {
		return nil, err
	}
	activated, err := tc.stor.features.newestIsActivated(int16(settings.SmartAccounts))
	if err != nil {
		return nil, err
	}
	if !activated {
		return nil, errors.New("SmartAccounts feature has not been activated yet")
	}
	if err := tc.checkBurn(&tx.Burn, info); err != nil {
		return nil, err
	}
	return smartAssets, nil
}
pkg/state/accounts_data_storage.go:21:9: Error return value is not checked (errcheck)
	dr2 := other.(*dataEntryRecordForHashes)
	       ^
pkg/state/aliases.go:35:9: Error return value is not checked (errcheck)
	ar2 := other.(*aliasRecordForStateHashes)
	       ^
pkg/state/balances.go:93:9: Error return value is not checked (errcheck)
	lc2 := other.(*leaseBalanceRecordForHashes)
	       ^
pkg/state/balances.go:120:9: Error return value is not checked (errcheck)
	wc2 := other.(*wavesRecordForHashes)
	       ^
pkg/state/balances.go:143:9: Error return value is not checked (errcheck)
	ac2 := other.(*assetRecordForHashes)
	       ^
pkg/state/leases.go:39:9: Error return value is not checked (errcheck)
	lr2 := other.(*leaseRecordForStateHashes)
	       ^
pkg/state/scripts_storage.go:50:9: Error return value is not checked (errcheck)
	ac2 := other.(*accountScripRecordForHashes)
	       ^
pkg/state/scripts_storage.go:72:9: Error return value is not checked (errcheck)
	as2 := other.(*assetScripRecordForHashes)
	       ^
pkg/state/sponsored_assets.go:37:9: Error return value is not checked (errcheck)
	sr2 := other.(*sponsorshipRecordForHashes)
	       ^
pkg/state/blockreadwriter_test.go:278:4: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Printf("Writer error: %v\n", err1)
			^
pkg/state/blockreadwriter_test.go:291:5: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
				fmt.Printf("Reader error: %v\n", err1)
				^
pkg/state/blockreadwriter_test.go:322:4: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Printf("Writer error: %v\n", err1)
			^
pkg/state/blockreadwriter_test.go:335:5: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
				fmt.Printf("Reader error: %v\n", err1)
				^
pkg/state/blockreadwriter_test.go:442:4: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Printf("Writer error: %v\n", err1)
			^
pkg/state/blockreadwriter_test.go:455:5: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
				fmt.Printf("Reader error: %v\n", err1)
				^
pkg/state/address_transactions.go:289: Function 'persist' has too many statements (54 > 50) (funlen)
func (at *addressTransactions) persist() error {
pkg/state/appender.go:436: Function 'appendTx' has too many statements (69 > 50) (funlen)
func (a *txAppender) appendTx(tx proto.Transaction, params *appendTxParams) error {
pkg/state/appender.go:710: Function 'handleExchange' has too many statements (54 > 50) (funlen)
func (a *txAppender) handleExchange(tx proto.Transaction, info *fallibleValidationParams) (*applicationResult, error) {
pkg/state/fee_validation.go:90: Function 'minFeeInUnits' has too many statements (87 > 50) (funlen)
func minFeeInUnits(params *feeValidationParams, tx proto.Transaction) (uint64, error) {
pkg/state/invoke_applier.go:314: Function 'fallibleValidation' has too many statements (232 > 50) (funlen)
func (ia *invokeApplier) fallibleValidation(tx proto.Transaction, info *addlInvokeInfo) (proto.TxFailureReason, txBalanceChanges, error) {
pkg/state/invoke_applier.go:732: Function 'applyInvokeScript' has too many statements (113 > 50) (funlen)
func (ia *invokeApplier) applyInvokeScript(tx proto.Transaction, info *fallibleValidationParams) (*applicationResult, error) {
pkg/state/keys.go:133: Function 'prefixByEntity' has too many statements (53 > 50) (funlen)
func prefixByEntity(entity blockchainEntity) ([]byte, error) {
pkg/state/script_caller.go:261: Function 'invokeFunction' has too many statements (89 > 50) (funlen)
func (a *scriptCaller) invokeFunction(tree *ast.Tree, tx proto.Transaction, info *fallibleValidationParams, scriptAddress proto.WavesAddress) (ride.Result, error) {
pkg/state/state.go:375: Function 'newStateManager' has too many statements (74 > 50) (funlen)
func newStateManager(dataDir string, amend bool, params StateParams, settings *settings.BlockchainSettings) (*stateManager, error) {
pkg/state/state.go:1433: Function 'addBlocks' has too many statements (60 > 50) (funlen)
func (s *stateManager) addBlocks() (*proto.Block, error) {
pkg/state/transaction_checker.go:393: Function 'checkEthereumTransactionWithProofs' has too many statements (60 > 50) (funlen)
func (tc *transactionChecker) checkEthereumTransactionWithProofs(transaction proto.Transaction, info *checkerInfo) ([]crypto.Digest, error) {
pkg/state/transaction_checker.go:802: Function 'checkExchange' has too many statements (65 > 50) (funlen)
func (tc *transactionChecker) checkExchange(transaction proto.Transaction, info *checkerInfo) ([]crypto.Digest, error) {
pkg/state/transaction_differ.go:854: Function 'createDiffExchange' has too many statements (88 > 50) (funlen)
func (td *transactionDiffer) createDiffExchange(transaction proto.Transaction, info *differInfo) (txBalanceChanges, error) {
pkg/state/test_util.go:23:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/state/blockreadwriter_test.go:62:1: cognitive complexity 39 of func `writeBlocks` is high (> 20) (gocognit)
func writeBlocks(ctx context.Context, rw *blockReadWriter, blocks []proto.Block, readTasks chan<- *readTask, flush, protobuf bool) error {
^
pkg/state/blockreadwriter_test.go:190:1: cognitive complexity 39 of func `testReader` is high (> 20) (gocognit)
func testReader(rw *blockReadWriter, readTasks <-chan *readTask) error {
^
pkg/state/blockreadwriter_test.go:142:1: cognitive complexity 33 of func `testNewestReader` is high (> 20) (gocognit)
func testNewestReader(rw *blockReadWriter, readTasks <-chan *readTask) error {
^
pkg/state/balances.go:393:1: cognitive complexity 25 of func `(*balances).nftList` is high (> 20) (gocognit)
func (s *balances) nftList(addr proto.AddressID, limit uint64, afterAssetID *proto.AssetID) ([]crypto.Digest, error) {
^
pkg/state/state.go:1341:1: cognitive complexity 25 of func `(*stateManager).cancelLeases` is high (> 20) (gocognit)
func (s *stateManager) cancelLeases(height uint64, blockID proto.BlockID) error {
^
pkg/state/state_test.go:208:1: cognitive complexity 25 of func `TestStateIntegrated` is high (> 20) (gocognit)
func TestStateIntegrated(t *testing.T) {
^
pkg/state/transaction_checker.go:69:1: cognitive complexity 22 of func `(*transactionChecker).scriptActivation` is high (> 20) (gocognit)
func (tc *transactionChecker) scriptActivation(libVersion ast.LibraryVersion, hasBlockV2 bool) (scriptFeaturesActivations, error) {
^
pkg/state/state.go:1275:1: cognitive complexity 21 of func `(*stateManager).blockchainHeightAction` is high (> 20) (gocognit)
func (s *stateManager) blockchainHeightAction(blockchainHeight uint64, lastBlock, nextBlock proto.BlockID) error {
^
pkg/state/appender.go:268:2: `if ride4DAppsActivated` has complex nested blocks (complexity: 8) (nestif)
	if ride4DAppsActivated {
	^
pkg/state/appender.go:732:2: `if smartAccountTradingActivated` has complex nested blocks (complexity: 8) (nestif)
	if smartAccountTradingActivated {
	^
pkg/state/balances.go:636:2: `if s.calculateHashes` has complex nested blocks (complexity: 7) (nestif)
	if s.calculateHashes {
	^
pkg/state/invoke_applier.go:906:2: `if info.senderScripted` has complex nested blocks (complexity: 6) (nestif)
	if info.senderScripted {
	^
pkg/state/history_storage.go:246:2: `if property.fixedSize` has complex nested blocks (complexity: 5) (nestif)
	if property.fixedSize {
	^
pkg/state/invoke_applier.go:846:2: `if err != nil` has complex nested blocks (complexity: 5) (nestif)
	if err != nil {
	^
pkg/state/state.go:2221:23: unnecessary conversion (unconvert)
	txID := crypto.Digest(ai.ID)             // explicitly show that full asset ID is a crypto.Digest and equals txID
	                     ^
pkg/state/blockreadwriter.go:382:53: unnecessary conversion (unconvert)
	binary.BigEndian.PutUint32(headerBytes[4:8], uint32(h.TransactionBlockLength))
	                                                   ^
pkg/state/accounts_data_storage.go:51:52: (*dataEntryRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *dataEntryRecord) marshalBinary() ([]byte, error) {
                                                   ^
pkg/state/accounts_data_storage.go:57:56: (*dataEntryRecord).unmarshalBinary - result 0 (error) is always nil (unparam)
func (r *dataEntryRecord) unmarshalBinary(data []byte) error {
                                                       ^
pkg/state/accounts_data_storage_test.go:15:46: `createAccountsDataStorage` - `amend` always receives `true` (unparam)
func createAccountsDataStorage(t *testing.T, amend bool) *accountsDataStorageTestObjects {
                                             ^
pkg/state/aliases.go:54:48: (*aliasRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *aliasRecord) marshalBinary() ([]byte, error) {
                                               ^
pkg/state/balances.go:50:55: (*wavesBalanceRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *wavesBalanceRecord) marshalBinary() ([]byte, error) {
                                                      ^
pkg/state/balances.go:72:55: (*assetBalanceRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *assetBalanceRecord) marshalBinary() ([]byte, error) {
                                                      ^
pkg/state/common_test.go:474:105: (*testStorageObjects).createAssetWithDecimals - result 0 (*github.com/wavesplatform/gowaves/pkg/state.assetInfo) is never used (unparam)
func (s *testStorageObjects) createAssetWithDecimals(t *testing.T, assetID crypto.Digest, decimals int) *assetInfo {
                                                                                                        ^
pkg/state/diff_applier.go:19:77: newDiffApplier - result 1 (error) is always nil (unparam)
func newDiffApplier(balances *balances, scheme proto.Scheme) (*diffApplier, error) {
                                                                            ^
pkg/state/diff_storage.go:62:38: newDiffStorage - result 1 (error) is always nil (unparam)
func newDiffStorage() (*diffStorage, error) {
                                     ^
pkg/state/features.go:23:60: (*activatedFeaturesRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *activatedFeaturesRecord) marshalBinary() ([]byte, error) {
                                                           ^
pkg/state/features.go:41:59: (*approvedFeaturesRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *approvedFeaturesRecord) marshalBinary() ([]byte, error) {
                                                          ^
pkg/state/features.go:59:56: (*votesFeaturesRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *votesFeaturesRecord) marshalBinary() ([]byte, error) {
                                                       ^
pkg/state/features.go:237:32: `(*features).isActivated` - `featureID` always receives `featureID` (`1`) (unparam)
func (f *features) isActivated(featureID int16) (bool, error) {
                               ^
pkg/state/headers_validation_test.go:54:44: spoilGenSignature - result 0 (error) is always nil (unparam)
func spoilGenSignature(block *proto.Block) error {
                                           ^
pkg/state/history_formatter.go:16:59: newHistoryFormatter - result 1 (error) is always nil (unparam)
func newHistoryFormatter(db *stateDB) (*historyFormatter, error) {
                                                          ^
pkg/state/history_storage.go:208:50: (*historyEntry).marshalBinary - result 1 (error) is always nil (unparam)
func (he *historyEntry) marshalBinary() ([]byte, error) {
                                                 ^
pkg/state/local_history_storage.go:40:54: newLocalHistoryStorage - result 1 (error) is always nil (unparam)
func newLocalHistoryStorage() (*localHistoryStorage, error) {
                                                     ^
pkg/state/monetary_policy.go:24:54: (*blockRewardRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *blockRewardRecord) marshalBinary() ([]byte, error) {
                                                     ^
pkg/state/monetary_policy.go:43:54: (*rewardVotesRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (r *rewardVotesRecord) marshalBinary() ([]byte, error) {
                                                     ^
pkg/state/orders_volume.go:19:54: (*orderVolumeRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (o *orderVolumeRecord) marshalBinary() ([]byte, error) {
                                                     ^
pkg/state/script_caller.go:30:19: newScriptCaller - result 1 (error) is always nil (unparam)
) (*scriptCaller, error) {
                  ^
pkg/state/sponsored_assets.go:46:54: (*sponsorshipRecord).marshalBinary - result 1 (error) is always nil (unparam)
func (s *sponsorshipRecord) marshalBinary() ([]byte, error) {
                                                     ^
pkg/state/sponsored_assets.go:126:75: (*sponsoredAssets).newestIsSponsored - result 1 (error) is always nil (unparam)
func (s *sponsoredAssets) newestIsSponsored(assetID proto.AssetID) (bool, error) {
                                                                          ^
pkg/state/transaction_checker.go:61:25: newTransactionChecker - result 1 (error) is always nil (unparam)
) (*transactionChecker, error) {
                        ^
pkg/state/transaction_fee_counter.go:27:89: newTransactionFeeCounter - result 1 (error) is always nil (unparam)
func newTransactionFeeCounter(stor *blockchainEntitiesStorage) (*transactionFeeCounter, error) {
                                                                                        ^
pkg/state/accounts_data_storage.go:101:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound {
	   ^
pkg/state/address_transactions.go:252:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == errNotFound {
	   ^
pkg/state/address_transactions.go:349:6: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
		if err == io.EOF {
		   ^
pkg/state/balances.go:526:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/balances.go:538:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/balances.go:549:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/balances.go:573:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/batched_storage.go:322:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == errNotFound {
	   ^
pkg/state/database.go:273:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound {
	   ^
pkg/state/diff_storage.go:95:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == errNotFound {
	   ^
pkg/state/features.go:133:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist || recordBytes == nil {
	   ^
pkg/state/features.go:150:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/features.go:167:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/features.go:376:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/features.go:392:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == keyvalue.ErrNotFound || err == errEmptyHist {
	   ^
pkg/state/appender.go:193:2: missing cases in switch of type proto.TransactionType: proto.GenesisTransaction, proto.PaymentTransaction, proto.IssueTransaction, proto.TransferTransaction, proto.ReissueTransaction, proto.BurnTransaction, proto.LeaseTransaction, proto.LeaseCancelTransaction, proto.CreateAliasTransaction, proto.MassTransferTransaction, proto.DataTransaction, proto.SetScriptTransaction, proto.SponsorshipTransaction, proto.SetAssetScriptTransaction, proto.UpdateAssetInfoTransaction (exhaustive)
	switch tx.GetTypeInfo().Type {
	^
pkg/state/appender.go:474:2: missing cases in switch of type proto.TransactionType: proto.GenesisTransaction, proto.PaymentTransaction, proto.IssueTransaction, proto.TransferTransaction, proto.ReissueTransaction, proto.BurnTransaction, proto.LeaseTransaction, proto.LeaseCancelTransaction, proto.CreateAliasTransaction, proto.MassTransferTransaction, proto.DataTransaction, proto.SetScriptTransaction, proto.SponsorshipTransaction, proto.SetAssetScriptTransaction, proto.UpdateAssetInfoTransaction (exhaustive)
	switch tx.GetTypeInfo().Type {
	^
pkg/state/scripts_cache.go:89:3: naked return in func `get` with 9 lines of code (nakedret)
		return
		^
pkg/state/appender.go:786:4: error is not nil (line 780) but it returns nil (nilerr)
			return &applicationResult{false, scriptsRuns, failedChanges}, nil
			^
pkg/state/appender.go:794:4: error is not nil (line 791) but it returns nil (nilerr)
			return &applicationResult{false, scriptsRuns, failedChanges}, nil
			^
pkg/state/batched_storage.go:408:3: error is not nil (line 405) but it returns nil (nilerr)
		return nil
		^
pkg/state/orders_volume.go:89:3: error is not nil (line 86) but it returns nil (nilerr)
		return 0, nil
		^
pkg/state/orders_volume.go:98:3: error is not nil (line 95) but it returns nil (nilerr)
		return 0, nil
		^
pkg/state/scripts_storage.go:299:3: error is not nil (line 297) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:312:3: error is not nil (line 310) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:390:3: error is not nil (line 388) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:406:3: error is not nil (line 404) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:429:3: error is not nil (line 427) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:445:3: error is not nil (line 443) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:465:3: error is not nil (line 463) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/scripts_storage.go:478:3: error is not nil (line 476) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/sponsored_assets.go:129:3: error is not nil (line 127) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/sponsored_assets.go:142:3: error is not nil (line 140) but it returns nil (nilerr)
		return false, nil
		^
pkg/state/leases.go:120:3: return both the `nil` error and invalid value: use a sentinel error instead (nilnil)
		return nil, nil
		^
pkg/state/api.go:206:2: ST1003: struct field DbParams should be DBParams (stylecheck)
	DbParams        keyvalue.KeyValParams
	^
pkg/state/blockreadwriter.go:964:28: ST1003: method syncWithDb should be syncWithDB (stylecheck)
func (rw *blockReadWriter) syncWithDb() error {
                           ^
pkg/state/history_storage.go:561:27: ST1003: method manageDbUpdate should be manageDBUpdate (stylecheck)
func (hs *historyStorage) manageDbUpdate(key []byte, history *historyRecord) error {
                          ^
pkg/consensus/blocks_validation.go:325:2: `if vrf` has complex nested blocks (complexity: 7) (nestif)
	if vrf {
	^
pkg/wallet/crypt_test.go:3: File is not `goimports`-ed (goimports)
import (
cmd/forkdetector/internal/tcpext.go:187:13: Error return value is not checked (errcheck)
	tcpConn := c.RawConn.(*net.TCPConn)
	           ^
cmd/forkdetector/internal/graph_test.go:112:2: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Println(len(p))
	^
cmd/forkdetector/internal/graph_test.go:139:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Graph with %d nodes was built in %s\n", nodesCount, time.Since(start))
	^
cmd/forkdetector/internal/graph_test.go:144:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Length of the path from the last node (%d) found in %s\n", l, time.Since(start))
	^
cmd/forkdetector/internal/graph_test.go:149:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Path from the last node was found in %s\n", time.Since(start))
	^
cmd/forkdetector/internal/graph_test.go:154:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Intersection %d of paths was found in %s\n", int(x), time.Since(start))
	^
cmd/forkdetector/internal/graph_test.go:201:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Alloc = %v MiB", bToMb(m.Alloc))
	^
cmd/forkdetector/internal/graph_test.go:202:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
	^
cmd/forkdetector/internal/graph_test.go:203:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("\tSys = %v MiB", bToMb(m.Sys))
	^
cmd/forkdetector/internal/graph_test.go:204:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("\tNumGC = %v\n", m.NumGC)
	^
cmd/forkdetector/internal/synchronizer.go:41:1: cognitive complexity 39 of func `(*synchronizer).start` is high (> 20) (gocognit)
func (s *synchronizer) start() {
^
cmd/forkdetector/internal/distributor.go:40:1: cognitive complexity 29 of func `(*distributor).Start` is high (> 20) (gocognit)
func (l *distributor) Start() <-chan struct{} {
^
cmd/forkdetector/internal/tcpext.go:434:1: cognitive complexity 28 of func `(*Server).Serve` is high (> 20) (gocognit)
func (s *Server) Serve(l net.Listener) {
^
cmd/forkdetector/internal/tcpext.go:611:1: cognitive complexity 24 of func `(*safeReader).read` is high (> 20) (gocognit)
func (r *safeReader) read(buf []byte) uint64 {
^
cmd/forkdetector/internal/drawer.go:9: File is not `goimports`-ed (goimports)
	"github.com/seiflotfy/cuckoofilter"
cmd/forkdetector/internal/tcpext.go:622:2: `if err != nil` has complex nested blocks (complexity: 14) (nestif)
	if err != nil {
	^
cmd/forkdetector/internal/tcpext.go:446:3: `if err != nil` has complex nested blocks (complexity: 9) (nestif)
		if err != nil {
		^
cmd/forkdetector/internal/tcpext.go:154:3: `if mode == StopImmediately` has complex nested blocks (complexity: 5) (nestif)
		if mode == StopImmediately {
		^
cmd/forkdetector/internal/tcpext.go:294:3: `if err != nil` has complex nested blocks (complexity: 5) (nestif)
		if err != nil {
		^
cmd/forkdetector/internal/tcpext.go:241:40: unnecessary conversion (unconvert)
		atomic.AddUint64(&c.recvBytes, uint64(n))
		                                     ^
cmd/forkdetector/internal/tcpext.go:252:40: unnecessary conversion (unconvert)
		atomic.AddUint64(&c.recvBytes, uint64(n))
		                                     ^
cmd/forkdetector/internal/tcpext.go:266:40: unnecessary conversion (unconvert)
		atomic.AddUint64(&c.recvBytes, uint64(n))
		                                     ^
cmd/forkdetector/internal/graph_test.go:129:24: unnecessary conversion (unconvert)
				current[j] = uint32(n)
				                   ^
cmd/forkdetector/internal/graph_test.go:184:24: unnecessary conversion (unconvert)
				current[j] = uint32(n)
				                   ^
cmd/forkdetector/internal/drawer.go:26:45: (*safeCuckooFilter).insert - result 0 (bool) is never used (unparam)
func (f *safeCuckooFilter) insert(d []byte) bool {
                                            ^
cmd/retransmitter/retransmit/network/incoming_peer.go:148:10: Error return value is not checked (errcheck)
	addr := a.conn.Conn().RemoteAddr().(*net.TCPAddr)
	        ^
cmd/retransmitter/retransmit/network/outgoing_peer_test.go:112:16: Error return value is not checked (errcheck)
		connected := m.Value.(*peer.Connected)
		             ^
pkg/crypto/groth16.go:23:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/crypto/groth16.go:81:3: error is not nil (line 79) but it returns nil (nilerr)
		return false, nil
		^
pkg/crypto/errors.go:15:43: param len has same name as predeclared identifier (predeclared)
func NewIncorrectLengthError(name string, len int, expectedLen int) IncorrectLengthError {
                                          ^
pkg/crypto/messaging_test.go:215:4: ST1018: string literal contains Unicode format characters, consider using escape sequences instead (stylecheck)
		{"🏳️‍🌈🇩🇪🏳️‍🌈🇩🇪", "160402a95f2c35d533d03e75d93347409489b97259a6ebfb1c6f6c53677611b5"},
		 ^
cmd/retransmitter/main.go:80:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println(err)
		^
pkg/proto/types.go:4012:6: `FieldsHashes` should be annotated with the `json` tag as it is passed to `json.Marshal` at cmd/statecmp/statecmp.go:78:18 (musttag)
type FieldsHashes struct {
     ^
pkg/api/helpers.go:7:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/api/metrics.go:37:1: don't use `init` function (gochecknoinits)
func init() {
^
pkg/api/miner_test.go:5: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/require"
pkg/api/metrics.go:11:3: Metric: http_api_total_hits Error: counter metrics should have "_total" suffix (promlinter)
		prometheus.CounterOpts{
		^
pkg/api/metrics.go:19:3: Metric: http_api_path_hits Error: counter metrics should have "_total" suffix (promlinter)
		prometheus.CounterOpts{
		^
pkg/api/metrics.go:28:3: Metric: http_api_path_duration Error: no help text (promlinter)
		prometheus.HistogramOpts{
		^
pkg/api/node_api_test.go:28:29: "POST" can be replaced by http.MethodPost (usestdlibvars)
	req := httptest.NewRequest("POST", "/blocks/rollback", strings.NewReader(`{"height": 100500}`))
	                           ^
pkg/api/node_api_test.go:53:29: "POST" can be replaced by http.MethodPost (usestdlibvars)
	req := httptest.NewRequest("POST", "/wallet/load", strings.NewReader(`{"password": "password"}`))
	                           ^
pkg/node/state_fsm/fsm_ng.go:36:8: Error return value is not checked (errcheck)
		t := task.Data.(MineMicroTaskData)
		     ^
pkg/node/state_fsm/fsm_sync.go:162:3: error is not nil (line 160) but it returns nil (nilerr)
		return a, nil, nil // We've failed to apply mined block, it's not an error
		^
cmd/convert/main.go:18:1: don't use `init` function (gochecknoinits)
func init() {
^
cmd/retransmitter/retransmit/behaviour.go:8:2: ST1019: package "github.com/wavesplatform/gowaves/pkg/p2p/peer" is being imported more than once (stylecheck)
	"github.com/wavesplatform/gowaves/pkg/p2p/peer"
	^
pkg/api/errors/basics_test.go:4: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/assert"
pkg/api/errors/validation_test.go:5: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/assert"
pkg/grpc/server/accounts_api.go:31:3: `if len(asset) == 0` has complex nested blocks (complexity: 5) (nestif)
		if len(asset) == 0 {
		^
pkg/grpc/server/accounts_api.go:119:2: `if req.Key != ""` has complex nested blocks (complexity: 5) (nestif)
	if req.Key != "" {
	^
pkg/grpc/server/transactions_api.go:52:2: `if iter == nil` has complex nested blocks (complexity: 5) (nestif)
	if iter == nil {
	^
pkg/grpc/server/transactions_api.go:146:3: `if err == nil` has complex nested blocks (complexity: 5) (nestif)
		if _, failed, err := s.state.TransactionByIDWithStatus(id); err == nil {
		^
pkg/grpc/server/grpc_server.go:70:97: (*Server).initServer - result 0 (error) is always nil (unparam)
func (s *Server) initServer(state state.StateInfo, utx types.UtxPool, sch types.EmbeddedWallet) error {
                                                                                                ^
pkg/util/fifo_cache/cache.go:60:2: naked return in func `Get` with 5 lines of code (nakedret)
	return
	^
cmd/wallet/main.go:94:3: use of `fmt.Print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Print("Failed to handle more than one primary flag")
		^
cmd/wallet/main.go:103:4: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Println(err)
			^
cmd/wallet/main.go:112:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println(err)
		^
cmd/wallet/main.go:133:2: use of `fmt.Print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Print("Enter password to decode your wallet: ")
	^
cmd/wallet/main.go:178:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println()
		^
cmd/wallet/main.go:179:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Account number: %d\n", i)
		^
cmd/wallet/main.go:180:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Account seed:   %s\n", accountSeedDigest.String())
		^
cmd/wallet/main.go:181:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Public Key:     %s\n", pk.String())
		^
cmd/wallet/main.go:182:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Secret Key:     %s\n", sk.String())
		^
cmd/wallet/main.go:183:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Address:        %s\n", address.String())
		^
cmd/wallet/main.go:189:2: use of `fmt.Print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Print(usage)
	^
cmd/wallet/main.go:191:2: use of `fmt.Print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Print(examples)
	^
cmd/wallet/main.go:268:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Seed Phrase: '%s'\n", newSeedPhrase)
		^
cmd/wallet/main.go:354:3: use of `fmt.Print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Print("Wallet already exists. Do you want to [A]dd / [O]verwrite / [C]ancel? ")
		^
cmd/wallet/main.go:385:3: use of `fmt.Print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Print("Enter password to encode your account seed: ")
		^
cmd/wallet/main.go:407:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("New account has been to wallet successfully %s\n", walletPath)
	^
cmd/wallet/main.go:408:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Account Seed:   %s\n", walletCredentials.accountSeed.String())
	^
cmd/wallet/main.go:409:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Public Key:     %s\n", walletCredentials.pk.String())
	^
cmd/wallet/main.go:410:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Secret Key:     %s\n", walletCredentials.sk.String())
	^
cmd/wallet/main.go:411:2: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Printf("Address:        %s\n", walletCredentials.address.String())
	^
cmd/wmd/internal/state/keys.go:4: File is not `goimports`-ed (goimports)
	"encoding/binary"
cmd/wmd/internal/state/storage.go:8: File is not `goimports`-ed (goimports)
	"github.com/pkg/errors"
cmd/wmd/internal/state/aliases_test.go:3: File is not `goimports`-ed (goimports)
import (
cmd/wmd/internal/state/meta_test.go:3: File is not `goimports`-ed (goimports)
import (
cmd/wmd/internal/state/trades_test.go:5: File is not `goimports`-ed (goimports)
	"encoding/binary"
cmd/wmd/internal/state/accounts.go:382:3: `if ok` has complex nested blocks (complexity: 12) (nestif)
		if ok {
		^
cmd/wmd/internal/state/accounts.go:293:2: `if it.Last()` has complex nested blocks (complexity: 10) (nestif)
	if it.Last() {
	^
cmd/wmd/internal/state/aliases.go:93:2: `if it.Last()` has complex nested blocks (complexity: 5) (nestif)
	if it.Last() {
	^
cmd/wmd/internal/state/trades.go:182:2: `if it.Last()` has complex nested blocks (complexity: 5) (nestif)
	if it.Last() {
	^
cmd/wmd/internal/state/trades.go:239:2: `if it.Last()` has complex nested blocks (complexity: 5) (nestif)
	if it.Last() {
	^
cmd/wmd/internal/state/trades.go:315:2: `if it.Last()` has complex nested blocks (complexity: 5) (nestif)
	if it.Last() {
	^
cmd/wmd/internal/state/meta.go:15:73: putBlock - result 0 (error) is always nil (unparam)
func putBlock(batch *leveldb.Batch, height uint32, block proto.BlockID) error {
                                                                        ^
pkg/miner/scheduler/scheduler.go:403:11: Error return value is not checked (errcheck)
	emits := rs.([]Emit)
	         ^
pkg/miner/scheduler/scheduler_test.go:23:31: unnecessary conversion (unconvert)
	require.EqualValues(t, []Emit([]Emit(nil)), rs)
	                             ^
pkg/ride/crypto/rsa.go:72:2: naked return in func `leftPad` with 8 lines of code (nakedret)
	return
	^
pkg/ride/crypto/rsa.go:89:2: naked return in func `pkcs1v15HashInfo` with 15 lines of code (nakedret)
	return
	^
cmd/statehash/statehash.go:69:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf("Waves RIDE Appraiser %s\n", version)
		^
cmd/statehash/statehash.go:163:2: `if compare` has complex nested blocks (complexity: 13) (nestif)
	if compare {
	^
cmd/statehash/statehash.go:116:2: `if compare` has complex nested blocks (complexity: 6) (nestif)
	if compare {
	^
pkg/crypto/internal/groth16/bls12_381/verifying_key.go:55:2: naked return in func `ReadFrom` with 34 lines of code (nakedret)
	return
	^
cmd/rollback/main.go:1:1: the average complexity for the package main is 12.000000, max is 10.000000 (cyclop)
package main
^
pkg/libs/channel/channel.go:42:6: ST1017: don't use Yoda conditions (stylecheck)
		if 1 == atomic.LoadUint32(&a.closed) {
		   ^
pkg/libs/channel/channel.go:69:6: ST1017: don't use Yoda conditions (stylecheck)
		if 1 == atomic.LoadUint32(&a.closed) {
		   ^
pkg/ride/math/math_test.go:29:4: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Println(err)
			^
pkg/ride/math/math.go:101:2: `if s > scale` has complex nested blocks (complexity: 5) (nestif)
	if s > scale {
	^
pkg/miner/utxpool/pool.go:30:10: Error return value is not checked (errcheck)
	item := x.(*types.TransactionWithBytes)
	        ^
pkg/miner/utxpool/pool.go:171:9: Error return value is not checked (errcheck)
		tb := heap.Pop(&a.transactions).(*types.TransactionWithBytes)
		      ^
pkg/miner/utxpool/transaction_bulk_validator.go:39:67: (bulkValidator).validate - result 1 (error) is always nil (unparam)
func (a bulkValidator) validate() ([]*types.TransactionWithBytes, error) {
                                                                  ^
pkg/ride/generate/internal/functions_generation.go:12: 12-81 lines are duplicate of `pkg/ride/generate/internal/functions_generation.go:83-152` (dupl)
func functionsV2() map[string]string {
	m := make(map[string]string)
	m["0"] = "eq"
	m["1"] = "instanceOf"
	m["2"] = "throw"
	m["100"] = "sum"
	m["101"] = "sub"
	m["102"] = "gt"
	m["103"] = "ge"
	m["104"] = "mul"
	m["105"] = "div"
	m["106"] = "mod"
	m["107"] = "fraction"
	m["200"] = "sizeBytes"
	m["201"] = "takeBytes"
	m["202"] = "dropBytes"
	m["203"] = "concatBytes"
	m["300"] = "concatStrings"
	m["303"] = "takeString"
	m["304"] = "dropString"
	m["305"] = "sizeString"
	m["400"] = "sizeList"
	m["401"] = "getList"
	m["410"] = "intToBytes"
	m["411"] = "stringToBytes"
	m["412"] = "booleanToBytes"
	m["420"] = "intToString"
	m["421"] = "booleanToString"
	m["500"] = "sigVerify"
	m["501"] = "keccak256"
	m["502"] = "blake2b256"
	m["503"] = "sha256"
	m["600"] = "toBase58"
	m["601"] = "fromBase58"
	m["602"] = "toBase64"
	m["603"] = "fromBase64"
	m["1000"] = "transactionByID"
	m["1001"] = "transactionHeightByID"
	m["1003"] = "assetBalanceV3"
	m["1040"] = "intFromArray"
	m["1041"] = "booleanFromArray"
	m["1042"] = "bytesFromArray"
	m["1043"] = "stringFromArray"
	m["1050"] = "intFromState"
	m["1051"] = "booleanFromState"
	m["1052"] = "bytesFromState"
	m["1053"] = "stringFromState"
	m["1060"] = "addressFromRecipient"
	m["throw"] = "throw0"
	m["addressFromString"] = "addressFromString"
	m["!="] = "neq"
	m["isDefined"] = "isDefined"
	m["extract"] = "extract"
	m["dropRightBytes"] = "dropRightBytes"
	m["takeRightBytes"] = "takeRightBytes"
	m["takeRight"] = "takeRightString"
	m["dropRight"] = "dropRightString"
	m["!"] = "unaryNot"
	m["-"] = "unaryMinus"
	m["getInteger"] = "intFromArrayByIndex"
	m["getBoolean"] = "booleanFromArrayByIndex"
	m["getBinary"] = "bytesFromArrayByIndex"
	m["getString"] = "stringFromArrayByIndex"
	m["addressFromPublicKey"] = "addressFromPublicKey"
	m["wavesBalance"] = "wavesBalanceV3"
	m["Address"] = "address"
	m["Alias"] = "alias"
	constructorsFunctions(ast.LibV2, m)
	return m
}
pkg/ride/generate/internal/functions_generation.go:83: 83-152 lines are duplicate of `pkg/ride/generate/internal/functions_generation.go:12-81` (dupl)
func catalogueV2() map[string]int {
	m := make(map[string]int)
	m["0"] = 1
	m["1"] = 1
	m["2"] = 1
	m["100"] = 1
	m["101"] = 1
	m["102"] = 1
	m["103"] = 1
	m["104"] = 1
	m["105"] = 1
	m["106"] = 1
	m["107"] = 1
	m["200"] = 1
	m["201"] = 1
	m["202"] = 1
	m["203"] = 10
	m["300"] = 10
	m["303"] = 1
	m["304"] = 1
	m["305"] = 1
	m["400"] = 2
	m["401"] = 2
	m["410"] = 1
	m["411"] = 1
	m["412"] = 1
	m["420"] = 1
	m["421"] = 1
	m["500"] = 100
	m["501"] = 10
	m["502"] = 10
	m["503"] = 10
	m["600"] = 10
	m["601"] = 10
	m["602"] = 10
	m["603"] = 10
	m["1000"] = 100
	m["1001"] = 100
	m["1003"] = 100
	m["1040"] = 10
	m["1041"] = 10
	m["1042"] = 10
	m["1043"] = 10
	m["1050"] = 100
	m["1051"] = 100
	m["1052"] = 100
	m["1053"] = 100
	m["1060"] = 100
	m["throw"] = 2
	m["addressFromString"] = 124
	m["!="] = 26
	m["isDefined"] = 35
	m["extract"] = 13
	m["dropRightBytes"] = 19
	m["takeRightBytes"] = 19
	m["takeRight"] = 19
	m["dropRight"] = 19
	m["!"] = 11
	m["-"] = 9
	m["getInteger"] = 30
	m["getBoolean"] = 30
	m["getBinary"] = 30
	m["getString"] = 30
	m["addressFromPublicKey"] = 82
	m["wavesBalance"] = 109
	m["Address"] = 1
	m["Alias"] = 1
	constructorsCatalogue(ast.LibV2, m)
	return m
}
pkg/ride/generate/internal/function_families_generation.go:16: 16-44 lines are duplicate of `pkg/ride/generate/internal/function_families_generation.go:45-73` (dupl)
	for _, l := range []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15} {
		fn := fmt.Sprintf("bls12Groth16Verify_%d", l)
		cd.Line("func %s(env environment, args ...rideType) (rideType, error) {", fn)
		cd.Line("if err := checkArgs(args, 3); err != nil {")
		cd.Line("return nil, errors.Wrap(err, \"%s\")", fn)
		cd.Line("}")
		cd.Line("key, ok := args[0].(rideByteVector)")
		cd.Line("if !ok {")
		cd.Line("return nil, errors.Errorf(\"%s: unexpected argument type '%%s'\", args[0].instanceOf())", fn)
		cd.Line("}")
		cd.Line("proof, ok := args[1].(rideByteVector)")
		cd.Line("if !ok {")
		cd.Line("return nil, errors.Errorf(\"%s: unexpected argument type '%%s'\", args[1].instanceOf())", fn)
		cd.Line("}")
		cd.Line("inputs, ok := args[2].(rideByteVector)")
		cd.Line("if !ok {")
		cd.Line("return nil, errors.Errorf(\"%s: unexpected argument type '%%s'\", args[2].instanceOf())", fn)
		cd.Line("}")
		cd.Line("if l := len(inputs); l > 32*%d {", l)
		cd.Line("return nil, errors.Errorf(\"%s: invalid inputs size %%d\", l)", fn)
		cd.Line("}")
		cd.Line("ok, err := crypto.Groth16Verify(key, proof, inputs, ecc.BLS12_381)")
		cd.Line("if err != nil {")
		cd.Line("return nil, errors.Wrap(err, \"%s\")", fn)
		cd.Line("}")
		cd.Line("return rideBoolean(ok), nil")
		cd.Line("}")
		cd.Line("")
	}
pkg/ride/generate/internal/function_families_generation.go:45: 45-73 lines are duplicate of `pkg/ride/generate/internal/function_families_generation.go:16-44` (dupl)
	for _, l := range []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15} {
		fn := fmt.Sprintf("bn256Groth16Verify_%d", l)
		cd.Line("func %s(env environment, args ...rideType) (rideType, error) {", fn)
		cd.Line("if err := checkArgs(args, 3); err != nil {")
		cd.Line("return nil, errors.Wrap(err, \"%s\")", fn)
		cd.Line("}")
		cd.Line("key, ok := args[0].(rideByteVector)")
		cd.Line("if !ok {")
		cd.Line("return nil, errors.Errorf(\"%s: unexpected argument type '%%s'\", args[0].instanceOf())", fn)
		cd.Line("}")
		cd.Line("proof, ok := args[1].(rideByteVector)")
		cd.Line("if !ok {")
		cd.Line("return nil, errors.Errorf(\"%s: unexpected argument type '%%s'\", args[1].instanceOf())", fn)
		cd.Line("}")
		cd.Line("inputs, ok := args[2].(rideByteVector)")
		cd.Line("if !ok {")
		cd.Line("return nil, errors.Errorf(\"%s: unexpected argument type '%%s'\", args[2].instanceOf())", fn)
		cd.Line("}")
		cd.Line("if l := len(inputs); l > 32*%d {", l)
		cd.Line("return nil, errors.Errorf(\"%s: invalid inputs size %%d\", l)", fn)
		cd.Line("}")
		cd.Line("ok, err := crypto.Groth16Verify(key, proof, inputs, ecc.BN254)")
		cd.Line("if err != nil {")
		cd.Line("return nil, errors.Wrap(err, \"%s\")", fn)
		cd.Line("}")
		cd.Line("return rideBoolean(ok), nil")
		cd.Line("}")
		cd.Line("")
	}
pkg/ride/generate/internal/coder.go:52:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println("====== Generated code ======")
		^
pkg/ride/generate/internal/coder.go:53:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println(code)
		^
pkg/ride/generate/internal/constructors_generation.go:124:24: processVerInfos - result 0 (error) is always nil (unparam)
func processVerInfos() error {
                       ^
pkg/p2p/conn/conn.go:83:4: naked return in func `Read` with 16 lines of code (nakedret)
			return
			^
pkg/util/collect_writes/collect_test.go:5: File is not `goimports`-ed (goimports)
	"github.com/stretchr/testify/assert"
pkg/ride/compiler/stdlib/funcs.go:147:8: Error return value is not checked (errcheck)
		l := args[0].(ListType)
		     ^
pkg/ride/compiler/stdlib/funcs.go:152:8: Error return value is not checked (errcheck)
		l := args[1].(ListType)
		     ^
pkg/ride/compiler/stdlib/types.go:302:14: Error return value is not checked (errcheck)
					list := t.Types[listIndex].(ListType)
					        ^
pkg/ride/compiler/stdlib/types.go:336:11: Error return value is not checked (errcheck)
		list := t.Types[listIndex].(ListType)
		        ^
pkg/ride/compiler/stdlib/types.go:421:7: Error return value is not checked (errcheck)
	o := rideType.(ListType)
	     ^
cmd/blockcmp/blockcmp.go:254:73: directive `// nolint` should be written without leading space as `//nolint` (nolintlint)
		stream, err := api.GetStateChanges(ctx, request, g.EmptyCallOption{}) // nolint
		                                                                      ^
