// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package state

import (
	"github.com/wavesplatform/gowaves/pkg/crypto"
	"github.com/wavesplatform/gowaves/pkg/proto"
	"github.com/wavesplatform/gowaves/pkg/ride"
	"sync"
)

// Ensure, that MockScriptStorageState does implement ScriptStorageState.
// If this is not the case, regenerate this file with moq.
var _ ScriptStorageState = &MockScriptStorageState{}

// MockScriptStorageState is a mock implementation of ScriptStorageState.
//
// 	func TestSomethingThatUsesScriptStorageState(t *testing.T) {
//
// 		// make and configure a mocked ScriptStorageState
// 		mockedScriptStorageState := &MockScriptStorageState{
// 			AccountScriptsHasherFunc: func() *stateHasher {
// 				panic("mock out the AccountScriptsHasher method")
// 			},
// 			AssetScriptsHasherFunc: func() *stateHasher {
// 				panic("mock out the AssetScriptsHasher method")
// 			},
// 			NewestScriptPKByAddrFunc: func(addr proto.WavesAddress, filter bool) (crypto.PublicKey, error) {
// 				panic("mock out the NewestScriptPKByAddr method")
// 			},
// 			accountHasScriptFunc: func(addr proto.WavesAddress, filter bool) (bool, error) {
// 				panic("mock out the accountHasScript method")
// 			},
// 			accountHasVerifierFunc: func(addr proto.WavesAddress, filter bool) (bool, error) {
// 				panic("mock out the accountHasVerifier method")
// 			},
// 			clearFunc: func() error {
// 				panic("mock out the clear method")
// 			},
// 			commitUncertainFunc: func(blockID proto.BlockID) error {
// 				panic("mock out the commitUncertain method")
// 			},
// 			dropUncertainFunc: func()  {
// 				panic("mock out the dropUncertain method")
// 			},
// 			isSmartAssetFunc: func(assetID proto.AssetID, filter bool) (bool, error) {
// 				panic("mock out the isSmartAsset method")
// 			},
// 			newestAccountHasScriptFunc: func(addr proto.WavesAddress, filter bool) (bool, error) {
// 				panic("mock out the newestAccountHasScript method")
// 			},
// 			newestAccountHasVerifierFunc: func(addr proto.WavesAddress, filter bool) (bool, error) {
// 				panic("mock out the newestAccountHasVerifier method")
// 			},
// 			newestIsSmartAssetFunc: func(assetID proto.AssetID, filter bool) (bool, error) {
// 				panic("mock out the newestIsSmartAsset method")
// 			},
// 			newestScriptAstByKeyFunc: func(key []byte, filter bool) (*ride.Tree, error) {
// 				panic("mock out the newestScriptAstByKey method")
// 			},
// 			newestScriptByAddrFunc: func(addr proto.WavesAddress, filter bool) (*ride.Tree, error) {
// 				panic("mock out the newestScriptByAddr method")
// 			},
// 			newestScriptByAssetFunc: func(assetID proto.AssetID, filter bool) (*ride.Tree, error) {
// 				panic("mock out the newestScriptByAsset method")
// 			},
// 			newestScriptBytesByAssetFunc: func(assetID proto.AssetID, filter bool) (proto.Script, error) {
// 				panic("mock out the newestScriptBytesByAsset method")
// 			},
// 			newestScriptBytesByKeyFunc: func(key []byte, filter bool) (proto.Script, error) {
// 				panic("mock out the newestScriptBytesByKey method")
// 			},
// 			prepareHashesFunc: func() error {
// 				panic("mock out the prepareHashes method")
// 			},
// 			resetFunc: func()  {
// 				panic("mock out the reset method")
// 			},
// 			scriptAstFromRecordBytesFunc: func(script proto.Script) (*ride.Tree, error) {
// 				panic("mock out the scriptAstFromRecordBytes method")
// 			},
// 			scriptByAddrFunc: func(addr proto.WavesAddress, filter bool) (*ride.Tree, error) {
// 				panic("mock out the scriptByAddr method")
// 			},
// 			scriptByAssetFunc: func(assetID proto.AssetID, filter bool) (*ride.Tree, error) {
// 				panic("mock out the scriptByAsset method")
// 			},
// 			scriptBytesByAddrFunc: func(addr proto.WavesAddress, filter bool) (proto.Script, error) {
// 				panic("mock out the scriptBytesByAddr method")
// 			},
// 			scriptBytesByAssetFunc: func(assetID proto.AssetID, filter bool) (proto.Script, error) {
// 				panic("mock out the scriptBytesByAsset method")
// 			},
// 			scriptBytesByKeyFunc: func(key []byte, filter bool) (proto.Script, error) {
// 				panic("mock out the scriptBytesByKey method")
// 			},
// 			scriptTreeByKeyFunc: func(key []byte, filter bool) (*ride.Tree, error) {
// 				panic("mock out the scriptTreeByKey method")
// 			},
// 			setAccountScriptFunc: func(addr proto.WavesAddress, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
// 				panic("mock out the setAccountScript method")
// 			},
// 			setAssetScriptFunc: func(assetID crypto.Digest, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
// 				panic("mock out the setAssetScript method")
// 			},
// 			setAssetScriptUncertainFunc: func(fullAssetID crypto.Digest, script proto.Script, pk crypto.PublicKey)  {
// 				panic("mock out the setAssetScriptUncertain method")
// 			},
// 			setScriptFunc: func(scriptType blockchainEntity, key scriptKey, dbItem scriptDBItem, blockID proto.BlockID) error {
// 				panic("mock out the setScript method")
// 			},
// 		}
//
// 		// use mockedScriptStorageState in code that requires ScriptStorageState
// 		// and then make assertions.
//
// 	}
type MockScriptStorageState struct {
	// AccountScriptsHasherFunc mocks the AccountScriptsHasher method.
	AccountScriptsHasherFunc func() *stateHasher

	// AssetScriptsHasherFunc mocks the AssetScriptsHasher method.
	AssetScriptsHasherFunc func() *stateHasher

	// NewestScriptPKByAddrFunc mocks the NewestScriptPKByAddr method.
	NewestScriptPKByAddrFunc func(addr proto.WavesAddress, filter bool) (crypto.PublicKey, error)

	// accountHasScriptFunc mocks the accountHasScript method.
	accountHasScriptFunc func(addr proto.WavesAddress, filter bool) (bool, error)

	// accountHasVerifierFunc mocks the accountHasVerifier method.
	accountHasVerifierFunc func(addr proto.WavesAddress, filter bool) (bool, error)

	// clearFunc mocks the clear method.
	clearFunc func() error

	// commitUncertainFunc mocks the commitUncertain method.
	commitUncertainFunc func(blockID proto.BlockID) error

	// dropUncertainFunc mocks the dropUncertain method.
	dropUncertainFunc func()

	// isSmartAssetFunc mocks the isSmartAsset method.
	isSmartAssetFunc func(assetID proto.AssetID, filter bool) (bool, error)

	// newestAccountHasScriptFunc mocks the newestAccountHasScript method.
	newestAccountHasScriptFunc func(addr proto.WavesAddress, filter bool) (bool, error)

	// newestAccountHasVerifierFunc mocks the newestAccountHasVerifier method.
	newestAccountHasVerifierFunc func(addr proto.WavesAddress, filter bool) (bool, error)

	// newestIsSmartAssetFunc mocks the newestIsSmartAsset method.
	newestIsSmartAssetFunc func(assetID proto.AssetID, filter bool) (bool, error)

	// newestScriptAstByKeyFunc mocks the newestScriptAstByKey method.
	newestScriptAstByKeyFunc func(key []byte, filter bool) (*ride.Tree, error)

	// newestScriptByAddrFunc mocks the newestScriptByAddr method.
	newestScriptByAddrFunc func(addr proto.WavesAddress, filter bool) (*ride.Tree, error)

	// newestScriptByAssetFunc mocks the newestScriptByAsset method.
	newestScriptByAssetFunc func(assetID proto.AssetID, filter bool) (*ride.Tree, error)

	// newestScriptBytesByAssetFunc mocks the newestScriptBytesByAsset method.
	newestScriptBytesByAssetFunc func(assetID proto.AssetID, filter bool) (proto.Script, error)

	// newestScriptBytesByKeyFunc mocks the newestScriptBytesByKey method.
	newestScriptBytesByKeyFunc func(key []byte, filter bool) (proto.Script, error)

	// prepareHashesFunc mocks the prepareHashes method.
	prepareHashesFunc func() error

	// resetFunc mocks the reset method.
	resetFunc func()

	// scriptAstFromRecordBytesFunc mocks the scriptAstFromRecordBytes method.
	scriptAstFromRecordBytesFunc func(script proto.Script) (*ride.Tree, error)

	// scriptByAddrFunc mocks the scriptByAddr method.
	scriptByAddrFunc func(addr proto.WavesAddress, filter bool) (*ride.Tree, error)

	// scriptByAssetFunc mocks the scriptByAsset method.
	scriptByAssetFunc func(assetID proto.AssetID, filter bool) (*ride.Tree, error)

	// scriptBytesByAddrFunc mocks the scriptBytesByAddr method.
	scriptBytesByAddrFunc func(addr proto.WavesAddress, filter bool) (proto.Script, error)

	// scriptBytesByAssetFunc mocks the scriptBytesByAsset method.
	scriptBytesByAssetFunc func(assetID proto.AssetID, filter bool) (proto.Script, error)

	// scriptBytesByKeyFunc mocks the scriptBytesByKey method.
	scriptBytesByKeyFunc func(key []byte, filter bool) (proto.Script, error)

	// scriptTreeByKeyFunc mocks the scriptTreeByKey method.
	scriptTreeByKeyFunc func(key []byte, filter bool) (*ride.Tree, error)

	// setAccountScriptFunc mocks the setAccountScript method.
	setAccountScriptFunc func(addr proto.WavesAddress, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error

	// setAssetScriptFunc mocks the setAssetScript method.
	setAssetScriptFunc func(assetID crypto.Digest, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error

	// setAssetScriptUncertainFunc mocks the setAssetScriptUncertain method.
	setAssetScriptUncertainFunc func(fullAssetID crypto.Digest, script proto.Script, pk crypto.PublicKey)

	// setScriptFunc mocks the setScript method.
	setScriptFunc func(scriptType blockchainEntity, key scriptKey, dbItem scriptDBItem, blockID proto.BlockID) error

	// calls tracks calls to the methods.
	calls struct {
		// AccountScriptsHasher holds details about calls to the AccountScriptsHasher method.
		AccountScriptsHasher []struct {
		}
		// AssetScriptsHasher holds details about calls to the AssetScriptsHasher method.
		AssetScriptsHasher []struct {
		}
		// NewestScriptPKByAddr holds details about calls to the NewestScriptPKByAddr method.
		NewestScriptPKByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// accountHasScript holds details about calls to the accountHasScript method.
		accountHasScript []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// accountHasVerifier holds details about calls to the accountHasVerifier method.
		accountHasVerifier []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// clear holds details about calls to the clear method.
		clear []struct {
		}
		// commitUncertain holds details about calls to the commitUncertain method.
		commitUncertain []struct {
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// dropUncertain holds details about calls to the dropUncertain method.
		dropUncertain []struct {
		}
		// isSmartAsset holds details about calls to the isSmartAsset method.
		isSmartAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
			// Filter is the filter argument value.
			Filter bool
		}
		// newestAccountHasScript holds details about calls to the newestAccountHasScript method.
		newestAccountHasScript []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// newestAccountHasVerifier holds details about calls to the newestAccountHasVerifier method.
		newestAccountHasVerifier []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// newestIsSmartAsset holds details about calls to the newestIsSmartAsset method.
		newestIsSmartAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
			// Filter is the filter argument value.
			Filter bool
		}
		// newestScriptAstByKey holds details about calls to the newestScriptAstByKey method.
		newestScriptAstByKey []struct {
			// Key is the key argument value.
			Key []byte
			// Filter is the filter argument value.
			Filter bool
		}
		// newestScriptByAddr holds details about calls to the newestScriptByAddr method.
		newestScriptByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// newestScriptByAsset holds details about calls to the newestScriptByAsset method.
		newestScriptByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
			// Filter is the filter argument value.
			Filter bool
		}
		// newestScriptBytesByAsset holds details about calls to the newestScriptBytesByAsset method.
		newestScriptBytesByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
			// Filter is the filter argument value.
			Filter bool
		}
		// newestScriptBytesByKey holds details about calls to the newestScriptBytesByKey method.
		newestScriptBytesByKey []struct {
			// Key is the key argument value.
			Key []byte
			// Filter is the filter argument value.
			Filter bool
		}
		// prepareHashes holds details about calls to the prepareHashes method.
		prepareHashes []struct {
		}
		// reset holds details about calls to the reset method.
		reset []struct {
		}
		// scriptAstFromRecordBytes holds details about calls to the scriptAstFromRecordBytes method.
		scriptAstFromRecordBytes []struct {
			// Script is the script argument value.
			Script proto.Script
		}
		// scriptByAddr holds details about calls to the scriptByAddr method.
		scriptByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// scriptByAsset holds details about calls to the scriptByAsset method.
		scriptByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
			// Filter is the filter argument value.
			Filter bool
		}
		// scriptBytesByAddr holds details about calls to the scriptBytesByAddr method.
		scriptBytesByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Filter is the filter argument value.
			Filter bool
		}
		// scriptBytesByAsset holds details about calls to the scriptBytesByAsset method.
		scriptBytesByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
			// Filter is the filter argument value.
			Filter bool
		}
		// scriptBytesByKey holds details about calls to the scriptBytesByKey method.
		scriptBytesByKey []struct {
			// Key is the key argument value.
			Key []byte
			// Filter is the filter argument value.
			Filter bool
		}
		// scriptTreeByKey holds details about calls to the scriptTreeByKey method.
		scriptTreeByKey []struct {
			// Key is the key argument value.
			Key []byte
			// Filter is the filter argument value.
			Filter bool
		}
		// setAccountScript holds details about calls to the setAccountScript method.
		setAccountScript []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Script is the script argument value.
			Script proto.Script
			// Pk is the pk argument value.
			Pk crypto.PublicKey
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// setAssetScript holds details about calls to the setAssetScript method.
		setAssetScript []struct {
			// AssetID is the assetID argument value.
			AssetID crypto.Digest
			// Script is the script argument value.
			Script proto.Script
			// Pk is the pk argument value.
			Pk crypto.PublicKey
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// setAssetScriptUncertain holds details about calls to the setAssetScriptUncertain method.
		setAssetScriptUncertain []struct {
			// FullAssetID is the fullAssetID argument value.
			FullAssetID crypto.Digest
			// Script is the script argument value.
			Script proto.Script
			// Pk is the pk argument value.
			Pk crypto.PublicKey
		}
		// setScript holds details about calls to the setScript method.
		setScript []struct {
			// ScriptType is the scriptType argument value.
			ScriptType blockchainEntity
			// Key is the key argument value.
			Key scriptKey
			// DbItem is the dbItem argument value.
			DbItem scriptDBItem
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
	}
	lockAccountScriptsHasher     sync.RWMutex
	lockAssetScriptsHasher       sync.RWMutex
	lockNewestScriptPKByAddr     sync.RWMutex
	lockaccountHasScript         sync.RWMutex
	lockaccountHasVerifier       sync.RWMutex
	lockclear                    sync.RWMutex
	lockcommitUncertain          sync.RWMutex
	lockdropUncertain            sync.RWMutex
	lockisSmartAsset             sync.RWMutex
	locknewestAccountHasScript   sync.RWMutex
	locknewestAccountHasVerifier sync.RWMutex
	locknewestIsSmartAsset       sync.RWMutex
	locknewestScriptAstByKey     sync.RWMutex
	locknewestScriptByAddr       sync.RWMutex
	locknewestScriptByAsset      sync.RWMutex
	locknewestScriptBytesByAsset sync.RWMutex
	locknewestScriptBytesByKey   sync.RWMutex
	lockprepareHashes            sync.RWMutex
	lockreset                    sync.RWMutex
	lockscriptAstFromRecordBytes sync.RWMutex
	lockscriptByAddr             sync.RWMutex
	lockscriptByAsset            sync.RWMutex
	lockscriptBytesByAddr        sync.RWMutex
	lockscriptBytesByAsset       sync.RWMutex
	lockscriptBytesByKey         sync.RWMutex
	lockscriptTreeByKey          sync.RWMutex
	locksetAccountScript         sync.RWMutex
	locksetAssetScript           sync.RWMutex
	locksetAssetScriptUncertain  sync.RWMutex
	locksetScript                sync.RWMutex
}

// AccountScriptsHasher calls AccountScriptsHasherFunc.
func (mock *MockScriptStorageState) AccountScriptsHasher() *stateHasher {
	if mock.AccountScriptsHasherFunc == nil {
		panic("MockScriptStorageState.AccountScriptsHasherFunc: method is nil but ScriptStorageState.AccountScriptsHasher was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAccountScriptsHasher.Lock()
	mock.calls.AccountScriptsHasher = append(mock.calls.AccountScriptsHasher, callInfo)
	mock.lockAccountScriptsHasher.Unlock()
	return mock.AccountScriptsHasherFunc()
}

// AccountScriptsHasherCalls gets all the calls that were made to AccountScriptsHasher.
// Check the length with:
//     len(mockedScriptStorageState.AccountScriptsHasherCalls())
func (mock *MockScriptStorageState) AccountScriptsHasherCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAccountScriptsHasher.RLock()
	calls = mock.calls.AccountScriptsHasher
	mock.lockAccountScriptsHasher.RUnlock()
	return calls
}

// AssetScriptsHasher calls AssetScriptsHasherFunc.
func (mock *MockScriptStorageState) AssetScriptsHasher() *stateHasher {
	if mock.AssetScriptsHasherFunc == nil {
		panic("MockScriptStorageState.AssetScriptsHasherFunc: method is nil but ScriptStorageState.AssetScriptsHasher was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAssetScriptsHasher.Lock()
	mock.calls.AssetScriptsHasher = append(mock.calls.AssetScriptsHasher, callInfo)
	mock.lockAssetScriptsHasher.Unlock()
	return mock.AssetScriptsHasherFunc()
}

// AssetScriptsHasherCalls gets all the calls that were made to AssetScriptsHasher.
// Check the length with:
//     len(mockedScriptStorageState.AssetScriptsHasherCalls())
func (mock *MockScriptStorageState) AssetScriptsHasherCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAssetScriptsHasher.RLock()
	calls = mock.calls.AssetScriptsHasher
	mock.lockAssetScriptsHasher.RUnlock()
	return calls
}

// NewestScriptPKByAddr calls NewestScriptPKByAddrFunc.
func (mock *MockScriptStorageState) NewestScriptPKByAddr(addr proto.WavesAddress, filter bool) (crypto.PublicKey, error) {
	if mock.NewestScriptPKByAddrFunc == nil {
		panic("MockScriptStorageState.NewestScriptPKByAddrFunc: method is nil but ScriptStorageState.NewestScriptPKByAddr was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.lockNewestScriptPKByAddr.Lock()
	mock.calls.NewestScriptPKByAddr = append(mock.calls.NewestScriptPKByAddr, callInfo)
	mock.lockNewestScriptPKByAddr.Unlock()
	return mock.NewestScriptPKByAddrFunc(addr, filter)
}

// NewestScriptPKByAddrCalls gets all the calls that were made to NewestScriptPKByAddr.
// Check the length with:
//     len(mockedScriptStorageState.NewestScriptPKByAddrCalls())
func (mock *MockScriptStorageState) NewestScriptPKByAddrCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.lockNewestScriptPKByAddr.RLock()
	calls = mock.calls.NewestScriptPKByAddr
	mock.lockNewestScriptPKByAddr.RUnlock()
	return calls
}

// accountHasScript calls accountHasScriptFunc.
func (mock *MockScriptStorageState) accountHasScript(addr proto.WavesAddress, filter bool) (bool, error) {
	if mock.accountHasScriptFunc == nil {
		panic("MockScriptStorageState.accountHasScriptFunc: method is nil but ScriptStorageState.accountHasScript was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.lockaccountHasScript.Lock()
	mock.calls.accountHasScript = append(mock.calls.accountHasScript, callInfo)
	mock.lockaccountHasScript.Unlock()
	return mock.accountHasScriptFunc(addr, filter)
}

// accountHasScriptCalls gets all the calls that were made to accountHasScript.
// Check the length with:
//     len(mockedScriptStorageState.accountHasScriptCalls())
func (mock *MockScriptStorageState) accountHasScriptCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.lockaccountHasScript.RLock()
	calls = mock.calls.accountHasScript
	mock.lockaccountHasScript.RUnlock()
	return calls
}

// accountHasVerifier calls accountHasVerifierFunc.
func (mock *MockScriptStorageState) accountHasVerifier(addr proto.WavesAddress, filter bool) (bool, error) {
	if mock.accountHasVerifierFunc == nil {
		panic("MockScriptStorageState.accountHasVerifierFunc: method is nil but ScriptStorageState.accountHasVerifier was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.lockaccountHasVerifier.Lock()
	mock.calls.accountHasVerifier = append(mock.calls.accountHasVerifier, callInfo)
	mock.lockaccountHasVerifier.Unlock()
	return mock.accountHasVerifierFunc(addr, filter)
}

// accountHasVerifierCalls gets all the calls that were made to accountHasVerifier.
// Check the length with:
//     len(mockedScriptStorageState.accountHasVerifierCalls())
func (mock *MockScriptStorageState) accountHasVerifierCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.lockaccountHasVerifier.RLock()
	calls = mock.calls.accountHasVerifier
	mock.lockaccountHasVerifier.RUnlock()
	return calls
}

// clear calls clearFunc.
func (mock *MockScriptStorageState) clear() error {
	if mock.clearFunc == nil {
		panic("MockScriptStorageState.clearFunc: method is nil but ScriptStorageState.clear was just called")
	}
	callInfo := struct {
	}{}
	mock.lockclear.Lock()
	mock.calls.clear = append(mock.calls.clear, callInfo)
	mock.lockclear.Unlock()
	return mock.clearFunc()
}

// clearCalls gets all the calls that were made to clear.
// Check the length with:
//     len(mockedScriptStorageState.clearCalls())
func (mock *MockScriptStorageState) clearCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockclear.RLock()
	calls = mock.calls.clear
	mock.lockclear.RUnlock()
	return calls
}

// commitUncertain calls commitUncertainFunc.
func (mock *MockScriptStorageState) commitUncertain(blockID proto.BlockID) error {
	if mock.commitUncertainFunc == nil {
		panic("MockScriptStorageState.commitUncertainFunc: method is nil but ScriptStorageState.commitUncertain was just called")
	}
	callInfo := struct {
		BlockID proto.BlockID
	}{
		BlockID: blockID,
	}
	mock.lockcommitUncertain.Lock()
	mock.calls.commitUncertain = append(mock.calls.commitUncertain, callInfo)
	mock.lockcommitUncertain.Unlock()
	return mock.commitUncertainFunc(blockID)
}

// commitUncertainCalls gets all the calls that were made to commitUncertain.
// Check the length with:
//     len(mockedScriptStorageState.commitUncertainCalls())
func (mock *MockScriptStorageState) commitUncertainCalls() []struct {
	BlockID proto.BlockID
} {
	var calls []struct {
		BlockID proto.BlockID
	}
	mock.lockcommitUncertain.RLock()
	calls = mock.calls.commitUncertain
	mock.lockcommitUncertain.RUnlock()
	return calls
}

// dropUncertain calls dropUncertainFunc.
func (mock *MockScriptStorageState) dropUncertain() {
	if mock.dropUncertainFunc == nil {
		panic("MockScriptStorageState.dropUncertainFunc: method is nil but ScriptStorageState.dropUncertain was just called")
	}
	callInfo := struct {
	}{}
	mock.lockdropUncertain.Lock()
	mock.calls.dropUncertain = append(mock.calls.dropUncertain, callInfo)
	mock.lockdropUncertain.Unlock()
	mock.dropUncertainFunc()
}

// dropUncertainCalls gets all the calls that were made to dropUncertain.
// Check the length with:
//     len(mockedScriptStorageState.dropUncertainCalls())
func (mock *MockScriptStorageState) dropUncertainCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockdropUncertain.RLock()
	calls = mock.calls.dropUncertain
	mock.lockdropUncertain.RUnlock()
	return calls
}

// isSmartAsset calls isSmartAssetFunc.
func (mock *MockScriptStorageState) isSmartAsset(assetID proto.AssetID, filter bool) (bool, error) {
	if mock.isSmartAssetFunc == nil {
		panic("MockScriptStorageState.isSmartAssetFunc: method is nil but ScriptStorageState.isSmartAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
		Filter  bool
	}{
		AssetID: assetID,
		Filter:  filter,
	}
	mock.lockisSmartAsset.Lock()
	mock.calls.isSmartAsset = append(mock.calls.isSmartAsset, callInfo)
	mock.lockisSmartAsset.Unlock()
	return mock.isSmartAssetFunc(assetID, filter)
}

// isSmartAssetCalls gets all the calls that were made to isSmartAsset.
// Check the length with:
//     len(mockedScriptStorageState.isSmartAssetCalls())
func (mock *MockScriptStorageState) isSmartAssetCalls() []struct {
	AssetID proto.AssetID
	Filter  bool
} {
	var calls []struct {
		AssetID proto.AssetID
		Filter  bool
	}
	mock.lockisSmartAsset.RLock()
	calls = mock.calls.isSmartAsset
	mock.lockisSmartAsset.RUnlock()
	return calls
}

// newestAccountHasScript calls newestAccountHasScriptFunc.
func (mock *MockScriptStorageState) newestAccountHasScript(addr proto.WavesAddress, filter bool) (bool, error) {
	if mock.newestAccountHasScriptFunc == nil {
		panic("MockScriptStorageState.newestAccountHasScriptFunc: method is nil but ScriptStorageState.newestAccountHasScript was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.locknewestAccountHasScript.Lock()
	mock.calls.newestAccountHasScript = append(mock.calls.newestAccountHasScript, callInfo)
	mock.locknewestAccountHasScript.Unlock()
	return mock.newestAccountHasScriptFunc(addr, filter)
}

// newestAccountHasScriptCalls gets all the calls that were made to newestAccountHasScript.
// Check the length with:
//     len(mockedScriptStorageState.newestAccountHasScriptCalls())
func (mock *MockScriptStorageState) newestAccountHasScriptCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.locknewestAccountHasScript.RLock()
	calls = mock.calls.newestAccountHasScript
	mock.locknewestAccountHasScript.RUnlock()
	return calls
}

// newestAccountHasVerifier calls newestAccountHasVerifierFunc.
func (mock *MockScriptStorageState) newestAccountHasVerifier(addr proto.WavesAddress, filter bool) (bool, error) {
	if mock.newestAccountHasVerifierFunc == nil {
		panic("MockScriptStorageState.newestAccountHasVerifierFunc: method is nil but ScriptStorageState.newestAccountHasVerifier was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.locknewestAccountHasVerifier.Lock()
	mock.calls.newestAccountHasVerifier = append(mock.calls.newestAccountHasVerifier, callInfo)
	mock.locknewestAccountHasVerifier.Unlock()
	return mock.newestAccountHasVerifierFunc(addr, filter)
}

// newestAccountHasVerifierCalls gets all the calls that were made to newestAccountHasVerifier.
// Check the length with:
//     len(mockedScriptStorageState.newestAccountHasVerifierCalls())
func (mock *MockScriptStorageState) newestAccountHasVerifierCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.locknewestAccountHasVerifier.RLock()
	calls = mock.calls.newestAccountHasVerifier
	mock.locknewestAccountHasVerifier.RUnlock()
	return calls
}

// newestIsSmartAsset calls newestIsSmartAssetFunc.
func (mock *MockScriptStorageState) newestIsSmartAsset(assetID proto.AssetID, filter bool) (bool, error) {
	if mock.newestIsSmartAssetFunc == nil {
		panic("MockScriptStorageState.newestIsSmartAssetFunc: method is nil but ScriptStorageState.newestIsSmartAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
		Filter  bool
	}{
		AssetID: assetID,
		Filter:  filter,
	}
	mock.locknewestIsSmartAsset.Lock()
	mock.calls.newestIsSmartAsset = append(mock.calls.newestIsSmartAsset, callInfo)
	mock.locknewestIsSmartAsset.Unlock()
	return mock.newestIsSmartAssetFunc(assetID, filter)
}

// newestIsSmartAssetCalls gets all the calls that were made to newestIsSmartAsset.
// Check the length with:
//     len(mockedScriptStorageState.newestIsSmartAssetCalls())
func (mock *MockScriptStorageState) newestIsSmartAssetCalls() []struct {
	AssetID proto.AssetID
	Filter  bool
} {
	var calls []struct {
		AssetID proto.AssetID
		Filter  bool
	}
	mock.locknewestIsSmartAsset.RLock()
	calls = mock.calls.newestIsSmartAsset
	mock.locknewestIsSmartAsset.RUnlock()
	return calls
}

// newestScriptAstByKey calls newestScriptAstByKeyFunc.
func (mock *MockScriptStorageState) newestScriptAstByKey(key []byte, filter bool) (*ride.Tree, error) {
	if mock.newestScriptAstByKeyFunc == nil {
		panic("MockScriptStorageState.newestScriptAstByKeyFunc: method is nil but ScriptStorageState.newestScriptAstByKey was just called")
	}
	callInfo := struct {
		Key    []byte
		Filter bool
	}{
		Key:    key,
		Filter: filter,
	}
	mock.locknewestScriptAstByKey.Lock()
	mock.calls.newestScriptAstByKey = append(mock.calls.newestScriptAstByKey, callInfo)
	mock.locknewestScriptAstByKey.Unlock()
	return mock.newestScriptAstByKeyFunc(key, filter)
}

// newestScriptAstByKeyCalls gets all the calls that were made to newestScriptAstByKey.
// Check the length with:
//     len(mockedScriptStorageState.newestScriptAstByKeyCalls())
func (mock *MockScriptStorageState) newestScriptAstByKeyCalls() []struct {
	Key    []byte
	Filter bool
} {
	var calls []struct {
		Key    []byte
		Filter bool
	}
	mock.locknewestScriptAstByKey.RLock()
	calls = mock.calls.newestScriptAstByKey
	mock.locknewestScriptAstByKey.RUnlock()
	return calls
}

// newestScriptByAddr calls newestScriptByAddrFunc.
func (mock *MockScriptStorageState) newestScriptByAddr(addr proto.WavesAddress, filter bool) (*ride.Tree, error) {
	if mock.newestScriptByAddrFunc == nil {
		panic("MockScriptStorageState.newestScriptByAddrFunc: method is nil but ScriptStorageState.newestScriptByAddr was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.locknewestScriptByAddr.Lock()
	mock.calls.newestScriptByAddr = append(mock.calls.newestScriptByAddr, callInfo)
	mock.locknewestScriptByAddr.Unlock()
	return mock.newestScriptByAddrFunc(addr, filter)
}

// newestScriptByAddrCalls gets all the calls that were made to newestScriptByAddr.
// Check the length with:
//     len(mockedScriptStorageState.newestScriptByAddrCalls())
func (mock *MockScriptStorageState) newestScriptByAddrCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.locknewestScriptByAddr.RLock()
	calls = mock.calls.newestScriptByAddr
	mock.locknewestScriptByAddr.RUnlock()
	return calls
}

// newestScriptByAsset calls newestScriptByAssetFunc.
func (mock *MockScriptStorageState) newestScriptByAsset(assetID proto.AssetID, filter bool) (*ride.Tree, error) {
	if mock.newestScriptByAssetFunc == nil {
		panic("MockScriptStorageState.newestScriptByAssetFunc: method is nil but ScriptStorageState.newestScriptByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
		Filter  bool
	}{
		AssetID: assetID,
		Filter:  filter,
	}
	mock.locknewestScriptByAsset.Lock()
	mock.calls.newestScriptByAsset = append(mock.calls.newestScriptByAsset, callInfo)
	mock.locknewestScriptByAsset.Unlock()
	return mock.newestScriptByAssetFunc(assetID, filter)
}

// newestScriptByAssetCalls gets all the calls that were made to newestScriptByAsset.
// Check the length with:
//     len(mockedScriptStorageState.newestScriptByAssetCalls())
func (mock *MockScriptStorageState) newestScriptByAssetCalls() []struct {
	AssetID proto.AssetID
	Filter  bool
} {
	var calls []struct {
		AssetID proto.AssetID
		Filter  bool
	}
	mock.locknewestScriptByAsset.RLock()
	calls = mock.calls.newestScriptByAsset
	mock.locknewestScriptByAsset.RUnlock()
	return calls
}

// newestScriptBytesByAsset calls newestScriptBytesByAssetFunc.
func (mock *MockScriptStorageState) newestScriptBytesByAsset(assetID proto.AssetID, filter bool) (proto.Script, error) {
	if mock.newestScriptBytesByAssetFunc == nil {
		panic("MockScriptStorageState.newestScriptBytesByAssetFunc: method is nil but ScriptStorageState.newestScriptBytesByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
		Filter  bool
	}{
		AssetID: assetID,
		Filter:  filter,
	}
	mock.locknewestScriptBytesByAsset.Lock()
	mock.calls.newestScriptBytesByAsset = append(mock.calls.newestScriptBytesByAsset, callInfo)
	mock.locknewestScriptBytesByAsset.Unlock()
	return mock.newestScriptBytesByAssetFunc(assetID, filter)
}

// newestScriptBytesByAssetCalls gets all the calls that were made to newestScriptBytesByAsset.
// Check the length with:
//     len(mockedScriptStorageState.newestScriptBytesByAssetCalls())
func (mock *MockScriptStorageState) newestScriptBytesByAssetCalls() []struct {
	AssetID proto.AssetID
	Filter  bool
} {
	var calls []struct {
		AssetID proto.AssetID
		Filter  bool
	}
	mock.locknewestScriptBytesByAsset.RLock()
	calls = mock.calls.newestScriptBytesByAsset
	mock.locknewestScriptBytesByAsset.RUnlock()
	return calls
}

// newestScriptBytesByKey calls newestScriptBytesByKeyFunc.
func (mock *MockScriptStorageState) newestScriptBytesByKey(key []byte, filter bool) (proto.Script, error) {
	if mock.newestScriptBytesByKeyFunc == nil {
		panic("MockScriptStorageState.newestScriptBytesByKeyFunc: method is nil but ScriptStorageState.newestScriptBytesByKey was just called")
	}
	callInfo := struct {
		Key    []byte
		Filter bool
	}{
		Key:    key,
		Filter: filter,
	}
	mock.locknewestScriptBytesByKey.Lock()
	mock.calls.newestScriptBytesByKey = append(mock.calls.newestScriptBytesByKey, callInfo)
	mock.locknewestScriptBytesByKey.Unlock()
	return mock.newestScriptBytesByKeyFunc(key, filter)
}

// newestScriptBytesByKeyCalls gets all the calls that were made to newestScriptBytesByKey.
// Check the length with:
//     len(mockedScriptStorageState.newestScriptBytesByKeyCalls())
func (mock *MockScriptStorageState) newestScriptBytesByKeyCalls() []struct {
	Key    []byte
	Filter bool
} {
	var calls []struct {
		Key    []byte
		Filter bool
	}
	mock.locknewestScriptBytesByKey.RLock()
	calls = mock.calls.newestScriptBytesByKey
	mock.locknewestScriptBytesByKey.RUnlock()
	return calls
}

// prepareHashes calls prepareHashesFunc.
func (mock *MockScriptStorageState) prepareHashes() error {
	if mock.prepareHashesFunc == nil {
		panic("MockScriptStorageState.prepareHashesFunc: method is nil but ScriptStorageState.prepareHashes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockprepareHashes.Lock()
	mock.calls.prepareHashes = append(mock.calls.prepareHashes, callInfo)
	mock.lockprepareHashes.Unlock()
	return mock.prepareHashesFunc()
}

// prepareHashesCalls gets all the calls that were made to prepareHashes.
// Check the length with:
//     len(mockedScriptStorageState.prepareHashesCalls())
func (mock *MockScriptStorageState) prepareHashesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockprepareHashes.RLock()
	calls = mock.calls.prepareHashes
	mock.lockprepareHashes.RUnlock()
	return calls
}

// reset calls resetFunc.
func (mock *MockScriptStorageState) reset() {
	if mock.resetFunc == nil {
		panic("MockScriptStorageState.resetFunc: method is nil but ScriptStorageState.reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockreset.Lock()
	mock.calls.reset = append(mock.calls.reset, callInfo)
	mock.lockreset.Unlock()
	mock.resetFunc()
}

// resetCalls gets all the calls that were made to reset.
// Check the length with:
//     len(mockedScriptStorageState.resetCalls())
func (mock *MockScriptStorageState) resetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockreset.RLock()
	calls = mock.calls.reset
	mock.lockreset.RUnlock()
	return calls
}

// scriptAstFromRecordBytes calls scriptAstFromRecordBytesFunc.
func (mock *MockScriptStorageState) scriptAstFromRecordBytes(script proto.Script) (*ride.Tree, error) {
	if mock.scriptAstFromRecordBytesFunc == nil {
		panic("MockScriptStorageState.scriptAstFromRecordBytesFunc: method is nil but ScriptStorageState.scriptAstFromRecordBytes was just called")
	}
	callInfo := struct {
		Script proto.Script
	}{
		Script: script,
	}
	mock.lockscriptAstFromRecordBytes.Lock()
	mock.calls.scriptAstFromRecordBytes = append(mock.calls.scriptAstFromRecordBytes, callInfo)
	mock.lockscriptAstFromRecordBytes.Unlock()
	return mock.scriptAstFromRecordBytesFunc(script)
}

// scriptAstFromRecordBytesCalls gets all the calls that were made to scriptAstFromRecordBytes.
// Check the length with:
//     len(mockedScriptStorageState.scriptAstFromRecordBytesCalls())
func (mock *MockScriptStorageState) scriptAstFromRecordBytesCalls() []struct {
	Script proto.Script
} {
	var calls []struct {
		Script proto.Script
	}
	mock.lockscriptAstFromRecordBytes.RLock()
	calls = mock.calls.scriptAstFromRecordBytes
	mock.lockscriptAstFromRecordBytes.RUnlock()
	return calls
}

// scriptByAddr calls scriptByAddrFunc.
func (mock *MockScriptStorageState) scriptByAddr(addr proto.WavesAddress, filter bool) (*ride.Tree, error) {
	if mock.scriptByAddrFunc == nil {
		panic("MockScriptStorageState.scriptByAddrFunc: method is nil but ScriptStorageState.scriptByAddr was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.lockscriptByAddr.Lock()
	mock.calls.scriptByAddr = append(mock.calls.scriptByAddr, callInfo)
	mock.lockscriptByAddr.Unlock()
	return mock.scriptByAddrFunc(addr, filter)
}

// scriptByAddrCalls gets all the calls that were made to scriptByAddr.
// Check the length with:
//     len(mockedScriptStorageState.scriptByAddrCalls())
func (mock *MockScriptStorageState) scriptByAddrCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.lockscriptByAddr.RLock()
	calls = mock.calls.scriptByAddr
	mock.lockscriptByAddr.RUnlock()
	return calls
}

// scriptByAsset calls scriptByAssetFunc.
func (mock *MockScriptStorageState) scriptByAsset(assetID proto.AssetID, filter bool) (*ride.Tree, error) {
	if mock.scriptByAssetFunc == nil {
		panic("MockScriptStorageState.scriptByAssetFunc: method is nil but ScriptStorageState.scriptByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
		Filter  bool
	}{
		AssetID: assetID,
		Filter:  filter,
	}
	mock.lockscriptByAsset.Lock()
	mock.calls.scriptByAsset = append(mock.calls.scriptByAsset, callInfo)
	mock.lockscriptByAsset.Unlock()
	return mock.scriptByAssetFunc(assetID, filter)
}

// scriptByAssetCalls gets all the calls that were made to scriptByAsset.
// Check the length with:
//     len(mockedScriptStorageState.scriptByAssetCalls())
func (mock *MockScriptStorageState) scriptByAssetCalls() []struct {
	AssetID proto.AssetID
	Filter  bool
} {
	var calls []struct {
		AssetID proto.AssetID
		Filter  bool
	}
	mock.lockscriptByAsset.RLock()
	calls = mock.calls.scriptByAsset
	mock.lockscriptByAsset.RUnlock()
	return calls
}

// scriptBytesByAddr calls scriptBytesByAddrFunc.
func (mock *MockScriptStorageState) scriptBytesByAddr(addr proto.WavesAddress, filter bool) (proto.Script, error) {
	if mock.scriptBytesByAddrFunc == nil {
		panic("MockScriptStorageState.scriptBytesByAddrFunc: method is nil but ScriptStorageState.scriptBytesByAddr was just called")
	}
	callInfo := struct {
		Addr   proto.WavesAddress
		Filter bool
	}{
		Addr:   addr,
		Filter: filter,
	}
	mock.lockscriptBytesByAddr.Lock()
	mock.calls.scriptBytesByAddr = append(mock.calls.scriptBytesByAddr, callInfo)
	mock.lockscriptBytesByAddr.Unlock()
	return mock.scriptBytesByAddrFunc(addr, filter)
}

// scriptBytesByAddrCalls gets all the calls that were made to scriptBytesByAddr.
// Check the length with:
//     len(mockedScriptStorageState.scriptBytesByAddrCalls())
func (mock *MockScriptStorageState) scriptBytesByAddrCalls() []struct {
	Addr   proto.WavesAddress
	Filter bool
} {
	var calls []struct {
		Addr   proto.WavesAddress
		Filter bool
	}
	mock.lockscriptBytesByAddr.RLock()
	calls = mock.calls.scriptBytesByAddr
	mock.lockscriptBytesByAddr.RUnlock()
	return calls
}

// scriptBytesByAsset calls scriptBytesByAssetFunc.
func (mock *MockScriptStorageState) scriptBytesByAsset(assetID proto.AssetID, filter bool) (proto.Script, error) {
	if mock.scriptBytesByAssetFunc == nil {
		panic("MockScriptStorageState.scriptBytesByAssetFunc: method is nil but ScriptStorageState.scriptBytesByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
		Filter  bool
	}{
		AssetID: assetID,
		Filter:  filter,
	}
	mock.lockscriptBytesByAsset.Lock()
	mock.calls.scriptBytesByAsset = append(mock.calls.scriptBytesByAsset, callInfo)
	mock.lockscriptBytesByAsset.Unlock()
	return mock.scriptBytesByAssetFunc(assetID, filter)
}

// scriptBytesByAssetCalls gets all the calls that were made to scriptBytesByAsset.
// Check the length with:
//     len(mockedScriptStorageState.scriptBytesByAssetCalls())
func (mock *MockScriptStorageState) scriptBytesByAssetCalls() []struct {
	AssetID proto.AssetID
	Filter  bool
} {
	var calls []struct {
		AssetID proto.AssetID
		Filter  bool
	}
	mock.lockscriptBytesByAsset.RLock()
	calls = mock.calls.scriptBytesByAsset
	mock.lockscriptBytesByAsset.RUnlock()
	return calls
}

// scriptBytesByKey calls scriptBytesByKeyFunc.
func (mock *MockScriptStorageState) scriptBytesByKey(key []byte, filter bool) (proto.Script, error) {
	if mock.scriptBytesByKeyFunc == nil {
		panic("MockScriptStorageState.scriptBytesByKeyFunc: method is nil but ScriptStorageState.scriptBytesByKey was just called")
	}
	callInfo := struct {
		Key    []byte
		Filter bool
	}{
		Key:    key,
		Filter: filter,
	}
	mock.lockscriptBytesByKey.Lock()
	mock.calls.scriptBytesByKey = append(mock.calls.scriptBytesByKey, callInfo)
	mock.lockscriptBytesByKey.Unlock()
	return mock.scriptBytesByKeyFunc(key, filter)
}

// scriptBytesByKeyCalls gets all the calls that were made to scriptBytesByKey.
// Check the length with:
//     len(mockedScriptStorageState.scriptBytesByKeyCalls())
func (mock *MockScriptStorageState) scriptBytesByKeyCalls() []struct {
	Key    []byte
	Filter bool
} {
	var calls []struct {
		Key    []byte
		Filter bool
	}
	mock.lockscriptBytesByKey.RLock()
	calls = mock.calls.scriptBytesByKey
	mock.lockscriptBytesByKey.RUnlock()
	return calls
}

// scriptTreeByKey calls scriptTreeByKeyFunc.
func (mock *MockScriptStorageState) scriptTreeByKey(key []byte, filter bool) (*ride.Tree, error) {
	if mock.scriptTreeByKeyFunc == nil {
		panic("MockScriptStorageState.scriptTreeByKeyFunc: method is nil but ScriptStorageState.scriptTreeByKey was just called")
	}
	callInfo := struct {
		Key    []byte
		Filter bool
	}{
		Key:    key,
		Filter: filter,
	}
	mock.lockscriptTreeByKey.Lock()
	mock.calls.scriptTreeByKey = append(mock.calls.scriptTreeByKey, callInfo)
	mock.lockscriptTreeByKey.Unlock()
	return mock.scriptTreeByKeyFunc(key, filter)
}

// scriptTreeByKeyCalls gets all the calls that were made to scriptTreeByKey.
// Check the length with:
//     len(mockedScriptStorageState.scriptTreeByKeyCalls())
func (mock *MockScriptStorageState) scriptTreeByKeyCalls() []struct {
	Key    []byte
	Filter bool
} {
	var calls []struct {
		Key    []byte
		Filter bool
	}
	mock.lockscriptTreeByKey.RLock()
	calls = mock.calls.scriptTreeByKey
	mock.lockscriptTreeByKey.RUnlock()
	return calls
}

// setAccountScript calls setAccountScriptFunc.
func (mock *MockScriptStorageState) setAccountScript(addr proto.WavesAddress, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
	if mock.setAccountScriptFunc == nil {
		panic("MockScriptStorageState.setAccountScriptFunc: method is nil but ScriptStorageState.setAccountScript was just called")
	}
	callInfo := struct {
		Addr    proto.WavesAddress
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}{
		Addr:    addr,
		Script:  script,
		Pk:      pk,
		BlockID: blockID,
	}
	mock.locksetAccountScript.Lock()
	mock.calls.setAccountScript = append(mock.calls.setAccountScript, callInfo)
	mock.locksetAccountScript.Unlock()
	return mock.setAccountScriptFunc(addr, script, pk, blockID)
}

// setAccountScriptCalls gets all the calls that were made to setAccountScript.
// Check the length with:
//     len(mockedScriptStorageState.setAccountScriptCalls())
func (mock *MockScriptStorageState) setAccountScriptCalls() []struct {
	Addr    proto.WavesAddress
	Script  proto.Script
	Pk      crypto.PublicKey
	BlockID proto.BlockID
} {
	var calls []struct {
		Addr    proto.WavesAddress
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}
	mock.locksetAccountScript.RLock()
	calls = mock.calls.setAccountScript
	mock.locksetAccountScript.RUnlock()
	return calls
}

// setAssetScript calls setAssetScriptFunc.
func (mock *MockScriptStorageState) setAssetScript(assetID crypto.Digest, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
	if mock.setAssetScriptFunc == nil {
		panic("MockScriptStorageState.setAssetScriptFunc: method is nil but ScriptStorageState.setAssetScript was just called")
	}
	callInfo := struct {
		AssetID crypto.Digest
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}{
		AssetID: assetID,
		Script:  script,
		Pk:      pk,
		BlockID: blockID,
	}
	mock.locksetAssetScript.Lock()
	mock.calls.setAssetScript = append(mock.calls.setAssetScript, callInfo)
	mock.locksetAssetScript.Unlock()
	return mock.setAssetScriptFunc(assetID, script, pk, blockID)
}

// setAssetScriptCalls gets all the calls that were made to setAssetScript.
// Check the length with:
//     len(mockedScriptStorageState.setAssetScriptCalls())
func (mock *MockScriptStorageState) setAssetScriptCalls() []struct {
	AssetID crypto.Digest
	Script  proto.Script
	Pk      crypto.PublicKey
	BlockID proto.BlockID
} {
	var calls []struct {
		AssetID crypto.Digest
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}
	mock.locksetAssetScript.RLock()
	calls = mock.calls.setAssetScript
	mock.locksetAssetScript.RUnlock()
	return calls
}

// setAssetScriptUncertain calls setAssetScriptUncertainFunc.
func (mock *MockScriptStorageState) setAssetScriptUncertain(fullAssetID crypto.Digest, script proto.Script, pk crypto.PublicKey) {
	if mock.setAssetScriptUncertainFunc == nil {
		panic("MockScriptStorageState.setAssetScriptUncertainFunc: method is nil but ScriptStorageState.setAssetScriptUncertain was just called")
	}
	callInfo := struct {
		FullAssetID crypto.Digest
		Script      proto.Script
		Pk          crypto.PublicKey
	}{
		FullAssetID: fullAssetID,
		Script:      script,
		Pk:          pk,
	}
	mock.locksetAssetScriptUncertain.Lock()
	mock.calls.setAssetScriptUncertain = append(mock.calls.setAssetScriptUncertain, callInfo)
	mock.locksetAssetScriptUncertain.Unlock()
	mock.setAssetScriptUncertainFunc(fullAssetID, script, pk)
}

// setAssetScriptUncertainCalls gets all the calls that were made to setAssetScriptUncertain.
// Check the length with:
//     len(mockedScriptStorageState.setAssetScriptUncertainCalls())
func (mock *MockScriptStorageState) setAssetScriptUncertainCalls() []struct {
	FullAssetID crypto.Digest
	Script      proto.Script
	Pk          crypto.PublicKey
} {
	var calls []struct {
		FullAssetID crypto.Digest
		Script      proto.Script
		Pk          crypto.PublicKey
	}
	mock.locksetAssetScriptUncertain.RLock()
	calls = mock.calls.setAssetScriptUncertain
	mock.locksetAssetScriptUncertain.RUnlock()
	return calls
}

// setScript calls setScriptFunc.
func (mock *MockScriptStorageState) setScript(scriptType blockchainEntity, key scriptKey, dbItem scriptDBItem, blockID proto.BlockID) error {
	if mock.setScriptFunc == nil {
		panic("MockScriptStorageState.setScriptFunc: method is nil but ScriptStorageState.setScript was just called")
	}
	callInfo := struct {
		ScriptType blockchainEntity
		Key        scriptKey
		DbItem     scriptDBItem
		BlockID    proto.BlockID
	}{
		ScriptType: scriptType,
		Key:        key,
		DbItem:     dbItem,
		BlockID:    blockID,
	}
	mock.locksetScript.Lock()
	mock.calls.setScript = append(mock.calls.setScript, callInfo)
	mock.locksetScript.Unlock()
	return mock.setScriptFunc(scriptType, key, dbItem, blockID)
}

// setScriptCalls gets all the calls that were made to setScript.
// Check the length with:
//     len(mockedScriptStorageState.setScriptCalls())
func (mock *MockScriptStorageState) setScriptCalls() []struct {
	ScriptType blockchainEntity
	Key        scriptKey
	DbItem     scriptDBItem
	BlockID    proto.BlockID
} {
	var calls []struct {
		ScriptType blockchainEntity
		Key        scriptKey
		DbItem     scriptDBItem
		BlockID    proto.BlockID
	}
	mock.locksetScript.RLock()
	calls = mock.calls.setScript
	mock.locksetScript.RUnlock()
	return calls
}
