// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package state

import (
	"github.com/wavesplatform/gowaves/pkg/crypto"
	"github.com/wavesplatform/gowaves/pkg/proto"
	"github.com/wavesplatform/gowaves/pkg/ride/ast"
	"sync"
)

// Ensure, that mockScriptStorageState does implement scriptStorageState.
// If this is not the case, regenerate this file with moq.
var _ scriptStorageState = &mockScriptStorageState{}

// mockScriptStorageState is a mock implementation of scriptStorageState.
//
//	func TestSomethingThatUsesscriptStorageState(t *testing.T) {
//
//		// make and configure a mocked scriptStorageState
//		mockedscriptStorageState := &mockScriptStorageState{
//			accountHasScriptFunc: func(addr proto.WavesAddress) (bool, error) {
//				panic("mock out the accountHasScript method")
//			},
//			accountHasVerifierFunc: func(addr proto.WavesAddress) (bool, error) {
//				panic("mock out the accountHasVerifier method")
//			},
//			accountIsDAppFunc: func(addr proto.WavesAddress) (bool, error) {
//				panic("mock out the accountIsDApp method")
//			},
//			clearCacheFunc: func() error {
//				panic("mock out the clearCache method")
//			},
//			commitUncertainFunc: func(blockID proto.BlockID) error {
//				panic("mock out the commitUncertain method")
//			},
//			dropUncertainFunc: func()  {
//				panic("mock out the dropUncertain method")
//			},
//			getAccountScriptsHasherFunc: func() *stateHasher {
//				panic("mock out the getAccountScriptsHasher method")
//			},
//			getAssetScriptsHasherFunc: func() *stateHasher {
//				panic("mock out the getAssetScriptsHasher method")
//			},
//			isSmartAssetFunc: func(assetID proto.AssetID) (bool, error) {
//				panic("mock out the isSmartAsset method")
//			},
//			newestAccountHasScriptFunc: func(addr proto.WavesAddress) (bool, error) {
//				panic("mock out the newestAccountHasScript method")
//			},
//			newestAccountHasVerifierFunc: func(addr proto.WavesAddress) (bool, error) {
//				panic("mock out the newestAccountHasVerifier method")
//			},
//			newestAccountIsDAppFunc: func(addr proto.WavesAddress) (bool, error) {
//				panic("mock out the newestAccountIsDApp method")
//			},
//			newestIsSmartAssetFunc: func(assetID proto.AssetID) (bool, error) {
//				panic("mock out the newestIsSmartAsset method")
//			},
//			newestScriptBasicInfoByAddressIDFunc: func(addressID proto.AddressID) (scriptBasicInfoRecord, error) {
//				panic("mock out the newestScriptBasicInfoByAddressID method")
//			},
//			newestScriptByAddrFunc: func(addr proto.WavesAddress) (*ast.Tree, error) {
//				panic("mock out the newestScriptByAddr method")
//			},
//			newestScriptByAssetFunc: func(assetID proto.AssetID) (*ast.Tree, error) {
//				panic("mock out the newestScriptByAsset method")
//			},
//			newestScriptBytesByAddrFunc: func(addr proto.WavesAddress) (proto.Script, error) {
//				panic("mock out the newestScriptBytesByAddr method")
//			},
//			newestScriptBytesByAssetFunc: func(assetID proto.AssetID) (proto.Script, error) {
//				panic("mock out the newestScriptBytesByAsset method")
//			},
//			prepareHashesFunc: func() error {
//				panic("mock out the prepareHashes method")
//			},
//			resetFunc: func()  {
//				panic("mock out the reset method")
//			},
//			scriptBasicInfoByAddressIDFunc: func(addressID proto.AddressID) (scriptBasicInfoRecord, error) {
//				panic("mock out the scriptBasicInfoByAddressID method")
//			},
//			scriptByAddrFunc: func(addr proto.WavesAddress) (*ast.Tree, error) {
//				panic("mock out the scriptByAddr method")
//			},
//			scriptByAssetFunc: func(assetID proto.AssetID) (*ast.Tree, error) {
//				panic("mock out the scriptByAsset method")
//			},
//			scriptBytesByAddrFunc: func(addr proto.WavesAddress) (proto.Script, error) {
//				panic("mock out the scriptBytesByAddr method")
//			},
//			scriptBytesByAssetFunc: func(assetID proto.AssetID) (proto.Script, error) {
//				panic("mock out the scriptBytesByAsset method")
//			},
//			setAccountScriptFunc: func(addr proto.WavesAddress, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
//				panic("mock out the setAccountScript method")
//			},
//			setAssetScriptFunc: func(assetID crypto.Digest, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
//				panic("mock out the setAssetScript method")
//			},
//			setAssetScriptUncertainFunc: func(fullAssetID crypto.Digest, script proto.Script, pk crypto.PublicKey) error {
//				panic("mock out the setAssetScriptUncertain method")
//			},
//		}
//
//		// use mockedscriptStorageState in code that requires scriptStorageState
//		// and then make assertions.
//
//	}
type mockScriptStorageState struct {
	// accountHasScriptFunc mocks the accountHasScript method.
	accountHasScriptFunc func(addr proto.WavesAddress) (bool, error)

	// accountHasVerifierFunc mocks the accountHasVerifier method.
	accountHasVerifierFunc func(addr proto.WavesAddress) (bool, error)

	// accountIsDAppFunc mocks the accountIsDApp method.
	accountIsDAppFunc func(addr proto.WavesAddress) (bool, error)

	// clearCacheFunc mocks the clearCache method.
	clearCacheFunc func() error

	// commitUncertainFunc mocks the commitUncertain method.
	commitUncertainFunc func(blockID proto.BlockID) error

	// dropUncertainFunc mocks the dropUncertain method.
	dropUncertainFunc func()

	// getAccountScriptsHasherFunc mocks the getAccountScriptsHasher method.
	getAccountScriptsHasherFunc func() *stateHasher

	// getAssetScriptsHasherFunc mocks the getAssetScriptsHasher method.
	getAssetScriptsHasherFunc func() *stateHasher

	// isSmartAssetFunc mocks the isSmartAsset method.
	isSmartAssetFunc func(assetID proto.AssetID) (bool, error)

	// newestAccountHasScriptFunc mocks the newestAccountHasScript method.
	newestAccountHasScriptFunc func(addr proto.WavesAddress) (bool, error)

	// newestAccountHasVerifierFunc mocks the newestAccountHasVerifier method.
	newestAccountHasVerifierFunc func(addr proto.WavesAddress) (bool, error)

	// newestAccountIsDAppFunc mocks the newestAccountIsDApp method.
	newestAccountIsDAppFunc func(addr proto.WavesAddress) (bool, error)

	// newestIsSmartAssetFunc mocks the newestIsSmartAsset method.
	newestIsSmartAssetFunc func(assetID proto.AssetID) (bool, error)

	// newestScriptBasicInfoByAddressIDFunc mocks the newestScriptBasicInfoByAddressID method.
	newestScriptBasicInfoByAddressIDFunc func(addressID proto.AddressID) (scriptBasicInfoRecord, error)

	// newestScriptByAddrFunc mocks the newestScriptByAddr method.
	newestScriptByAddrFunc func(addr proto.WavesAddress) (*ast.Tree, error)

	// newestScriptByAssetFunc mocks the newestScriptByAsset method.
	newestScriptByAssetFunc func(assetID proto.AssetID) (*ast.Tree, error)

	// newestScriptBytesByAddrFunc mocks the newestScriptBytesByAddr method.
	newestScriptBytesByAddrFunc func(addr proto.WavesAddress) (proto.Script, error)

	// newestScriptBytesByAssetFunc mocks the newestScriptBytesByAsset method.
	newestScriptBytesByAssetFunc func(assetID proto.AssetID) (proto.Script, error)

	// prepareHashesFunc mocks the prepareHashes method.
	prepareHashesFunc func() error

	// resetFunc mocks the reset method.
	resetFunc func()

	// scriptBasicInfoByAddressIDFunc mocks the scriptBasicInfoByAddressID method.
	scriptBasicInfoByAddressIDFunc func(addressID proto.AddressID) (scriptBasicInfoRecord, error)

	// scriptByAddrFunc mocks the scriptByAddr method.
	scriptByAddrFunc func(addr proto.WavesAddress) (*ast.Tree, error)

	// scriptByAssetFunc mocks the scriptByAsset method.
	scriptByAssetFunc func(assetID proto.AssetID) (*ast.Tree, error)

	// scriptBytesByAddrFunc mocks the scriptBytesByAddr method.
	scriptBytesByAddrFunc func(addr proto.WavesAddress) (proto.Script, error)

	// scriptBytesByAssetFunc mocks the scriptBytesByAsset method.
	scriptBytesByAssetFunc func(assetID proto.AssetID) (proto.Script, error)

	// setAccountScriptFunc mocks the setAccountScript method.
	setAccountScriptFunc func(addr proto.WavesAddress, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error

	// setAssetScriptFunc mocks the setAssetScript method.
	setAssetScriptFunc func(assetID crypto.Digest, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error

	// setAssetScriptUncertainFunc mocks the setAssetScriptUncertain method.
	setAssetScriptUncertainFunc func(fullAssetID crypto.Digest, script proto.Script, pk crypto.PublicKey) error

	// calls tracks calls to the methods.
	calls struct {
		// accountHasScript holds details about calls to the accountHasScript method.
		accountHasScript []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// accountHasVerifier holds details about calls to the accountHasVerifier method.
		accountHasVerifier []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// accountIsDApp holds details about calls to the accountIsDApp method.
		accountIsDApp []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// clearCache holds details about calls to the clearCache method.
		clearCache []struct {
		}
		// commitUncertain holds details about calls to the commitUncertain method.
		commitUncertain []struct {
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// dropUncertain holds details about calls to the dropUncertain method.
		dropUncertain []struct {
		}
		// getAccountScriptsHasher holds details about calls to the getAccountScriptsHasher method.
		getAccountScriptsHasher []struct {
		}
		// getAssetScriptsHasher holds details about calls to the getAssetScriptsHasher method.
		getAssetScriptsHasher []struct {
		}
		// isSmartAsset holds details about calls to the isSmartAsset method.
		isSmartAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// newestAccountHasScript holds details about calls to the newestAccountHasScript method.
		newestAccountHasScript []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// newestAccountHasVerifier holds details about calls to the newestAccountHasVerifier method.
		newestAccountHasVerifier []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// newestAccountIsDApp holds details about calls to the newestAccountIsDApp method.
		newestAccountIsDApp []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// newestIsSmartAsset holds details about calls to the newestIsSmartAsset method.
		newestIsSmartAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// newestScriptBasicInfoByAddressID holds details about calls to the newestScriptBasicInfoByAddressID method.
		newestScriptBasicInfoByAddressID []struct {
			// AddressID is the addressID argument value.
			AddressID proto.AddressID
		}
		// newestScriptByAddr holds details about calls to the newestScriptByAddr method.
		newestScriptByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// newestScriptByAsset holds details about calls to the newestScriptByAsset method.
		newestScriptByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// newestScriptBytesByAddr holds details about calls to the newestScriptBytesByAddr method.
		newestScriptBytesByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// newestScriptBytesByAsset holds details about calls to the newestScriptBytesByAsset method.
		newestScriptBytesByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// prepareHashes holds details about calls to the prepareHashes method.
		prepareHashes []struct {
		}
		// reset holds details about calls to the reset method.
		reset []struct {
		}
		// scriptBasicInfoByAddressID holds details about calls to the scriptBasicInfoByAddressID method.
		scriptBasicInfoByAddressID []struct {
			// AddressID is the addressID argument value.
			AddressID proto.AddressID
		}
		// scriptByAddr holds details about calls to the scriptByAddr method.
		scriptByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// scriptByAsset holds details about calls to the scriptByAsset method.
		scriptByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// scriptBytesByAddr holds details about calls to the scriptBytesByAddr method.
		scriptBytesByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// scriptBytesByAsset holds details about calls to the scriptBytesByAsset method.
		scriptBytesByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// setAccountScript holds details about calls to the setAccountScript method.
		setAccountScript []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
			// Script is the script argument value.
			Script proto.Script
			// Pk is the pk argument value.
			Pk crypto.PublicKey
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// setAssetScript holds details about calls to the setAssetScript method.
		setAssetScript []struct {
			// AssetID is the assetID argument value.
			AssetID crypto.Digest
			// Script is the script argument value.
			Script proto.Script
			// Pk is the pk argument value.
			Pk crypto.PublicKey
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// setAssetScriptUncertain holds details about calls to the setAssetScriptUncertain method.
		setAssetScriptUncertain []struct {
			// FullAssetID is the fullAssetID argument value.
			FullAssetID crypto.Digest
			// Script is the script argument value.
			Script proto.Script
			// Pk is the pk argument value.
			Pk crypto.PublicKey
		}
	}
	lockaccountHasScript                 sync.RWMutex
	lockaccountHasVerifier               sync.RWMutex
	lockaccountIsDApp                    sync.RWMutex
	lockclearCache                       sync.RWMutex
	lockcommitUncertain                  sync.RWMutex
	lockdropUncertain                    sync.RWMutex
	lockgetAccountScriptsHasher          sync.RWMutex
	lockgetAssetScriptsHasher            sync.RWMutex
	lockisSmartAsset                     sync.RWMutex
	locknewestAccountHasScript           sync.RWMutex
	locknewestAccountHasVerifier         sync.RWMutex
	locknewestAccountIsDApp              sync.RWMutex
	locknewestIsSmartAsset               sync.RWMutex
	locknewestScriptBasicInfoByAddressID sync.RWMutex
	locknewestScriptByAddr               sync.RWMutex
	locknewestScriptByAsset              sync.RWMutex
	locknewestScriptBytesByAddr          sync.RWMutex
	locknewestScriptBytesByAsset         sync.RWMutex
	lockprepareHashes                    sync.RWMutex
	lockreset                            sync.RWMutex
	lockscriptBasicInfoByAddressID       sync.RWMutex
	lockscriptByAddr                     sync.RWMutex
	lockscriptByAsset                    sync.RWMutex
	lockscriptBytesByAddr                sync.RWMutex
	lockscriptBytesByAsset               sync.RWMutex
	locksetAccountScript                 sync.RWMutex
	locksetAssetScript                   sync.RWMutex
	locksetAssetScriptUncertain          sync.RWMutex
}

// accountHasScript calls accountHasScriptFunc.
func (mock *mockScriptStorageState) accountHasScript(addr proto.WavesAddress) (bool, error) {
	if mock.accountHasScriptFunc == nil {
		panic("mockScriptStorageState.accountHasScriptFunc: method is nil but scriptStorageState.accountHasScript was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.lockaccountHasScript.Lock()
	mock.calls.accountHasScript = append(mock.calls.accountHasScript, callInfo)
	mock.lockaccountHasScript.Unlock()
	return mock.accountHasScriptFunc(addr)
}

// accountHasScriptCalls gets all the calls that were made to accountHasScript.
// Check the length with:
//
//	len(mockedscriptStorageState.accountHasScriptCalls())
func (mock *mockScriptStorageState) accountHasScriptCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.lockaccountHasScript.RLock()
	calls = mock.calls.accountHasScript
	mock.lockaccountHasScript.RUnlock()
	return calls
}

// accountHasVerifier calls accountHasVerifierFunc.
func (mock *mockScriptStorageState) accountHasVerifier(addr proto.WavesAddress) (bool, error) {
	if mock.accountHasVerifierFunc == nil {
		panic("mockScriptStorageState.accountHasVerifierFunc: method is nil but scriptStorageState.accountHasVerifier was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.lockaccountHasVerifier.Lock()
	mock.calls.accountHasVerifier = append(mock.calls.accountHasVerifier, callInfo)
	mock.lockaccountHasVerifier.Unlock()
	return mock.accountHasVerifierFunc(addr)
}

// accountHasVerifierCalls gets all the calls that were made to accountHasVerifier.
// Check the length with:
//
//	len(mockedscriptStorageState.accountHasVerifierCalls())
func (mock *mockScriptStorageState) accountHasVerifierCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.lockaccountHasVerifier.RLock()
	calls = mock.calls.accountHasVerifier
	mock.lockaccountHasVerifier.RUnlock()
	return calls
}

// accountIsDApp calls accountIsDAppFunc.
func (mock *mockScriptStorageState) accountIsDApp(addr proto.WavesAddress) (bool, error) {
	if mock.accountIsDAppFunc == nil {
		panic("mockScriptStorageState.accountIsDAppFunc: method is nil but scriptStorageState.accountIsDApp was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.lockaccountIsDApp.Lock()
	mock.calls.accountIsDApp = append(mock.calls.accountIsDApp, callInfo)
	mock.lockaccountIsDApp.Unlock()
	return mock.accountIsDAppFunc(addr)
}

// accountIsDAppCalls gets all the calls that were made to accountIsDApp.
// Check the length with:
//
//	len(mockedscriptStorageState.accountIsDAppCalls())
func (mock *mockScriptStorageState) accountIsDAppCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.lockaccountIsDApp.RLock()
	calls = mock.calls.accountIsDApp
	mock.lockaccountIsDApp.RUnlock()
	return calls
}

// clearCache calls clearCacheFunc.
func (mock *mockScriptStorageState) clearCache() error {
	if mock.clearCacheFunc == nil {
		panic("mockScriptStorageState.clearCacheFunc: method is nil but scriptStorageState.clearCache was just called")
	}
	callInfo := struct {
	}{}
	mock.lockclearCache.Lock()
	mock.calls.clearCache = append(mock.calls.clearCache, callInfo)
	mock.lockclearCache.Unlock()
	return mock.clearCacheFunc()
}

// clearCacheCalls gets all the calls that were made to clearCache.
// Check the length with:
//
//	len(mockedscriptStorageState.clearCacheCalls())
func (mock *mockScriptStorageState) clearCacheCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockclearCache.RLock()
	calls = mock.calls.clearCache
	mock.lockclearCache.RUnlock()
	return calls
}

// commitUncertain calls commitUncertainFunc.
func (mock *mockScriptStorageState) commitUncertain(blockID proto.BlockID) error {
	if mock.commitUncertainFunc == nil {
		panic("mockScriptStorageState.commitUncertainFunc: method is nil but scriptStorageState.commitUncertain was just called")
	}
	callInfo := struct {
		BlockID proto.BlockID
	}{
		BlockID: blockID,
	}
	mock.lockcommitUncertain.Lock()
	mock.calls.commitUncertain = append(mock.calls.commitUncertain, callInfo)
	mock.lockcommitUncertain.Unlock()
	return mock.commitUncertainFunc(blockID)
}

// commitUncertainCalls gets all the calls that were made to commitUncertain.
// Check the length with:
//
//	len(mockedscriptStorageState.commitUncertainCalls())
func (mock *mockScriptStorageState) commitUncertainCalls() []struct {
	BlockID proto.BlockID
} {
	var calls []struct {
		BlockID proto.BlockID
	}
	mock.lockcommitUncertain.RLock()
	calls = mock.calls.commitUncertain
	mock.lockcommitUncertain.RUnlock()
	return calls
}

// dropUncertain calls dropUncertainFunc.
func (mock *mockScriptStorageState) dropUncertain() {
	if mock.dropUncertainFunc == nil {
		panic("mockScriptStorageState.dropUncertainFunc: method is nil but scriptStorageState.dropUncertain was just called")
	}
	callInfo := struct {
	}{}
	mock.lockdropUncertain.Lock()
	mock.calls.dropUncertain = append(mock.calls.dropUncertain, callInfo)
	mock.lockdropUncertain.Unlock()
	mock.dropUncertainFunc()
}

// dropUncertainCalls gets all the calls that were made to dropUncertain.
// Check the length with:
//
//	len(mockedscriptStorageState.dropUncertainCalls())
func (mock *mockScriptStorageState) dropUncertainCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockdropUncertain.RLock()
	calls = mock.calls.dropUncertain
	mock.lockdropUncertain.RUnlock()
	return calls
}

// getAccountScriptsHasher calls getAccountScriptsHasherFunc.
func (mock *mockScriptStorageState) getAccountScriptsHasher() *stateHasher {
	if mock.getAccountScriptsHasherFunc == nil {
		panic("mockScriptStorageState.getAccountScriptsHasherFunc: method is nil but scriptStorageState.getAccountScriptsHasher was just called")
	}
	callInfo := struct {
	}{}
	mock.lockgetAccountScriptsHasher.Lock()
	mock.calls.getAccountScriptsHasher = append(mock.calls.getAccountScriptsHasher, callInfo)
	mock.lockgetAccountScriptsHasher.Unlock()
	return mock.getAccountScriptsHasherFunc()
}

// getAccountScriptsHasherCalls gets all the calls that were made to getAccountScriptsHasher.
// Check the length with:
//
//	len(mockedscriptStorageState.getAccountScriptsHasherCalls())
func (mock *mockScriptStorageState) getAccountScriptsHasherCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockgetAccountScriptsHasher.RLock()
	calls = mock.calls.getAccountScriptsHasher
	mock.lockgetAccountScriptsHasher.RUnlock()
	return calls
}

// getAssetScriptsHasher calls getAssetScriptsHasherFunc.
func (mock *mockScriptStorageState) getAssetScriptsHasher() *stateHasher {
	if mock.getAssetScriptsHasherFunc == nil {
		panic("mockScriptStorageState.getAssetScriptsHasherFunc: method is nil but scriptStorageState.getAssetScriptsHasher was just called")
	}
	callInfo := struct {
	}{}
	mock.lockgetAssetScriptsHasher.Lock()
	mock.calls.getAssetScriptsHasher = append(mock.calls.getAssetScriptsHasher, callInfo)
	mock.lockgetAssetScriptsHasher.Unlock()
	return mock.getAssetScriptsHasherFunc()
}

// getAssetScriptsHasherCalls gets all the calls that were made to getAssetScriptsHasher.
// Check the length with:
//
//	len(mockedscriptStorageState.getAssetScriptsHasherCalls())
func (mock *mockScriptStorageState) getAssetScriptsHasherCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockgetAssetScriptsHasher.RLock()
	calls = mock.calls.getAssetScriptsHasher
	mock.lockgetAssetScriptsHasher.RUnlock()
	return calls
}

// isSmartAsset calls isSmartAssetFunc.
func (mock *mockScriptStorageState) isSmartAsset(assetID proto.AssetID) (bool, error) {
	if mock.isSmartAssetFunc == nil {
		panic("mockScriptStorageState.isSmartAssetFunc: method is nil but scriptStorageState.isSmartAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockisSmartAsset.Lock()
	mock.calls.isSmartAsset = append(mock.calls.isSmartAsset, callInfo)
	mock.lockisSmartAsset.Unlock()
	return mock.isSmartAssetFunc(assetID)
}

// isSmartAssetCalls gets all the calls that were made to isSmartAsset.
// Check the length with:
//
//	len(mockedscriptStorageState.isSmartAssetCalls())
func (mock *mockScriptStorageState) isSmartAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockisSmartAsset.RLock()
	calls = mock.calls.isSmartAsset
	mock.lockisSmartAsset.RUnlock()
	return calls
}

// newestAccountHasScript calls newestAccountHasScriptFunc.
func (mock *mockScriptStorageState) newestAccountHasScript(addr proto.WavesAddress) (bool, error) {
	if mock.newestAccountHasScriptFunc == nil {
		panic("mockScriptStorageState.newestAccountHasScriptFunc: method is nil but scriptStorageState.newestAccountHasScript was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.locknewestAccountHasScript.Lock()
	mock.calls.newestAccountHasScript = append(mock.calls.newestAccountHasScript, callInfo)
	mock.locknewestAccountHasScript.Unlock()
	return mock.newestAccountHasScriptFunc(addr)
}

// newestAccountHasScriptCalls gets all the calls that were made to newestAccountHasScript.
// Check the length with:
//
//	len(mockedscriptStorageState.newestAccountHasScriptCalls())
func (mock *mockScriptStorageState) newestAccountHasScriptCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.locknewestAccountHasScript.RLock()
	calls = mock.calls.newestAccountHasScript
	mock.locknewestAccountHasScript.RUnlock()
	return calls
}

// newestAccountHasVerifier calls newestAccountHasVerifierFunc.
func (mock *mockScriptStorageState) newestAccountHasVerifier(addr proto.WavesAddress) (bool, error) {
	if mock.newestAccountHasVerifierFunc == nil {
		panic("mockScriptStorageState.newestAccountHasVerifierFunc: method is nil but scriptStorageState.newestAccountHasVerifier was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.locknewestAccountHasVerifier.Lock()
	mock.calls.newestAccountHasVerifier = append(mock.calls.newestAccountHasVerifier, callInfo)
	mock.locknewestAccountHasVerifier.Unlock()
	return mock.newestAccountHasVerifierFunc(addr)
}

// newestAccountHasVerifierCalls gets all the calls that were made to newestAccountHasVerifier.
// Check the length with:
//
//	len(mockedscriptStorageState.newestAccountHasVerifierCalls())
func (mock *mockScriptStorageState) newestAccountHasVerifierCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.locknewestAccountHasVerifier.RLock()
	calls = mock.calls.newestAccountHasVerifier
	mock.locknewestAccountHasVerifier.RUnlock()
	return calls
}

// newestAccountIsDApp calls newestAccountIsDAppFunc.
func (mock *mockScriptStorageState) newestAccountIsDApp(addr proto.WavesAddress) (bool, error) {
	if mock.newestAccountIsDAppFunc == nil {
		panic("mockScriptStorageState.newestAccountIsDAppFunc: method is nil but scriptStorageState.newestAccountIsDApp was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.locknewestAccountIsDApp.Lock()
	mock.calls.newestAccountIsDApp = append(mock.calls.newestAccountIsDApp, callInfo)
	mock.locknewestAccountIsDApp.Unlock()
	return mock.newestAccountIsDAppFunc(addr)
}

// newestAccountIsDAppCalls gets all the calls that were made to newestAccountIsDApp.
// Check the length with:
//
//	len(mockedscriptStorageState.newestAccountIsDAppCalls())
func (mock *mockScriptStorageState) newestAccountIsDAppCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.locknewestAccountIsDApp.RLock()
	calls = mock.calls.newestAccountIsDApp
	mock.locknewestAccountIsDApp.RUnlock()
	return calls
}

// newestIsSmartAsset calls newestIsSmartAssetFunc.
func (mock *mockScriptStorageState) newestIsSmartAsset(assetID proto.AssetID) (bool, error) {
	if mock.newestIsSmartAssetFunc == nil {
		panic("mockScriptStorageState.newestIsSmartAssetFunc: method is nil but scriptStorageState.newestIsSmartAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.locknewestIsSmartAsset.Lock()
	mock.calls.newestIsSmartAsset = append(mock.calls.newestIsSmartAsset, callInfo)
	mock.locknewestIsSmartAsset.Unlock()
	return mock.newestIsSmartAssetFunc(assetID)
}

// newestIsSmartAssetCalls gets all the calls that were made to newestIsSmartAsset.
// Check the length with:
//
//	len(mockedscriptStorageState.newestIsSmartAssetCalls())
func (mock *mockScriptStorageState) newestIsSmartAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.locknewestIsSmartAsset.RLock()
	calls = mock.calls.newestIsSmartAsset
	mock.locknewestIsSmartAsset.RUnlock()
	return calls
}

// newestScriptBasicInfoByAddressID calls newestScriptBasicInfoByAddressIDFunc.
func (mock *mockScriptStorageState) newestScriptBasicInfoByAddressID(addressID proto.AddressID) (scriptBasicInfoRecord, error) {
	if mock.newestScriptBasicInfoByAddressIDFunc == nil {
		panic("mockScriptStorageState.newestScriptBasicInfoByAddressIDFunc: method is nil but scriptStorageState.newestScriptBasicInfoByAddressID was just called")
	}
	callInfo := struct {
		AddressID proto.AddressID
	}{
		AddressID: addressID,
	}
	mock.locknewestScriptBasicInfoByAddressID.Lock()
	mock.calls.newestScriptBasicInfoByAddressID = append(mock.calls.newestScriptBasicInfoByAddressID, callInfo)
	mock.locknewestScriptBasicInfoByAddressID.Unlock()
	return mock.newestScriptBasicInfoByAddressIDFunc(addressID)
}

// newestScriptBasicInfoByAddressIDCalls gets all the calls that were made to newestScriptBasicInfoByAddressID.
// Check the length with:
//
//	len(mockedscriptStorageState.newestScriptBasicInfoByAddressIDCalls())
func (mock *mockScriptStorageState) newestScriptBasicInfoByAddressIDCalls() []struct {
	AddressID proto.AddressID
} {
	var calls []struct {
		AddressID proto.AddressID
	}
	mock.locknewestScriptBasicInfoByAddressID.RLock()
	calls = mock.calls.newestScriptBasicInfoByAddressID
	mock.locknewestScriptBasicInfoByAddressID.RUnlock()
	return calls
}

// newestScriptByAddr calls newestScriptByAddrFunc.
func (mock *mockScriptStorageState) newestScriptByAddr(addr proto.WavesAddress) (*ast.Tree, error) {
	if mock.newestScriptByAddrFunc == nil {
		panic("mockScriptStorageState.newestScriptByAddrFunc: method is nil but scriptStorageState.newestScriptByAddr was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.locknewestScriptByAddr.Lock()
	mock.calls.newestScriptByAddr = append(mock.calls.newestScriptByAddr, callInfo)
	mock.locknewestScriptByAddr.Unlock()
	return mock.newestScriptByAddrFunc(addr)
}

// newestScriptByAddrCalls gets all the calls that were made to newestScriptByAddr.
// Check the length with:
//
//	len(mockedscriptStorageState.newestScriptByAddrCalls())
func (mock *mockScriptStorageState) newestScriptByAddrCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.locknewestScriptByAddr.RLock()
	calls = mock.calls.newestScriptByAddr
	mock.locknewestScriptByAddr.RUnlock()
	return calls
}

// newestScriptByAsset calls newestScriptByAssetFunc.
func (mock *mockScriptStorageState) newestScriptByAsset(assetID proto.AssetID) (*ast.Tree, error) {
	if mock.newestScriptByAssetFunc == nil {
		panic("mockScriptStorageState.newestScriptByAssetFunc: method is nil but scriptStorageState.newestScriptByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.locknewestScriptByAsset.Lock()
	mock.calls.newestScriptByAsset = append(mock.calls.newestScriptByAsset, callInfo)
	mock.locknewestScriptByAsset.Unlock()
	return mock.newestScriptByAssetFunc(assetID)
}

// newestScriptByAssetCalls gets all the calls that were made to newestScriptByAsset.
// Check the length with:
//
//	len(mockedscriptStorageState.newestScriptByAssetCalls())
func (mock *mockScriptStorageState) newestScriptByAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.locknewestScriptByAsset.RLock()
	calls = mock.calls.newestScriptByAsset
	mock.locknewestScriptByAsset.RUnlock()
	return calls
}

// newestScriptBytesByAddr calls newestScriptBytesByAddrFunc.
func (mock *mockScriptStorageState) newestScriptBytesByAddr(addr proto.WavesAddress) (proto.Script, error) {
	if mock.newestScriptBytesByAddrFunc == nil {
		panic("mockScriptStorageState.newestScriptBytesByAddrFunc: method is nil but scriptStorageState.newestScriptBytesByAddr was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.locknewestScriptBytesByAddr.Lock()
	mock.calls.newestScriptBytesByAddr = append(mock.calls.newestScriptBytesByAddr, callInfo)
	mock.locknewestScriptBytesByAddr.Unlock()
	return mock.newestScriptBytesByAddrFunc(addr)
}

// newestScriptBytesByAddrCalls gets all the calls that were made to newestScriptBytesByAddr.
// Check the length with:
//
//	len(mockedscriptStorageState.newestScriptBytesByAddrCalls())
func (mock *mockScriptStorageState) newestScriptBytesByAddrCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.locknewestScriptBytesByAddr.RLock()
	calls = mock.calls.newestScriptBytesByAddr
	mock.locknewestScriptBytesByAddr.RUnlock()
	return calls
}

// newestScriptBytesByAsset calls newestScriptBytesByAssetFunc.
func (mock *mockScriptStorageState) newestScriptBytesByAsset(assetID proto.AssetID) (proto.Script, error) {
	if mock.newestScriptBytesByAssetFunc == nil {
		panic("mockScriptStorageState.newestScriptBytesByAssetFunc: method is nil but scriptStorageState.newestScriptBytesByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.locknewestScriptBytesByAsset.Lock()
	mock.calls.newestScriptBytesByAsset = append(mock.calls.newestScriptBytesByAsset, callInfo)
	mock.locknewestScriptBytesByAsset.Unlock()
	return mock.newestScriptBytesByAssetFunc(assetID)
}

// newestScriptBytesByAssetCalls gets all the calls that were made to newestScriptBytesByAsset.
// Check the length with:
//
//	len(mockedscriptStorageState.newestScriptBytesByAssetCalls())
func (mock *mockScriptStorageState) newestScriptBytesByAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.locknewestScriptBytesByAsset.RLock()
	calls = mock.calls.newestScriptBytesByAsset
	mock.locknewestScriptBytesByAsset.RUnlock()
	return calls
}

// prepareHashes calls prepareHashesFunc.
func (mock *mockScriptStorageState) prepareHashes() error {
	if mock.prepareHashesFunc == nil {
		panic("mockScriptStorageState.prepareHashesFunc: method is nil but scriptStorageState.prepareHashes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockprepareHashes.Lock()
	mock.calls.prepareHashes = append(mock.calls.prepareHashes, callInfo)
	mock.lockprepareHashes.Unlock()
	return mock.prepareHashesFunc()
}

// prepareHashesCalls gets all the calls that were made to prepareHashes.
// Check the length with:
//
//	len(mockedscriptStorageState.prepareHashesCalls())
func (mock *mockScriptStorageState) prepareHashesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockprepareHashes.RLock()
	calls = mock.calls.prepareHashes
	mock.lockprepareHashes.RUnlock()
	return calls
}

// reset calls resetFunc.
func (mock *mockScriptStorageState) reset() {
	if mock.resetFunc == nil {
		panic("mockScriptStorageState.resetFunc: method is nil but scriptStorageState.reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockreset.Lock()
	mock.calls.reset = append(mock.calls.reset, callInfo)
	mock.lockreset.Unlock()
	mock.resetFunc()
}

// resetCalls gets all the calls that were made to reset.
// Check the length with:
//
//	len(mockedscriptStorageState.resetCalls())
func (mock *mockScriptStorageState) resetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockreset.RLock()
	calls = mock.calls.reset
	mock.lockreset.RUnlock()
	return calls
}

// scriptBasicInfoByAddressID calls scriptBasicInfoByAddressIDFunc.
func (mock *mockScriptStorageState) scriptBasicInfoByAddressID(addressID proto.AddressID) (scriptBasicInfoRecord, error) {
	if mock.scriptBasicInfoByAddressIDFunc == nil {
		panic("mockScriptStorageState.scriptBasicInfoByAddressIDFunc: method is nil but scriptStorageState.scriptBasicInfoByAddressID was just called")
	}
	callInfo := struct {
		AddressID proto.AddressID
	}{
		AddressID: addressID,
	}
	mock.lockscriptBasicInfoByAddressID.Lock()
	mock.calls.scriptBasicInfoByAddressID = append(mock.calls.scriptBasicInfoByAddressID, callInfo)
	mock.lockscriptBasicInfoByAddressID.Unlock()
	return mock.scriptBasicInfoByAddressIDFunc(addressID)
}

// scriptBasicInfoByAddressIDCalls gets all the calls that were made to scriptBasicInfoByAddressID.
// Check the length with:
//
//	len(mockedscriptStorageState.scriptBasicInfoByAddressIDCalls())
func (mock *mockScriptStorageState) scriptBasicInfoByAddressIDCalls() []struct {
	AddressID proto.AddressID
} {
	var calls []struct {
		AddressID proto.AddressID
	}
	mock.lockscriptBasicInfoByAddressID.RLock()
	calls = mock.calls.scriptBasicInfoByAddressID
	mock.lockscriptBasicInfoByAddressID.RUnlock()
	return calls
}

// scriptByAddr calls scriptByAddrFunc.
func (mock *mockScriptStorageState) scriptByAddr(addr proto.WavesAddress) (*ast.Tree, error) {
	if mock.scriptByAddrFunc == nil {
		panic("mockScriptStorageState.scriptByAddrFunc: method is nil but scriptStorageState.scriptByAddr was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.lockscriptByAddr.Lock()
	mock.calls.scriptByAddr = append(mock.calls.scriptByAddr, callInfo)
	mock.lockscriptByAddr.Unlock()
	return mock.scriptByAddrFunc(addr)
}

// scriptByAddrCalls gets all the calls that were made to scriptByAddr.
// Check the length with:
//
//	len(mockedscriptStorageState.scriptByAddrCalls())
func (mock *mockScriptStorageState) scriptByAddrCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.lockscriptByAddr.RLock()
	calls = mock.calls.scriptByAddr
	mock.lockscriptByAddr.RUnlock()
	return calls
}

// scriptByAsset calls scriptByAssetFunc.
func (mock *mockScriptStorageState) scriptByAsset(assetID proto.AssetID) (*ast.Tree, error) {
	if mock.scriptByAssetFunc == nil {
		panic("mockScriptStorageState.scriptByAssetFunc: method is nil but scriptStorageState.scriptByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockscriptByAsset.Lock()
	mock.calls.scriptByAsset = append(mock.calls.scriptByAsset, callInfo)
	mock.lockscriptByAsset.Unlock()
	return mock.scriptByAssetFunc(assetID)
}

// scriptByAssetCalls gets all the calls that were made to scriptByAsset.
// Check the length with:
//
//	len(mockedscriptStorageState.scriptByAssetCalls())
func (mock *mockScriptStorageState) scriptByAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockscriptByAsset.RLock()
	calls = mock.calls.scriptByAsset
	mock.lockscriptByAsset.RUnlock()
	return calls
}

// scriptBytesByAddr calls scriptBytesByAddrFunc.
func (mock *mockScriptStorageState) scriptBytesByAddr(addr proto.WavesAddress) (proto.Script, error) {
	if mock.scriptBytesByAddrFunc == nil {
		panic("mockScriptStorageState.scriptBytesByAddrFunc: method is nil but scriptStorageState.scriptBytesByAddr was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.lockscriptBytesByAddr.Lock()
	mock.calls.scriptBytesByAddr = append(mock.calls.scriptBytesByAddr, callInfo)
	mock.lockscriptBytesByAddr.Unlock()
	return mock.scriptBytesByAddrFunc(addr)
}

// scriptBytesByAddrCalls gets all the calls that were made to scriptBytesByAddr.
// Check the length with:
//
//	len(mockedscriptStorageState.scriptBytesByAddrCalls())
func (mock *mockScriptStorageState) scriptBytesByAddrCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.lockscriptBytesByAddr.RLock()
	calls = mock.calls.scriptBytesByAddr
	mock.lockscriptBytesByAddr.RUnlock()
	return calls
}

// scriptBytesByAsset calls scriptBytesByAssetFunc.
func (mock *mockScriptStorageState) scriptBytesByAsset(assetID proto.AssetID) (proto.Script, error) {
	if mock.scriptBytesByAssetFunc == nil {
		panic("mockScriptStorageState.scriptBytesByAssetFunc: method is nil but scriptStorageState.scriptBytesByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockscriptBytesByAsset.Lock()
	mock.calls.scriptBytesByAsset = append(mock.calls.scriptBytesByAsset, callInfo)
	mock.lockscriptBytesByAsset.Unlock()
	return mock.scriptBytesByAssetFunc(assetID)
}

// scriptBytesByAssetCalls gets all the calls that were made to scriptBytesByAsset.
// Check the length with:
//
//	len(mockedscriptStorageState.scriptBytesByAssetCalls())
func (mock *mockScriptStorageState) scriptBytesByAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockscriptBytesByAsset.RLock()
	calls = mock.calls.scriptBytesByAsset
	mock.lockscriptBytesByAsset.RUnlock()
	return calls
}

// setAccountScript calls setAccountScriptFunc.
func (mock *mockScriptStorageState) setAccountScript(addr proto.WavesAddress, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
	if mock.setAccountScriptFunc == nil {
		panic("mockScriptStorageState.setAccountScriptFunc: method is nil but scriptStorageState.setAccountScript was just called")
	}
	callInfo := struct {
		Addr    proto.WavesAddress
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}{
		Addr:    addr,
		Script:  script,
		Pk:      pk,
		BlockID: blockID,
	}
	mock.locksetAccountScript.Lock()
	mock.calls.setAccountScript = append(mock.calls.setAccountScript, callInfo)
	mock.locksetAccountScript.Unlock()
	return mock.setAccountScriptFunc(addr, script, pk, blockID)
}

// setAccountScriptCalls gets all the calls that were made to setAccountScript.
// Check the length with:
//
//	len(mockedscriptStorageState.setAccountScriptCalls())
func (mock *mockScriptStorageState) setAccountScriptCalls() []struct {
	Addr    proto.WavesAddress
	Script  proto.Script
	Pk      crypto.PublicKey
	BlockID proto.BlockID
} {
	var calls []struct {
		Addr    proto.WavesAddress
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}
	mock.locksetAccountScript.RLock()
	calls = mock.calls.setAccountScript
	mock.locksetAccountScript.RUnlock()
	return calls
}

// setAssetScript calls setAssetScriptFunc.
func (mock *mockScriptStorageState) setAssetScript(assetID crypto.Digest, script proto.Script, pk crypto.PublicKey, blockID proto.BlockID) error {
	if mock.setAssetScriptFunc == nil {
		panic("mockScriptStorageState.setAssetScriptFunc: method is nil but scriptStorageState.setAssetScript was just called")
	}
	callInfo := struct {
		AssetID crypto.Digest
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}{
		AssetID: assetID,
		Script:  script,
		Pk:      pk,
		BlockID: blockID,
	}
	mock.locksetAssetScript.Lock()
	mock.calls.setAssetScript = append(mock.calls.setAssetScript, callInfo)
	mock.locksetAssetScript.Unlock()
	return mock.setAssetScriptFunc(assetID, script, pk, blockID)
}

// setAssetScriptCalls gets all the calls that were made to setAssetScript.
// Check the length with:
//
//	len(mockedscriptStorageState.setAssetScriptCalls())
func (mock *mockScriptStorageState) setAssetScriptCalls() []struct {
	AssetID crypto.Digest
	Script  proto.Script
	Pk      crypto.PublicKey
	BlockID proto.BlockID
} {
	var calls []struct {
		AssetID crypto.Digest
		Script  proto.Script
		Pk      crypto.PublicKey
		BlockID proto.BlockID
	}
	mock.locksetAssetScript.RLock()
	calls = mock.calls.setAssetScript
	mock.locksetAssetScript.RUnlock()
	return calls
}

// setAssetScriptUncertain calls setAssetScriptUncertainFunc.
func (mock *mockScriptStorageState) setAssetScriptUncertain(fullAssetID crypto.Digest, script proto.Script, pk crypto.PublicKey) error {
	if mock.setAssetScriptUncertainFunc == nil {
		panic("mockScriptStorageState.setAssetScriptUncertainFunc: method is nil but scriptStorageState.setAssetScriptUncertain was just called")
	}
	callInfo := struct {
		FullAssetID crypto.Digest
		Script      proto.Script
		Pk          crypto.PublicKey
	}{
		FullAssetID: fullAssetID,
		Script:      script,
		Pk:          pk,
	}
	mock.locksetAssetScriptUncertain.Lock()
	mock.calls.setAssetScriptUncertain = append(mock.calls.setAssetScriptUncertain, callInfo)
	mock.locksetAssetScriptUncertain.Unlock()
	return mock.setAssetScriptUncertainFunc(fullAssetID, script, pk)
}

// setAssetScriptUncertainCalls gets all the calls that were made to setAssetScriptUncertain.
// Check the length with:
//
//	len(mockedscriptStorageState.setAssetScriptUncertainCalls())
func (mock *mockScriptStorageState) setAssetScriptUncertainCalls() []struct {
	FullAssetID crypto.Digest
	Script      proto.Script
	Pk          crypto.PublicKey
} {
	var calls []struct {
		FullAssetID crypto.Digest
		Script      proto.Script
		Pk          crypto.PublicKey
	}
	mock.locksetAssetScriptUncertain.RLock()
	calls = mock.calls.setAssetScriptUncertain
	mock.locksetAssetScriptUncertain.RUnlock()
	return calls
}
