package proto

import (
	"math/big"

	"github.com/pkg/errors"

	"github.com/wavesplatform/gowaves/pkg/crypto"
	g "github.com/wavesplatform/gowaves/pkg/grpc/generated/waves"
)

type AtomicSnapshot interface {
	Apply(SnapshotApplier) error
	/* is temporarily used to mark snapshots generated by tx diff that shouldn't be applied,
	because balances diffs are applied later in the block. */
	IsGeneratedByTxDiff() bool
	AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error
}

type WavesBalanceSnapshot struct {
	Address WavesAddress
	Balance uint64
}

func (s WavesBalanceSnapshot) IsGeneratedByTxDiff() bool {
	return true
}

func (s WavesBalanceSnapshot) Apply(a SnapshotApplier) error { return a.ApplyWavesBalance(s) }

func (s WavesBalanceSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_Balance, error) {
	return &g.TransactionStateSnapshot_Balance{
		Address: s.Address.Body(),
		Amount: &g.Amount{
			AssetId: nil,
			Amount:  int64(s.Balance),
		},
	}, nil
}

func (s WavesBalanceSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.Balances = append(txSnapshots.Balances, snapshotInProto)
	return nil
}

type AssetBalanceSnapshot struct {
	Address WavesAddress
	AssetID crypto.Digest
	Balance uint64
}

func (s AssetBalanceSnapshot) IsGeneratedByTxDiff() bool {
	return true
}

func (s AssetBalanceSnapshot) Apply(a SnapshotApplier) error { return a.ApplyAssetBalance(s) }

func (s AssetBalanceSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_Balance, error) {
	return &g.TransactionStateSnapshot_Balance{
		Address: s.Address.Body(),
		Amount: &g.Amount{
			AssetId: s.AssetID.Bytes(),
			Amount:  int64(s.Balance),
		},
	}, nil
}

func (s AssetBalanceSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.Balances = append(txSnapshots.Balances, snapshotInProto)
	return nil
}

type DataEntriesSnapshot struct { // AccountData in pb
	Address     WavesAddress
	DataEntries []DataEntry
}

func (s DataEntriesSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s DataEntriesSnapshot) Apply(a SnapshotApplier) error { return a.ApplyDataEntries(s) }

func (s DataEntriesSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_AccountData, error) {
	entries := make([]*g.DataTransactionData_DataEntry, 0, len(s.DataEntries))
	for _, e := range s.DataEntries {
		entries = append(entries, e.ToProtobuf())
	}
	return &g.TransactionStateSnapshot_AccountData{
		Address: s.Address.Body(),
		Entries: entries,
	}, nil
}

func (s DataEntriesSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.AccountData = append(txSnapshots.AccountData, snapshotInProto)
	return nil
}

type AccountScriptSnapshot struct {
	SenderPublicKey    crypto.PublicKey
	Script             Script
	VerifierComplexity uint64
}

func (s AccountScriptSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s AccountScriptSnapshot) Apply(a SnapshotApplier) error { return a.ApplyAccountScript(s) }

func (s AccountScriptSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_AccountScript, error) {
	return &g.TransactionStateSnapshot_AccountScript{
		SenderPublicKey:    s.SenderPublicKey.Bytes(),
		Script:             s.Script,
		VerifierComplexity: int64(s.VerifierComplexity),
	}, nil
}

func (s AccountScriptSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.AccountScripts = append(txSnapshots.AccountScripts, snapshotInProto)
	return nil
}

type AssetScriptSnapshot struct {
	AssetID crypto.Digest
	Script  Script
}

func (s AssetScriptSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s AssetScriptSnapshot) Apply(a SnapshotApplier) error { return a.ApplyAssetScript(s) }

func (s AssetScriptSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_AssetScript, error) {
	return &g.TransactionStateSnapshot_AssetScript{
		AssetId: s.AssetID.Bytes(),
		Script:  s.Script,
	}, nil
}

func (s AssetScriptSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.AssetScripts = append(txSnapshots.AssetScripts, snapshotInProto)
	return nil
}

type LeaseBalanceSnapshot struct {
	Address  WavesAddress
	LeaseIn  uint64
	LeaseOut uint64
}

func (s LeaseBalanceSnapshot) IsGeneratedByTxDiff() bool {
	return true
}

func (s LeaseBalanceSnapshot) Apply(a SnapshotApplier) error { return a.ApplyLeaseBalance(s) }

func (s LeaseBalanceSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_LeaseBalance, error) {
	return &g.TransactionStateSnapshot_LeaseBalance{
		Address: s.Address.Body(),
		In:      int64(s.LeaseIn),
		Out:     int64(s.LeaseOut),
	}, nil
}

func (s LeaseBalanceSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.LeaseBalances = append(txSnapshots.LeaseBalances, snapshotInProto)
	return nil
}

func (s LeaseBalanceSnapshot) IsInternal() bool {
	return false
}

type LeaseStateStatus struct {
	Value               LeaseStatus // can be only LeaseActive or LeaseCanceled
	CancelHeight        Height
	CancelTransactionID *crypto.Digest
}

type LeaseStateSnapshot struct {
	LeaseID             crypto.Digest
	Status              LeaseStateStatus
	Amount              uint64
	Sender              WavesAddress
	Recipient           WavesAddress
	OriginTransactionID *crypto.Digest
	Height              Height
}

func (s LeaseStateSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s LeaseStateSnapshot) Apply(a SnapshotApplier) error { return a.ApplyLeaseState(s) }

func (s LeaseStateSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_LeaseState, error) {
	res := &g.TransactionStateSnapshot_LeaseState{
		LeaseId:             s.LeaseID.Bytes(),
		Status:              nil,
		Amount:              int64(s.Amount),
		Sender:              s.Sender.Body(),
		Recipient:           s.Recipient.Body(),
		OriginTransactionId: s.OriginTransactionID.Bytes(),
		Height:              int32(s.Height),
	}
	switch s.Status.Value {
	case LeaseActive:
		res.Status = &g.TransactionStateSnapshot_LeaseState_Active{}
	case LeaseCanceled:
		res.Status = &g.TransactionStateSnapshot_LeaseState_Cancelled{
			Height:        int32(s.Status.CancelHeight),
			TransactionId: s.Status.CancelTransactionID.Bytes(),
		}
	default:
		return nil, errors.Errorf("Failed to serialize LeaseStateSnapshot to Proto: invalid Lease status")
	}
	return res, nil
}

func (s LeaseStateSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.LeaseStates = append(txSnapshots.LeaseStates, snapshotInProto)
	return nil
}

type SponsorshipSnapshot struct {
	AssetID         crypto.Digest
	MinSponsoredFee uint64
}

func (s SponsorshipSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s SponsorshipSnapshot) Apply(a SnapshotApplier) error { return a.ApplySponsorship(s) }

func (s SponsorshipSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_Sponsorship, error) {
	return &g.TransactionStateSnapshot_Sponsorship{
		AssetId: s.AssetID.Bytes(),
		MinFee:  int64(s.MinSponsoredFee),
	}, nil
}

func (s SponsorshipSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.Sponsorships = append(txSnapshots.Sponsorships, snapshotInProto)
	return nil
}

type AliasSnapshot struct {
	Address WavesAddress
	Alias   Alias
}

func (s AliasSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s AliasSnapshot) Apply(a SnapshotApplier) error { return a.ApplyAlias(s) }

func (s AliasSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_Alias, error) {
	return &g.TransactionStateSnapshot_Alias{
		Address: s.Address.Body(),
		Alias:   s.Alias.Alias,
	}, nil
}

func (s AliasSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.Aliases = append(txSnapshots.Aliases, snapshotInProto)
	return nil
}

// FilledVolumeFeeSnapshot Filled Volume and Fee.
type FilledVolumeFeeSnapshot struct { // OrderFill
	OrderID      crypto.Digest
	FilledVolume uint64
	FilledFee    uint64
}

func (s FilledVolumeFeeSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s FilledVolumeFeeSnapshot) Apply(a SnapshotApplier) error { return a.ApplyFilledVolumeAndFee(s) }

func (s FilledVolumeFeeSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_OrderFill, error) {
	return &g.TransactionStateSnapshot_OrderFill{
		OrderId: s.OrderID.Bytes(),
		Volume:  int64(s.FilledVolume),
		Fee:     int64(s.FilledFee),
	}, nil
}

func (s FilledVolumeFeeSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.OrderFills = append(txSnapshots.OrderFills, snapshotInProto)
	return nil
}

type StaticAssetInfoSnapshot struct {
	AssetID             crypto.Digest
	SourceTransactionID crypto.Digest
	IssuerPublicKey     crypto.PublicKey
	Decimals            uint8
	IsNFT               bool
}

func (s StaticAssetInfoSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s StaticAssetInfoSnapshot) Apply(a SnapshotApplier) error { return a.ApplyStaticAssetInfo(s) }

func (s StaticAssetInfoSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_AssetStatic, error) {
	return &g.TransactionStateSnapshot_AssetStatic{
		AssetId:             s.AssetID.Bytes(),
		SourceTransactionId: s.SourceTransactionID.Bytes(),
		IssuerPublicKey:     s.IssuerPublicKey.Bytes(),
		Decimals:            int32(s.Decimals),
		Nft:                 s.IsNFT,
	}, nil
}

func (s StaticAssetInfoSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.AssetStatics = append(txSnapshots.AssetStatics, snapshotInProto)
	return nil
}

type AssetVolumeSnapshot struct { // AssetVolume in pb
	AssetID       crypto.Digest
	TotalQuantity big.Int // volume in protobuf
	IsReissuable  bool
}

func (s AssetVolumeSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s AssetVolumeSnapshot) Apply(a SnapshotApplier) error { return a.ApplyAssetVolume(s) }

func (s AssetVolumeSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_AssetVolume, error) {
	return &g.TransactionStateSnapshot_AssetVolume{
		AssetId:    s.AssetID.Bytes(),
		Reissuable: s.IsReissuable,
		Volume:     s.TotalQuantity.Bytes(),
	}, nil
}

func (s AssetVolumeSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.AssetVolumes = append(txSnapshots.AssetVolumes, snapshotInProto)
	return nil
}

type AssetDescriptionSnapshot struct { // AssetNameAndDescription in pb
	AssetID          crypto.Digest
	AssetName        string
	AssetDescription string
	ChangeHeight     Height // last_updated in pb
}

func (s AssetDescriptionSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s AssetDescriptionSnapshot) Apply(a SnapshotApplier) error { return a.ApplyAssetDescription(s) }

func (s AssetDescriptionSnapshot) ToProtobuf() (*g.TransactionStateSnapshot_AssetNameAndDescription, error) {
	return &g.TransactionStateSnapshot_AssetNameAndDescription{
		AssetId:     s.AssetID.Bytes(),
		Name:        s.AssetName,
		Description: s.AssetDescription,
		LastUpdated: int32(s.ChangeHeight),
	}, nil
}

func (s AssetDescriptionSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	snapshotInProto, err := s.ToProtobuf()
	if err != nil {
		return err
	}
	txSnapshots.AssetNamesAndDescriptions = append(txSnapshots.AssetNamesAndDescriptions, snapshotInProto)
	return nil
}

type TransactionStatusSnapshot struct {
	TransactionID crypto.Digest
	Status        TransactionStatus
}

func (s TransactionStatusSnapshot) Apply(a SnapshotApplier) error {
	return a.ApplyTransactionsStatus(s)
}

func (s TransactionStatusSnapshot) IsGeneratedByTxDiff() bool {
	return false
}

func (s TransactionStatusSnapshot) AppendToProtobuf(txSnapshots *g.TransactionStateSnapshot) error {
	switch s.Status {
	case TransactionSucceeded:
		txSnapshots.TransactionStatus = g.TransactionStatus_SUCCEEDED
	case TransactionElided:
		txSnapshots.TransactionStatus = g.TransactionStatus_ELIDED
	case TransactionFailed:
		txSnapshots.TransactionStatus = g.TransactionStatus_FAILED
	default:
		return errors.Errorf("Undefined tx status %d", s.Status)
	}
	return nil
}

type SnapshotApplier interface {
	ApplyWavesBalance(snapshot WavesBalanceSnapshot) error
	ApplyLeaseBalance(snapshot LeaseBalanceSnapshot) error
	ApplyAssetBalance(snapshot AssetBalanceSnapshot) error
	ApplyAlias(snapshot AliasSnapshot) error
	ApplyStaticAssetInfo(snapshot StaticAssetInfoSnapshot) error
	ApplyAssetDescription(snapshot AssetDescriptionSnapshot) error
	ApplyAssetVolume(snapshot AssetVolumeSnapshot) error
	ApplyAssetScript(snapshot AssetScriptSnapshot) error
	ApplySponsorship(snapshot SponsorshipSnapshot) error
	ApplyAccountScript(snapshot AccountScriptSnapshot) error
	ApplyFilledVolumeAndFee(snapshot FilledVolumeFeeSnapshot) error
	ApplyDataEntries(snapshot DataEntriesSnapshot) error
	ApplyLeaseState(snapshot LeaseStateSnapshot) error
	ApplyTransactionsStatus(snapshot TransactionStatusSnapshot) error
}
