// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package peer

import (
	"github.com/wavesplatform/gowaves/pkg/p2p/conn"
	"github.com/wavesplatform/gowaves/pkg/proto"
	"sync"
)

// Ensure, that mockPeer does implement Peer.
// If this is not the case, regenerate this file with moq.
var _ Peer = &mockPeer{}

// mockPeer is a mock implementation of Peer.
//
//	func TestSomethingThatUsesPeer(t *testing.T) {
//
//		// make and configure a mocked Peer
//		mockedPeer := &mockPeer{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ConnectionFunc: func() conn.Connection {
//				panic("mock out the Connection method")
//			},
//			DirectionFunc: func() Direction {
//				panic("mock out the Direction method")
//			},
//			HandshakeFunc: func() proto.Handshake {
//				panic("mock out the Handshake method")
//			},
//			IDFunc: func() ID {
//				panic("mock out the ID method")
//			},
//			RemoteAddrFunc: func() proto.TCPAddr {
//				panic("mock out the RemoteAddr method")
//			},
//			SendMessageFunc: func(message proto.Message)  {
//				panic("mock out the SendMessage method")
//			},
//		}
//
//		// use mockedPeer in code that requires Peer
//		// and then make assertions.
//
//	}
type mockPeer struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConnectionFunc mocks the Connection method.
	ConnectionFunc func() conn.Connection

	// DirectionFunc mocks the Direction method.
	DirectionFunc func() Direction

	// HandshakeFunc mocks the Handshake method.
	HandshakeFunc func() proto.Handshake

	// IDFunc mocks the ID method.
	IDFunc func() ID

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() proto.TCPAddr

	// SendMessageFunc mocks the SendMessage method.
	SendMessageFunc func(message proto.Message)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Connection holds details about calls to the Connection method.
		Connection []struct {
		}
		// Direction holds details about calls to the Direction method.
		Direction []struct {
		}
		// Handshake holds details about calls to the Handshake method.
		Handshake []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
		// SendMessage holds details about calls to the SendMessage method.
		SendMessage []struct {
			// Message is the message argument value.
			Message proto.Message
		}
	}
	lockClose       sync.RWMutex
	lockConnection  sync.RWMutex
	lockDirection   sync.RWMutex
	lockHandshake   sync.RWMutex
	lockID          sync.RWMutex
	lockRemoteAddr  sync.RWMutex
	lockSendMessage sync.RWMutex
}

// Close calls CloseFunc.
func (mock *mockPeer) Close() error {
	if mock.CloseFunc == nil {
		panic("mockPeer.CloseFunc: method is nil but Peer.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedPeer.CloseCalls())
func (mock *mockPeer) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Connection calls ConnectionFunc.
func (mock *mockPeer) Connection() conn.Connection {
	if mock.ConnectionFunc == nil {
		panic("mockPeer.ConnectionFunc: method is nil but Peer.Connection was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConnection.Lock()
	mock.calls.Connection = append(mock.calls.Connection, callInfo)
	mock.lockConnection.Unlock()
	return mock.ConnectionFunc()
}

// ConnectionCalls gets all the calls that were made to Connection.
// Check the length with:
//
//	len(mockedPeer.ConnectionCalls())
func (mock *mockPeer) ConnectionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConnection.RLock()
	calls = mock.calls.Connection
	mock.lockConnection.RUnlock()
	return calls
}

// Direction calls DirectionFunc.
func (mock *mockPeer) Direction() Direction {
	if mock.DirectionFunc == nil {
		panic("mockPeer.DirectionFunc: method is nil but Peer.Direction was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDirection.Lock()
	mock.calls.Direction = append(mock.calls.Direction, callInfo)
	mock.lockDirection.Unlock()
	return mock.DirectionFunc()
}

// DirectionCalls gets all the calls that were made to Direction.
// Check the length with:
//
//	len(mockedPeer.DirectionCalls())
func (mock *mockPeer) DirectionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDirection.RLock()
	calls = mock.calls.Direction
	mock.lockDirection.RUnlock()
	return calls
}

// Handshake calls HandshakeFunc.
func (mock *mockPeer) Handshake() proto.Handshake {
	if mock.HandshakeFunc == nil {
		panic("mockPeer.HandshakeFunc: method is nil but Peer.Handshake was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHandshake.Lock()
	mock.calls.Handshake = append(mock.calls.Handshake, callInfo)
	mock.lockHandshake.Unlock()
	return mock.HandshakeFunc()
}

// HandshakeCalls gets all the calls that were made to Handshake.
// Check the length with:
//
//	len(mockedPeer.HandshakeCalls())
func (mock *mockPeer) HandshakeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHandshake.RLock()
	calls = mock.calls.Handshake
	mock.lockHandshake.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *mockPeer) ID() ID {
	if mock.IDFunc == nil {
		panic("mockPeer.IDFunc: method is nil but Peer.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedPeer.IDCalls())
func (mock *mockPeer) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *mockPeer) RemoteAddr() proto.TCPAddr {
	if mock.RemoteAddrFunc == nil {
		panic("mockPeer.RemoteAddrFunc: method is nil but Peer.RemoteAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedPeer.RemoteAddrCalls())
func (mock *mockPeer) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}

// SendMessage calls SendMessageFunc.
func (mock *mockPeer) SendMessage(message proto.Message) {
	if mock.SendMessageFunc == nil {
		panic("mockPeer.SendMessageFunc: method is nil but Peer.SendMessage was just called")
	}
	callInfo := struct {
		Message proto.Message
	}{
		Message: message,
	}
	mock.lockSendMessage.Lock()
	mock.calls.SendMessage = append(mock.calls.SendMessage, callInfo)
	mock.lockSendMessage.Unlock()
	mock.SendMessageFunc(message)
}

// SendMessageCalls gets all the calls that were made to SendMessage.
// Check the length with:
//
//	len(mockedPeer.SendMessageCalls())
func (mock *mockPeer) SendMessageCalls() []struct {
	Message proto.Message
} {
	var calls []struct {
		Message proto.Message
	}
	mock.lockSendMessage.RLock()
	calls = mock.calls.SendMessage
	mock.lockSendMessage.RUnlock()
	return calls
}
