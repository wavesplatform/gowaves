// Code generated by ride/generate/main.go. DO NOT EDIT.

package ride

import (
	"github.com/pkg/errors"
	"strings"
)

const (
	assetTypeName                       = "Asset"
	assetPairTypeName                   = "AssetPair"
	attachedPaymentTypeName             = "AttachedPayment"
	balanceDetailsTypeName              = "BalanceDetails"
	binaryEntryTypeName                 = "BinaryEntry"
	blockInfoTypeName                   = "BlockInfo"
	booleanEntryTypeName                = "BooleanEntry"
	burnTypeName                        = "Burn"
	burnTransactionTypeName             = "BurnTransaction"
	createAliasTransactionTypeName      = "CreateAliasTransaction"
	dataEntryTypeName                   = "DataEntry"
	dataTransactionTypeName             = "DataTransaction"
	deleteEntryTypeName                 = "DeleteEntry"
	exchangeTransactionTypeName         = "ExchangeTransaction"
	genesisTransactionTypeName          = "GenesisTransaction"
	integerEntryTypeName                = "IntegerEntry"
	invocationTypeName                  = "Invocation"
	invokeExpressionTransactionTypeName = "InvokeExpressionTransaction"
	invokeScriptTransactionTypeName     = "InvokeScriptTransaction"
	issueTypeName                       = "Issue"
	issueTransactionTypeName            = "IssueTransaction"
	leaseTypeName                       = "Lease"
	leaseCancelTypeName                 = "LeaseCancel"
	leaseCancelTransactionTypeName      = "LeaseCancelTransaction"
	leaseTransactionTypeName            = "LeaseTransaction"
	massTransferTransactionTypeName     = "MassTransferTransaction"
	orderTypeName                       = "Order"
	paymentTransactionTypeName          = "PaymentTransaction"
	reissueTypeName                     = "Reissue"
	reissueTransactionTypeName          = "ReissueTransaction"
	scriptResultTypeName                = "ScriptResult"
	scriptTransferTypeName              = "ScriptTransfer"
	setAssetScriptTransactionTypeName   = "SetAssetScriptTransaction"
	setScriptTransactionTypeName        = "SetScriptTransaction"
	sponsorFeeTypeName                  = "SponsorFee"
	sponsorFeeTransactionTypeName       = "SponsorFeeTransaction"
	stringEntryTypeName                 = "StringEntry"
	transferTypeName                    = "Transfer"
	transferSetTypeName                 = "TransferSet"
	transferTransactionTypeName         = "TransferTransaction"
	updateAssetInfoTransactionTypeName  = "UpdateAssetInfoTransaction"
	writeSetTypeName                    = "WriteSet"
)

const (
	aliasField                 = "alias"
	amountField                = "amount"
	amountAssetField           = "amountAsset"
	argsField                  = "args"
	assetField                 = "asset"
	assetIDField               = "assetId"
	assetPairField             = "assetPair"
	attachmentField            = "attachment"
	availableField             = "available"
	baseTargetField            = "baseTarget"
	bodyBytesField             = "bodyBytes"
	buyMatcherFeeField         = "buyMatcherFee"
	buyOrderField              = "buyOrder"
	callerField                = "caller"
	callerPublicKeyField       = "callerPublicKey"
	compiledScriptField        = "compiledScript"
	dAppField                  = "dApp"
	dataField                  = "data"
	decimalsField              = "decimals"
	descriptionField           = "description"
	effectiveField             = "effective"
	expirationField            = "expiration"
	expressionField            = "expression"
	feeField                   = "fee"
	feeAssetIDField            = "feeAssetId"
	functionField              = "function"
	generatingField            = "generating"
	generationSignatureField   = "generationSignature"
	generatorField             = "generator"
	generatorPublicKeyField    = "generatorPublicKey"
	heightField                = "height"
	idField                    = "id"
	isReissuableField          = "isReissuable"
	issuerField                = "issuer"
	issuerPublicKeyField       = "issuerPublicKey"
	keyField                   = "key"
	leaseIDField               = "leaseId"
	matcherFeeField            = "matcherFee"
	matcherFeeAssetIDField     = "matcherFeeAssetId"
	matcherPublicKeyField      = "matcherPublicKey"
	minSponsoredAssetFeeField  = "minSponsoredAssetFee"
	minSponsoredFeeField       = "minSponsoredFee"
	nameField                  = "name"
	nonceField                 = "nonce"
	orderTypeField             = "orderType"
	originCallerField          = "originCaller"
	originCallerPublicKeyField = "originCallerPublicKey"
	paymentField               = "payment"
	paymentsField              = "payments"
	priceField                 = "price"
	priceAssetField            = "priceAsset"
	proofsField                = "proofs"
	quantityField              = "quantity"
	recipientField             = "recipient"
	regularField               = "regular"
	reissuableField            = "reissuable"
	rewardsField               = "rewards"
	scriptField                = "script"
	scriptedField              = "scripted"
	sellMatcherFeeField        = "sellMatcherFee"
	sellOrderField             = "sellOrder"
	senderField                = "sender"
	senderPublicKeyField       = "senderPublicKey"
	sponsoredField             = "sponsored"
	timestampField             = "timestamp"
	totalAmountField           = "totalAmount"
	transactionIDField         = "transactionId"
	transferCountField         = "transferCount"
	transferSetField           = "transferSet"
	transfersField             = "transfers"
	valueField                 = "value"
	versionField               = "version"
	vrfField                   = "vrf"
	writeSetField              = "writeSet"
)

type rideAssetV3 struct {
	issuerPublicKey rideByteVector
	id              rideByteVector
	quantity        rideInt
	decimals        rideInt
	issuer          rideAddress
	scripted        rideBoolean
	sponsored       rideBoolean
	reissuable      rideBoolean
}

func newRideAssetV3(issuerPublicKey rideByteVector, id rideByteVector, quantity rideInt, decimals rideInt, issuer rideAddress, scripted rideBoolean, sponsored rideBoolean, reissuable rideBoolean) rideAssetV3 {
	return rideAssetV3{
		issuerPublicKey: issuerPublicKey,
		id:              id,
		quantity:        quantity,
		decimals:        decimals,
		issuer:          issuer,
		scripted:        scripted,
		sponsored:       sponsored,
		reissuable:      reissuable,
	}
}

func (o rideAssetV3) instanceOf() string {
	return "Asset"
}

func (o rideAssetV3) eq(other rideType) bool {
	if oo, ok := other.(rideAssetV3); ok {
		if !o.issuerPublicKey.eq(oo.issuerPublicKey) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.issuer.eq(oo.issuer) {
			return false
		}
		if !o.scripted.eq(oo.scripted) {
			return false
		}
		if !o.sponsored.eq(oo.sponsored) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideAssetV3) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Asset"), nil
	case "issuerPublicKey":
		return o.issuerPublicKey, nil
	case "id":
		return o.id, nil
	case "quantity":
		return o.quantity, nil
	case "decimals":
		return o.decimals, nil
	case "issuer":
		return o.issuer, nil
	case "scripted":
		return o.scripted, nil
	case "sponsored":
		return o.sponsored, nil
	case "reissuable":
		return o.reissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAssetV3) copy() rideType {
	return newRideAssetV3(o.issuerPublicKey, o.id, o.quantity, o.decimals, o.issuer, o.scripted, o.sponsored, o.reissuable)
}

func (o rideAssetV3) lines() []string {
	r := make([]string, 0, 10)
	r = append(r, "Asset(")
	r = append(r, fieldLines("issuer", o.issuer.lines())...)
	r = append(r, fieldLines("scripted", o.scripted.lines())...)
	r = append(r, fieldLines("issuerPublicKey", o.issuerPublicKey.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("decimals", o.decimals.lines())...)
	r = append(r, fieldLines("reissuable", o.reissuable.lines())...)
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, fieldLines("sponsored", o.sponsored.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAssetV3) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideAssetV4 struct {
	description     rideString
	name            rideString
	issuerPublicKey rideByteVector
	id              rideByteVector
	minSponsoredFee rideType
	decimals        rideInt
	quantity        rideInt
	issuer          rideAddress
	reissuable      rideBoolean
	scripted        rideBoolean
}

func newRideAssetV4(description rideString, name rideString, issuerPublicKey rideByteVector, id rideByteVector, minSponsoredFee rideType, decimals rideInt, quantity rideInt, issuer rideAddress, reissuable rideBoolean, scripted rideBoolean) rideAssetV4 {
	return rideAssetV4{
		description:     description,
		name:            name,
		issuerPublicKey: issuerPublicKey,
		id:              id,
		minSponsoredFee: minSponsoredFee,
		decimals:        decimals,
		quantity:        quantity,
		issuer:          issuer,
		reissuable:      reissuable,
		scripted:        scripted,
	}
}

func (o rideAssetV4) instanceOf() string {
	return "Asset"
}

func (o rideAssetV4) eq(other rideType) bool {
	if oo, ok := other.(rideAssetV4); ok {
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.issuerPublicKey.eq(oo.issuerPublicKey) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.minSponsoredFee.eq(oo.minSponsoredFee) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.issuer.eq(oo.issuer) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		if !o.scripted.eq(oo.scripted) {
			return false
		}
		return true
	}
	return false
}

func (o rideAssetV4) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Asset"), nil
	case "description":
		return o.description, nil
	case "name":
		return o.name, nil
	case "issuerPublicKey":
		return o.issuerPublicKey, nil
	case "id":
		return o.id, nil
	case "minSponsoredFee":
		return o.minSponsoredFee, nil
	case "decimals":
		return o.decimals, nil
	case "quantity":
		return o.quantity, nil
	case "issuer":
		return o.issuer, nil
	case "reissuable":
		return o.reissuable, nil
	case "scripted":
		return o.scripted, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAssetV4) copy() rideType {
	return newRideAssetV4(o.description, o.name, o.issuerPublicKey, o.id, o.minSponsoredFee, o.decimals, o.quantity, o.issuer, o.reissuable, o.scripted)
}

func (o rideAssetV4) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "Asset(")
	r = append(r, fieldLines("description", o.description.lines())...)
	r = append(r, fieldLines("issuer", o.issuer.lines())...)
	r = append(r, fieldLines("scripted", o.scripted.lines())...)
	r = append(r, fieldLines("issuerPublicKey", o.issuerPublicKey.lines())...)
	r = append(r, fieldLines("minSponsoredFee", o.minSponsoredFee.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("decimals", o.decimals.lines())...)
	r = append(r, fieldLines("reissuable", o.reissuable.lines())...)
	r = append(r, fieldLines("name", o.name.lines())...)
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAssetV4) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideAssetPair struct {
	amountAsset rideType
	priceAsset  rideType
}

func newRideAssetPair(amountAsset rideType, priceAsset rideType) rideAssetPair {
	return rideAssetPair{
		amountAsset: amountAsset,
		priceAsset:  priceAsset,
	}
}

func (o rideAssetPair) instanceOf() string {
	return "AssetPair"
}

func (o rideAssetPair) eq(other rideType) bool {
	if oo, ok := other.(rideAssetPair); ok {
		if !o.amountAsset.eq(oo.amountAsset) {
			return false
		}
		if !o.priceAsset.eq(oo.priceAsset) {
			return false
		}
		return true
	}
	return false
}

func (o rideAssetPair) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("AssetPair"), nil
	case "amountAsset":
		return o.amountAsset, nil
	case "priceAsset":
		return o.priceAsset, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAssetPair) copy() rideType {
	return newRideAssetPair(o.amountAsset, o.priceAsset)
}

func (o rideAssetPair) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "AssetPair(")
	r = append(r, fieldLines("amountAsset", o.amountAsset.lines())...)
	r = append(r, fieldLines("priceAsset", o.priceAsset.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAssetPair) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideAttachedPayment struct {
	assetId rideType
	amount  rideInt
}

func newRideAttachedPayment(assetId rideType, amount rideInt) rideAttachedPayment {
	return rideAttachedPayment{
		assetId: assetId,
		amount:  amount,
	}
}

func (o rideAttachedPayment) instanceOf() string {
	return "AttachedPayment"
}

func (o rideAttachedPayment) eq(other rideType) bool {
	if oo, ok := other.(rideAttachedPayment); ok {
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		return true
	}
	return false
}

func (o rideAttachedPayment) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("AttachedPayment"), nil
	case "assetId":
		return o.assetId, nil
	case "amount":
		return o.amount, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAttachedPayment) copy() rideType {
	return newRideAttachedPayment(o.assetId, o.amount)
}

func (o rideAttachedPayment) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "AttachedPayment(")
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAttachedPayment) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBalanceDetails struct {
	available  rideInt
	regular    rideInt
	generating rideInt
	effective  rideInt
}

func newRideBalanceDetails(available rideInt, regular rideInt, generating rideInt, effective rideInt) rideBalanceDetails {
	return rideBalanceDetails{
		available:  available,
		regular:    regular,
		generating: generating,
		effective:  effective,
	}
}

func (o rideBalanceDetails) instanceOf() string {
	return "BalanceDetails"
}

func (o rideBalanceDetails) eq(other rideType) bool {
	if oo, ok := other.(rideBalanceDetails); ok {
		if !o.available.eq(oo.available) {
			return false
		}
		if !o.regular.eq(oo.regular) {
			return false
		}
		if !o.generating.eq(oo.generating) {
			return false
		}
		if !o.effective.eq(oo.effective) {
			return false
		}
		return true
	}
	return false
}

func (o rideBalanceDetails) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BalanceDetails"), nil
	case "available":
		return o.available, nil
	case "regular":
		return o.regular, nil
	case "generating":
		return o.generating, nil
	case "effective":
		return o.effective, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBalanceDetails) copy() rideType {
	return newRideBalanceDetails(o.available, o.regular, o.generating, o.effective)
}

func (o rideBalanceDetails) lines() []string {
	r := make([]string, 0, 6)
	r = append(r, "BalanceDetails(")
	r = append(r, fieldLines("available", o.available.lines())...)
	r = append(r, fieldLines("regular", o.regular.lines())...)
	r = append(r, fieldLines("generating", o.generating.lines())...)
	r = append(r, fieldLines("effective", o.effective.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBalanceDetails) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBinaryEntry struct {
	key   rideString
	value rideByteVector
}

func newRideBinaryEntry(key rideString, value rideByteVector) rideBinaryEntry {
	return rideBinaryEntry{
		key:   key,
		value: value,
	}
}

func (o rideBinaryEntry) instanceOf() string {
	return "BinaryEntry"
}

func (o rideBinaryEntry) eq(other rideType) bool {
	if oo, ok := other.(rideBinaryEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideBinaryEntry) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BinaryEntry"), nil
	case "key":
		return o.key, nil
	case "value":
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBinaryEntry) copy() rideType {
	return newRideBinaryEntry(o.key, o.value)
}

func (o rideBinaryEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "BinaryEntry(")
	r = append(r, fieldLines("key", o.key.lines())...)
	r = append(r, fieldLines("value", o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBinaryEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBlockInfoV3 struct {
	generationSignature rideByteVector
	generatorPublicKey  rideByteVector
	baseTarget          rideInt
	timestamp           rideInt
	height              rideInt
	generator           rideAddress
}

func newRideBlockInfoV3(generationSignature rideByteVector, generatorPublicKey rideByteVector, baseTarget rideInt, timestamp rideInt, height rideInt, generator rideAddress) rideBlockInfoV3 {
	return rideBlockInfoV3{
		generationSignature: generationSignature,
		generatorPublicKey:  generatorPublicKey,
		baseTarget:          baseTarget,
		timestamp:           timestamp,
		height:              height,
		generator:           generator,
	}
}

func (o rideBlockInfoV3) instanceOf() string {
	return "BlockInfo"
}

func (o rideBlockInfoV3) eq(other rideType) bool {
	if oo, ok := other.(rideBlockInfoV3); ok {
		if !o.generationSignature.eq(oo.generationSignature) {
			return false
		}
		if !o.generatorPublicKey.eq(oo.generatorPublicKey) {
			return false
		}
		if !o.baseTarget.eq(oo.baseTarget) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.height.eq(oo.height) {
			return false
		}
		if !o.generator.eq(oo.generator) {
			return false
		}
		return true
	}
	return false
}

func (o rideBlockInfoV3) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BlockInfo"), nil
	case "generationSignature":
		return o.generationSignature, nil
	case "generatorPublicKey":
		return o.generatorPublicKey, nil
	case "baseTarget":
		return o.baseTarget, nil
	case "timestamp":
		return o.timestamp, nil
	case "height":
		return o.height, nil
	case "generator":
		return o.generator, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBlockInfoV3) copy() rideType {
	return newRideBlockInfoV3(o.generationSignature, o.generatorPublicKey, o.baseTarget, o.timestamp, o.height, o.generator)
}

func (o rideBlockInfoV3) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, "BlockInfo(")
	r = append(r, fieldLines("baseTarget", o.baseTarget.lines())...)
	r = append(r, fieldLines("generator", o.generator.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("height", o.height.lines())...)
	r = append(r, fieldLines("generationSignature", o.generationSignature.lines())...)
	r = append(r, fieldLines("generatorPublicKey", o.generatorPublicKey.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBlockInfoV3) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBlockInfoV4 struct {
	vrf                 rideType
	generationSignature rideByteVector
	generatorPublicKey  rideByteVector
	baseTarget          rideInt
	timestamp           rideInt
	height              rideInt
	generator           rideAddress
}

func newRideBlockInfoV4(vrf rideType, generationSignature rideByteVector, generatorPublicKey rideByteVector, baseTarget rideInt, timestamp rideInt, height rideInt, generator rideAddress) rideBlockInfoV4 {
	return rideBlockInfoV4{
		vrf:                 vrf,
		generationSignature: generationSignature,
		generatorPublicKey:  generatorPublicKey,
		baseTarget:          baseTarget,
		timestamp:           timestamp,
		height:              height,
		generator:           generator,
	}
}

func (o rideBlockInfoV4) instanceOf() string {
	return "BlockInfo"
}

func (o rideBlockInfoV4) eq(other rideType) bool {
	if oo, ok := other.(rideBlockInfoV4); ok {
		if !o.vrf.eq(oo.vrf) {
			return false
		}
		if !o.generationSignature.eq(oo.generationSignature) {
			return false
		}
		if !o.generatorPublicKey.eq(oo.generatorPublicKey) {
			return false
		}
		if !o.baseTarget.eq(oo.baseTarget) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.height.eq(oo.height) {
			return false
		}
		if !o.generator.eq(oo.generator) {
			return false
		}
		return true
	}
	return false
}

func (o rideBlockInfoV4) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BlockInfo"), nil
	case "vrf":
		return o.vrf, nil
	case "generationSignature":
		return o.generationSignature, nil
	case "generatorPublicKey":
		return o.generatorPublicKey, nil
	case "baseTarget":
		return o.baseTarget, nil
	case "timestamp":
		return o.timestamp, nil
	case "height":
		return o.height, nil
	case "generator":
		return o.generator, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBlockInfoV4) copy() rideType {
	return newRideBlockInfoV4(o.vrf, o.generationSignature, o.generatorPublicKey, o.baseTarget, o.timestamp, o.height, o.generator)
}

func (o rideBlockInfoV4) lines() []string {
	r := make([]string, 0, 9)
	r = append(r, "BlockInfo(")
	r = append(r, fieldLines("baseTarget", o.baseTarget.lines())...)
	r = append(r, fieldLines("generator", o.generator.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("vrf", o.vrf.lines())...)
	r = append(r, fieldLines("height", o.height.lines())...)
	r = append(r, fieldLines("generationSignature", o.generationSignature.lines())...)
	r = append(r, fieldLines("generatorPublicKey", o.generatorPublicKey.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBlockInfoV4) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBlockInfoV7 struct {
	vrf                 rideType
	generationSignature rideByteVector
	generatorPublicKey  rideByteVector
	baseTarget          rideInt
	timestamp           rideInt
	height              rideInt
	generator           rideAddress
	rewards             rideList
}

func newRideBlockInfoV7(vrf rideType, generationSignature rideByteVector, generatorPublicKey rideByteVector, baseTarget rideInt, timestamp rideInt, height rideInt, generator rideAddress, rewards rideList) rideBlockInfoV7 {
	return rideBlockInfoV7{
		vrf:                 vrf,
		generationSignature: generationSignature,
		generatorPublicKey:  generatorPublicKey,
		baseTarget:          baseTarget,
		timestamp:           timestamp,
		height:              height,
		generator:           generator,
		rewards:             rewards,
	}
}

func (o rideBlockInfoV7) instanceOf() string {
	return "BlockInfo"
}

func (o rideBlockInfoV7) eq(other rideType) bool {
	if oo, ok := other.(rideBlockInfoV7); ok {
		if !o.vrf.eq(oo.vrf) {
			return false
		}
		if !o.generationSignature.eq(oo.generationSignature) {
			return false
		}
		if !o.generatorPublicKey.eq(oo.generatorPublicKey) {
			return false
		}
		if !o.baseTarget.eq(oo.baseTarget) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.height.eq(oo.height) {
			return false
		}
		if !o.generator.eq(oo.generator) {
			return false
		}
		if !o.rewards.eq(oo.rewards) {
			return false
		}
		return true
	}
	return false
}

func (o rideBlockInfoV7) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BlockInfo"), nil
	case "vrf":
		return o.vrf, nil
	case "generationSignature":
		return o.generationSignature, nil
	case "generatorPublicKey":
		return o.generatorPublicKey, nil
	case "baseTarget":
		return o.baseTarget, nil
	case "timestamp":
		return o.timestamp, nil
	case "height":
		return o.height, nil
	case "generator":
		return o.generator, nil
	case "rewards":
		return o.rewards, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBlockInfoV7) copy() rideType {
	return newRideBlockInfoV7(o.vrf, o.generationSignature, o.generatorPublicKey, o.baseTarget, o.timestamp, o.height, o.generator, o.rewards)
}

func (o rideBlockInfoV7) lines() []string {
	r := make([]string, 0, 10)
	r = append(r, "BlockInfo(")
	r = append(r, fieldLines("baseTarget", o.baseTarget.lines())...)
	r = append(r, fieldLines("generator", o.generator.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("vrf", o.vrf.lines())...)
	r = append(r, fieldLines("height", o.height.lines())...)
	r = append(r, fieldLines("generationSignature", o.generationSignature.lines())...)
	r = append(r, fieldLines("generatorPublicKey", o.generatorPublicKey.lines())...)
	r = append(r, fieldLines("rewards", o.rewards.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBlockInfoV7) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBooleanEntry struct {
	key   rideString
	value rideBoolean
}

func newRideBooleanEntry(key rideString, value rideBoolean) rideBooleanEntry {
	return rideBooleanEntry{
		key:   key,
		value: value,
	}
}

func (o rideBooleanEntry) instanceOf() string {
	return "BooleanEntry"
}

func (o rideBooleanEntry) eq(other rideType) bool {
	if oo, ok := other.(rideBooleanEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideBooleanEntry) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BooleanEntry"), nil
	case "key":
		return o.key, nil
	case "value":
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBooleanEntry) copy() rideType {
	return newRideBooleanEntry(o.key, o.value)
}

func (o rideBooleanEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "BooleanEntry(")
	r = append(r, fieldLines("key", o.key.lines())...)
	r = append(r, fieldLines("value", o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBooleanEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBurn struct {
	assetId  rideByteVector
	quantity rideInt
}

func newRideBurn(assetId rideByteVector, quantity rideInt) rideBurn {
	return rideBurn{
		assetId:  assetId,
		quantity: quantity,
	}
}

func (o rideBurn) instanceOf() string {
	return "Burn"
}

func (o rideBurn) eq(other rideType) bool {
	if oo, ok := other.(rideBurn); ok {
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		return true
	}
	return false
}

func (o rideBurn) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Burn"), nil
	case "assetId":
		return o.assetId, nil
	case "quantity":
		return o.quantity, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBurn) copy() rideType {
	return newRideBurn(o.assetId, o.quantity)
}

func (o rideBurn) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "Burn(")
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBurn) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideDataEntry struct {
	value rideType
	key   rideString
}

func newRideDataEntry(value rideType, key rideString) rideDataEntry {
	return rideDataEntry{
		value: value,
		key:   key,
	}
}

func (o rideDataEntry) instanceOf() string {
	return "DataEntry"
}

func (o rideDataEntry) eq(other rideType) bool {
	if oo, ok := other.(rideDataEntry); ok {
		if !o.value.eq(oo.value) {
			return false
		}
		if !o.key.eq(oo.key) {
			return false
		}
		return true
	}
	return false
}

func (o rideDataEntry) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("DataEntry"), nil
	case "value":
		return o.value, nil
	case "key":
		return o.key, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideDataEntry) copy() rideType {
	return newRideDataEntry(o.value, o.key)
}

func (o rideDataEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "DataEntry(")
	r = append(r, fieldLines("key", o.key.lines())...)
	r = append(r, fieldLines("value", o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideDataEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideDeleteEntry struct {
	key rideString
}

func newRideDeleteEntry(key rideString) rideDeleteEntry {
	return rideDeleteEntry{
		key: key,
	}
}

func (o rideDeleteEntry) instanceOf() string {
	return "DeleteEntry"
}

func (o rideDeleteEntry) eq(other rideType) bool {
	if oo, ok := other.(rideDeleteEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		return true
	}
	return false
}

func (o rideDeleteEntry) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("DeleteEntry"), nil
	case "key":
		return o.key, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideDeleteEntry) copy() rideType {
	return newRideDeleteEntry(o.key)
}

func (o rideDeleteEntry) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, "DeleteEntry(")
	r = append(r, fieldLines("key", o.key.lines())...)
	r = append(r, ")")
	return r
}

func (o rideDeleteEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideIntegerEntry struct {
	key   rideString
	value rideInt
}

func newRideIntegerEntry(key rideString, value rideInt) rideIntegerEntry {
	return rideIntegerEntry{
		key:   key,
		value: value,
	}
}

func (o rideIntegerEntry) instanceOf() string {
	return "IntegerEntry"
}

func (o rideIntegerEntry) eq(other rideType) bool {
	if oo, ok := other.(rideIntegerEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideIntegerEntry) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("IntegerEntry"), nil
	case "key":
		return o.key, nil
	case "value":
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideIntegerEntry) copy() rideType {
	return newRideIntegerEntry(o.key, o.value)
}

func (o rideIntegerEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "IntegerEntry(")
	r = append(r, fieldLines("key", o.key.lines())...)
	r = append(r, fieldLines("value", o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideIntegerEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvocationV3 struct {
	payment         rideType
	callerPublicKey rideByteVector
	feeAssetId      rideType
	transactionId   rideByteVector
	caller          rideAddress
	fee             rideInt
}

func newRideInvocationV3(payment rideType, callerPublicKey rideByteVector, feeAssetId rideType, transactionId rideByteVector, caller rideAddress, fee rideInt) rideInvocationV3 {
	return rideInvocationV3{
		payment:         payment,
		callerPublicKey: callerPublicKey,
		feeAssetId:      feeAssetId,
		transactionId:   transactionId,
		caller:          caller,
		fee:             fee,
	}
}

func (o rideInvocationV3) instanceOf() string {
	return "Invocation"
}

func (o rideInvocationV3) eq(other rideType) bool {
	if oo, ok := other.(rideInvocationV3); ok {
		if !o.payment.eq(oo.payment) {
			return false
		}
		if !o.callerPublicKey.eq(oo.callerPublicKey) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.transactionId.eq(oo.transactionId) {
			return false
		}
		if !o.caller.eq(oo.caller) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvocationV3) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Invocation"), nil
	case "payment":
		return o.payment, nil
	case "callerPublicKey":
		return o.callerPublicKey, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "transactionId":
		return o.transactionId, nil
	case "caller":
		return o.caller, nil
	case "fee":
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvocationV3) copy() rideType {
	return newRideInvocationV3(o.payment, o.callerPublicKey, o.feeAssetId, o.transactionId, o.caller, o.fee)
}

func (o rideInvocationV3) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, "Invocation(")
	r = append(r, fieldLines("payment", o.payment.lines())...)
	r = append(r, fieldLines("callerPublicKey", o.callerPublicKey.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("transactionId", o.transactionId.lines())...)
	r = append(r, fieldLines("caller", o.caller.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvocationV3) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvocationV4 struct {
	payments        rideList
	callerPublicKey rideByteVector
	feeAssetId      rideType
	transactionId   rideByteVector
	caller          rideAddress
	fee             rideInt
}

func newRideInvocationV4(payments rideList, callerPublicKey rideByteVector, feeAssetId rideType, transactionId rideByteVector, caller rideAddress, fee rideInt) rideInvocationV4 {
	return rideInvocationV4{
		payments:        payments,
		callerPublicKey: callerPublicKey,
		feeAssetId:      feeAssetId,
		transactionId:   transactionId,
		caller:          caller,
		fee:             fee,
	}
}

func (o rideInvocationV4) instanceOf() string {
	return "Invocation"
}

func (o rideInvocationV4) eq(other rideType) bool {
	if oo, ok := other.(rideInvocationV4); ok {
		if !o.payments.eq(oo.payments) {
			return false
		}
		if !o.callerPublicKey.eq(oo.callerPublicKey) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.transactionId.eq(oo.transactionId) {
			return false
		}
		if !o.caller.eq(oo.caller) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvocationV4) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Invocation"), nil
	case "payments":
		return o.payments, nil
	case "callerPublicKey":
		return o.callerPublicKey, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "transactionId":
		return o.transactionId, nil
	case "caller":
		return o.caller, nil
	case "fee":
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvocationV4) copy() rideType {
	return newRideInvocationV4(o.payments, o.callerPublicKey, o.feeAssetId, o.transactionId, o.caller, o.fee)
}

func (o rideInvocationV4) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, "Invocation(")
	r = append(r, fieldLines("payments", o.payments.lines())...)
	r = append(r, fieldLines("callerPublicKey", o.callerPublicKey.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("transactionId", o.transactionId.lines())...)
	r = append(r, fieldLines("caller", o.caller.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvocationV4) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvocationV5 struct {
	originCaller          rideAddress
	payments              rideList
	callerPublicKey       rideByteVector
	feeAssetId            rideType
	originCallerPublicKey rideType
	transactionId         rideByteVector
	caller                rideAddress
	fee                   rideInt
}

func newRideInvocationV5(originCaller rideAddress, payments rideList, callerPublicKey rideByteVector, feeAssetId rideType, originCallerPublicKey rideType, transactionId rideByteVector, caller rideAddress, fee rideInt) rideInvocationV5 {
	return rideInvocationV5{
		originCaller:          originCaller,
		payments:              payments,
		callerPublicKey:       callerPublicKey,
		feeAssetId:            feeAssetId,
		originCallerPublicKey: originCallerPublicKey,
		transactionId:         transactionId,
		caller:                caller,
		fee:                   fee,
	}
}

func (o rideInvocationV5) instanceOf() string {
	return "Invocation"
}

func (o rideInvocationV5) eq(other rideType) bool {
	if oo, ok := other.(rideInvocationV5); ok {
		if !o.originCaller.eq(oo.originCaller) {
			return false
		}
		if !o.payments.eq(oo.payments) {
			return false
		}
		if !o.callerPublicKey.eq(oo.callerPublicKey) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.originCallerPublicKey.eq(oo.originCallerPublicKey) {
			return false
		}
		if !o.transactionId.eq(oo.transactionId) {
			return false
		}
		if !o.caller.eq(oo.caller) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvocationV5) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Invocation"), nil
	case "originCaller":
		return o.originCaller, nil
	case "payments":
		return o.payments, nil
	case "callerPublicKey":
		return o.callerPublicKey, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "originCallerPublicKey":
		return o.originCallerPublicKey, nil
	case "transactionId":
		return o.transactionId, nil
	case "caller":
		return o.caller, nil
	case "fee":
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvocationV5) copy() rideType {
	return newRideInvocationV5(o.originCaller, o.payments, o.callerPublicKey, o.feeAssetId, o.originCallerPublicKey, o.transactionId, o.caller, o.fee)
}

func (o rideInvocationV5) lines() []string {
	r := make([]string, 0, 10)
	r = append(r, "Invocation(")
	r = append(r, fieldLines("originCaller", o.originCaller.lines())...)
	r = append(r, fieldLines("payments", o.payments.lines())...)
	r = append(r, fieldLines("callerPublicKey", o.callerPublicKey.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("originCallerPublicKey", o.originCallerPublicKey.lines())...)
	r = append(r, fieldLines("transactionId", o.transactionId.lines())...)
	r = append(r, fieldLines("caller", o.caller.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvocationV5) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideIssue struct {
	compiledScript rideType
	name           rideString
	description    rideString
	nonce          rideInt
	decimals       rideInt
	quantity       rideInt
	isReissuable   rideBoolean
}

func newRideIssue(compiledScript rideType, name rideString, description rideString, nonce rideInt, decimals rideInt, quantity rideInt, isReissuable rideBoolean) rideIssue {
	return rideIssue{
		compiledScript: compiledScript,
		name:           name,
		description:    description,
		nonce:          nonce,
		decimals:       decimals,
		quantity:       quantity,
		isReissuable:   isReissuable,
	}
}

func (o rideIssue) instanceOf() string {
	return "Issue"
}

func (o rideIssue) eq(other rideType) bool {
	if oo, ok := other.(rideIssue); ok {
		if !o.compiledScript.eq(oo.compiledScript) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.nonce.eq(oo.nonce) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.isReissuable.eq(oo.isReissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideIssue) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Issue"), nil
	case "compiledScript":
		return o.compiledScript, nil
	case "name":
		return o.name, nil
	case "description":
		return o.description, nil
	case "nonce":
		return o.nonce, nil
	case "decimals":
		return o.decimals, nil
	case "quantity":
		return o.quantity, nil
	case "isReissuable":
		return o.isReissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideIssue) copy() rideType {
	return newRideIssue(o.compiledScript, o.name, o.description, o.nonce, o.decimals, o.quantity, o.isReissuable)
}

func (o rideIssue) lines() []string {
	r := make([]string, 0, 9)
	r = append(r, "Issue(")
	r = append(r, fieldLines("isReissuable", o.isReissuable.lines())...)
	r = append(r, fieldLines("nonce", o.nonce.lines())...)
	r = append(r, fieldLines("description", o.description.lines())...)
	r = append(r, fieldLines("decimals", o.decimals.lines())...)
	r = append(r, fieldLines("compiledScript", o.compiledScript.lines())...)
	r = append(r, fieldLines("name", o.name.lines())...)
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, ")")
	return r
}

func (o rideIssue) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideLeaseCancel struct {
	leaseId rideByteVector
}

func newRideLeaseCancel(leaseId rideByteVector) rideLeaseCancel {
	return rideLeaseCancel{
		leaseId: leaseId,
	}
}

func (o rideLeaseCancel) instanceOf() string {
	return "LeaseCancel"
}

func (o rideLeaseCancel) eq(other rideType) bool {
	if oo, ok := other.(rideLeaseCancel); ok {
		if !o.leaseId.eq(oo.leaseId) {
			return false
		}
		return true
	}
	return false
}

func (o rideLeaseCancel) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("LeaseCancel"), nil
	case "leaseId":
		return o.leaseId, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLeaseCancel) copy() rideType {
	return newRideLeaseCancel(o.leaseId)
}

func (o rideLeaseCancel) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, "LeaseCancel(")
	r = append(r, fieldLines("leaseId", o.leaseId.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLeaseCancel) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideLease struct {
	recipient rideType
	amount    rideInt
	nonce     rideInt
}

func newRideLease(recipient rideType, amount rideInt, nonce rideInt) rideLease {
	return rideLease{
		recipient: recipient,
		amount:    amount,
		nonce:     nonce,
	}
}

func (o rideLease) instanceOf() string {
	return "Lease"
}

func (o rideLease) eq(other rideType) bool {
	if oo, ok := other.(rideLease); ok {
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.nonce.eq(oo.nonce) {
			return false
		}
		return true
	}
	return false
}

func (o rideLease) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Lease"), nil
	case "recipient":
		return o.recipient, nil
	case "amount":
		return o.amount, nil
	case "nonce":
		return o.nonce, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLease) copy() rideType {
	return newRideLease(o.recipient, o.amount, o.nonce)
}

func (o rideLease) lines() []string {
	r := make([]string, 0, 5)
	r = append(r, "Lease(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("nonce", o.nonce.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLease) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideOrder struct {
	assetPair         rideType
	orderType         rideType
	matcherFeeAssetId rideType
	proofs            rideList
	bodyBytes         rideByteVector
	id                rideByteVector
	senderPublicKey   rideByteVector
	matcherPublicKey  rideByteVector
	amount            rideInt
	timestamp         rideInt
	expiration        rideInt
	matcherFee        rideInt
	price             rideInt
	sender            rideAddress
}

func newRideOrder(assetPair rideType, orderType rideType, matcherFeeAssetId rideType, proofs rideList, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, matcherPublicKey rideByteVector, amount rideInt, timestamp rideInt, expiration rideInt, matcherFee rideInt, price rideInt, sender rideAddress) rideOrder {
	return rideOrder{
		assetPair:         assetPair,
		orderType:         orderType,
		matcherFeeAssetId: matcherFeeAssetId,
		proofs:            proofs,
		bodyBytes:         bodyBytes,
		id:                id,
		senderPublicKey:   senderPublicKey,
		matcherPublicKey:  matcherPublicKey,
		amount:            amount,
		timestamp:         timestamp,
		expiration:        expiration,
		matcherFee:        matcherFee,
		price:             price,
		sender:            sender,
	}
}

func (o rideOrder) instanceOf() string {
	return "Order"
}

func (o rideOrder) eq(other rideType) bool {
	if oo, ok := other.(rideOrder); ok {
		if !o.assetPair.eq(oo.assetPair) {
			return false
		}
		if !o.orderType.eq(oo.orderType) {
			return false
		}
		if !o.matcherFeeAssetId.eq(oo.matcherFeeAssetId) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.matcherPublicKey.eq(oo.matcherPublicKey) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.expiration.eq(oo.expiration) {
			return false
		}
		if !o.matcherFee.eq(oo.matcherFee) {
			return false
		}
		if !o.price.eq(oo.price) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideOrder) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Order"), nil
	case "assetPair":
		return o.assetPair, nil
	case "orderType":
		return o.orderType, nil
	case "matcherFeeAssetId":
		return o.matcherFeeAssetId, nil
	case "proofs":
		return o.proofs, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "matcherPublicKey":
		return o.matcherPublicKey, nil
	case "amount":
		return o.amount, nil
	case "timestamp":
		return o.timestamp, nil
	case "expiration":
		return o.expiration, nil
	case "matcherFee":
		return o.matcherFee, nil
	case "price":
		return o.price, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideOrder) copy() rideType {
	return newRideOrder(o.assetPair, o.orderType, o.matcherFeeAssetId, o.proofs, o.bodyBytes, o.id, o.senderPublicKey, o.matcherPublicKey, o.amount, o.timestamp, o.expiration, o.matcherFee, o.price, o.sender)
}

func (o rideOrder) lines() []string {
	r := make([]string, 0, 16)
	r = append(r, "Order(")
	r = append(r, fieldLines("assetPair", o.assetPair.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("matcherFeeAssetId", o.matcherFeeAssetId.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("matcherPublicKey", o.matcherPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("orderType", o.orderType.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("expiration", o.expiration.lines())...)
	r = append(r, fieldLines("matcherFee", o.matcherFee.lines())...)
	r = append(r, fieldLines("price", o.price.lines())...)
	r = append(r, ")")
	return r
}

func (o rideOrder) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideOrder) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideOrder) getProofs() rideList {
	return o.proofs
}

type rideReissue struct {
	assetId      rideByteVector
	quantity     rideInt
	isReissuable rideBoolean
}

func newRideReissue(assetId rideByteVector, quantity rideInt, isReissuable rideBoolean) rideReissue {
	return rideReissue{
		assetId:      assetId,
		quantity:     quantity,
		isReissuable: isReissuable,
	}
}

func (o rideReissue) instanceOf() string {
	return "Reissue"
}

func (o rideReissue) eq(other rideType) bool {
	if oo, ok := other.(rideReissue); ok {
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.isReissuable.eq(oo.isReissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideReissue) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Reissue"), nil
	case "assetId":
		return o.assetId, nil
	case "quantity":
		return o.quantity, nil
	case "isReissuable":
		return o.isReissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideReissue) copy() rideType {
	return newRideReissue(o.assetId, o.quantity, o.isReissuable)
}

func (o rideReissue) lines() []string {
	r := make([]string, 0, 5)
	r = append(r, "Reissue(")
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, fieldLines("isReissuable", o.isReissuable.lines())...)
	r = append(r, ")")
	return r
}

func (o rideReissue) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideScriptResult struct {
	writeSet    rideWriteSet
	transferSet rideTransferSet
}

func newRideScriptResult(writeSet rideWriteSet, transferSet rideTransferSet) rideScriptResult {
	return rideScriptResult{
		writeSet:    writeSet,
		transferSet: transferSet,
	}
}

func (o rideScriptResult) instanceOf() string {
	return "ScriptResult"
}

func (o rideScriptResult) eq(other rideType) bool {
	if oo, ok := other.(rideScriptResult); ok {
		if !o.writeSet.eq(oo.writeSet) {
			return false
		}
		if !o.transferSet.eq(oo.transferSet) {
			return false
		}
		return true
	}
	return false
}

func (o rideScriptResult) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("ScriptResult"), nil
	case "writeSet":
		return o.writeSet, nil
	case "transferSet":
		return o.transferSet, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideScriptResult) copy() rideType {
	return newRideScriptResult(o.writeSet, o.transferSet)
}

func (o rideScriptResult) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "ScriptResult(")
	r = append(r, fieldLines("writeSet", o.writeSet.lines())...)
	r = append(r, fieldLines("transferSet", o.transferSet.lines())...)
	r = append(r, ")")
	return r
}

func (o rideScriptResult) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideScriptTransfer struct {
	asset     rideType
	recipient rideType
	amount    rideInt
}

func newRideScriptTransfer(asset rideType, recipient rideType, amount rideInt) rideScriptTransfer {
	return rideScriptTransfer{
		asset:     asset,
		recipient: recipient,
		amount:    amount,
	}
}

func (o rideScriptTransfer) instanceOf() string {
	return "ScriptTransfer"
}

func (o rideScriptTransfer) eq(other rideType) bool {
	if oo, ok := other.(rideScriptTransfer); ok {
		if !o.asset.eq(oo.asset) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		return true
	}
	return false
}

func (o rideScriptTransfer) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("ScriptTransfer"), nil
	case "asset":
		return o.asset, nil
	case "recipient":
		return o.recipient, nil
	case "amount":
		return o.amount, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideScriptTransfer) copy() rideType {
	return newRideScriptTransfer(o.asset, o.recipient, o.amount)
}

func (o rideScriptTransfer) lines() []string {
	r := make([]string, 0, 5)
	r = append(r, "ScriptTransfer(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("asset", o.asset.lines())...)
	r = append(r, ")")
	return r
}

func (o rideScriptTransfer) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideSponsorFee struct {
	assetId              rideByteVector
	minSponsoredAssetFee rideInt
}

func newRideSponsorFee(assetId rideByteVector, minSponsoredAssetFee rideInt) rideSponsorFee {
	return rideSponsorFee{
		assetId:              assetId,
		minSponsoredAssetFee: minSponsoredAssetFee,
	}
}

func (o rideSponsorFee) instanceOf() string {
	return "SponsorFee"
}

func (o rideSponsorFee) eq(other rideType) bool {
	if oo, ok := other.(rideSponsorFee); ok {
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.minSponsoredAssetFee.eq(oo.minSponsoredAssetFee) {
			return false
		}
		return true
	}
	return false
}

func (o rideSponsorFee) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("SponsorFee"), nil
	case "assetId":
		return o.assetId, nil
	case "minSponsoredAssetFee":
		return o.minSponsoredAssetFee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSponsorFee) copy() rideType {
	return newRideSponsorFee(o.assetId, o.minSponsoredAssetFee)
}

func (o rideSponsorFee) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "SponsorFee(")
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("minSponsoredAssetFee", o.minSponsoredAssetFee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSponsorFee) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideStringEntry struct {
	key   rideString
	value rideString
}

func newRideStringEntry(key rideString, value rideString) rideStringEntry {
	return rideStringEntry{
		key:   key,
		value: value,
	}
}

func (o rideStringEntry) instanceOf() string {
	return "StringEntry"
}

func (o rideStringEntry) eq(other rideType) bool {
	if oo, ok := other.(rideStringEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideStringEntry) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("StringEntry"), nil
	case "key":
		return o.key, nil
	case "value":
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideStringEntry) copy() rideType {
	return newRideStringEntry(o.key, o.value)
}

func (o rideStringEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "StringEntry(")
	r = append(r, fieldLines("key", o.key.lines())...)
	r = append(r, fieldLines("value", o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideStringEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideTransfer struct {
	recipient rideType
	amount    rideInt
}

func newRideTransfer(recipient rideType, amount rideInt) rideTransfer {
	return rideTransfer{
		recipient: recipient,
		amount:    amount,
	}
}

func (o rideTransfer) instanceOf() string {
	return "Transfer"
}

func (o rideTransfer) eq(other rideType) bool {
	if oo, ok := other.(rideTransfer); ok {
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		return true
	}
	return false
}

func (o rideTransfer) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("Transfer"), nil
	case "recipient":
		return o.recipient, nil
	case "amount":
		return o.amount, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideTransfer) copy() rideType {
	return newRideTransfer(o.recipient, o.amount)
}

func (o rideTransfer) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, "Transfer(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, ")")
	return r
}

func (o rideTransfer) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideTransferSet struct {
	transfers rideList
}

func newRideTransferSet(transfers rideList) rideTransferSet {
	return rideTransferSet{
		transfers: transfers,
	}
}

func (o rideTransferSet) instanceOf() string {
	return "TransferSet"
}

func (o rideTransferSet) eq(other rideType) bool {
	if oo, ok := other.(rideTransferSet); ok {
		if !o.transfers.eq(oo.transfers) {
			return false
		}
		return true
	}
	return false
}

func (o rideTransferSet) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("TransferSet"), nil
	case "transfers":
		return o.transfers, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideTransferSet) copy() rideType {
	return newRideTransferSet(o.transfers)
}

func (o rideTransferSet) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, "TransferSet(")
	r = append(r, fieldLines("transfers", o.transfers.lines())...)
	r = append(r, ")")
	return r
}

func (o rideTransferSet) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideWriteSet struct {
	data rideList
}

func newRideWriteSet(data rideList) rideWriteSet {
	return rideWriteSet{
		data: data,
	}
}

func (o rideWriteSet) instanceOf() string {
	return "WriteSet"
}

func (o rideWriteSet) eq(other rideType) bool {
	if oo, ok := other.(rideWriteSet); ok {
		if !o.data.eq(oo.data) {
			return false
		}
		return true
	}
	return false
}

func (o rideWriteSet) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("WriteSet"), nil
	case "data":
		return o.data, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideWriteSet) copy() rideType {
	return newRideWriteSet(o.data)
}

func (o rideWriteSet) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, "WriteSet(")
	r = append(r, fieldLines("data", o.data.lines())...)
	r = append(r, ")")
	return r
}

func (o rideWriteSet) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBurnTransaction struct {
	bodyBytes       rideByteVector
	proofs          rideList
	senderPublicKey rideByteVector
	assetId         rideByteVector
	id              rideByteVector
	timestamp       rideInt
	version         rideInt
	quantity        rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideBurnTransaction(bodyBytes rideByteVector, proofs rideList, senderPublicKey rideByteVector, assetId rideByteVector, id rideByteVector, timestamp rideInt, version rideInt, quantity rideInt, fee rideInt, sender rideAddress) rideBurnTransaction {
	return rideBurnTransaction{
		bodyBytes:       bodyBytes,
		proofs:          proofs,
		senderPublicKey: senderPublicKey,
		assetId:         assetId,
		id:              id,
		timestamp:       timestamp,
		version:         version,
		quantity:        quantity,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideBurnTransaction) instanceOf() string {
	return "BurnTransaction"
}

func (o rideBurnTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideBurnTransaction); ok {
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideBurnTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("BurnTransaction"), nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "proofs":
		return o.proofs, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "assetId":
		return o.assetId, nil
	case "id":
		return o.id, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "quantity":
		return o.quantity, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBurnTransaction) copy() rideType {
	return newRideBurnTransaction(o.bodyBytes, o.proofs, o.senderPublicKey, o.assetId, o.id, o.timestamp, o.version, o.quantity, o.fee, o.sender)
}

func (o rideBurnTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "BurnTransaction(")
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBurnTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideBurnTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideBurnTransaction) getProofs() rideList {
	return o.proofs
}

type rideCreateAliasTransaction struct {
	proofs          rideList
	alias           rideString
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	fee             rideInt
	version         rideInt
	sender          rideAddress
}

func newRideCreateAliasTransaction(proofs rideList, alias rideString, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, fee rideInt, version rideInt, sender rideAddress) rideCreateAliasTransaction {
	return rideCreateAliasTransaction{
		proofs:          proofs,
		alias:           alias,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		fee:             fee,
		version:         version,
		sender:          sender,
	}
}

func (o rideCreateAliasTransaction) instanceOf() string {
	return "CreateAliasTransaction"
}

func (o rideCreateAliasTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideCreateAliasTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.alias.eq(oo.alias) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideCreateAliasTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("CreateAliasTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "alias":
		return o.alias, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "fee":
		return o.fee, nil
	case "version":
		return o.version, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideCreateAliasTransaction) copy() rideType {
	return newRideCreateAliasTransaction(o.proofs, o.alias, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.fee, o.version, o.sender)
}

func (o rideCreateAliasTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, "CreateAliasTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, fieldLines("alias", o.alias.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, ")")
	return r
}

func (o rideCreateAliasTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideCreateAliasTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideCreateAliasTransaction) getProofs() rideList {
	return o.proofs
}

type rideDataTransaction struct {
	proofs          rideList
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	data            rideList
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideDataTransaction(proofs rideList, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, data rideList, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideDataTransaction {
	return rideDataTransaction{
		proofs:          proofs,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		data:            data,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideDataTransaction) instanceOf() string {
	return "DataTransaction"
}

func (o rideDataTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideDataTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.data.eq(oo.data) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideDataTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("DataTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "data":
		return o.data, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideDataTransaction) copy() rideType {
	return newRideDataTransaction(o.proofs, o.bodyBytes, o.id, o.senderPublicKey, o.data, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideDataTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, "DataTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("data", o.data.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideDataTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideDataTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideDataTransaction) getProofs() rideList {
	return o.proofs
}

type rideExchangeTransaction struct {
	proofs          rideList
	buyOrder        rideType
	sellOrder       rideType
	id              rideByteVector
	bodyBytes       rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	price           rideInt
	amount          rideInt
	version         rideInt
	buyMatcherFee   rideInt
	fee             rideInt
	sellMatcherFee  rideInt
	sender          rideAddress
}

func newRideExchangeTransaction(proofs rideList, buyOrder rideType, sellOrder rideType, id rideByteVector, bodyBytes rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, price rideInt, amount rideInt, version rideInt, buyMatcherFee rideInt, fee rideInt, sellMatcherFee rideInt, sender rideAddress) rideExchangeTransaction {
	return rideExchangeTransaction{
		proofs:          proofs,
		buyOrder:        buyOrder,
		sellOrder:       sellOrder,
		id:              id,
		bodyBytes:       bodyBytes,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		price:           price,
		amount:          amount,
		version:         version,
		buyMatcherFee:   buyMatcherFee,
		fee:             fee,
		sellMatcherFee:  sellMatcherFee,
		sender:          sender,
	}
}

func (o rideExchangeTransaction) instanceOf() string {
	return "ExchangeTransaction"
}

func (o rideExchangeTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideExchangeTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.buyOrder.eq(oo.buyOrder) {
			return false
		}
		if !o.sellOrder.eq(oo.sellOrder) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.price.eq(oo.price) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.buyMatcherFee.eq(oo.buyMatcherFee) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sellMatcherFee.eq(oo.sellMatcherFee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideExchangeTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("ExchangeTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "buyOrder":
		return o.buyOrder, nil
	case "sellOrder":
		return o.sellOrder, nil
	case "id":
		return o.id, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "price":
		return o.price, nil
	case "amount":
		return o.amount, nil
	case "version":
		return o.version, nil
	case "buyMatcherFee":
		return o.buyMatcherFee, nil
	case "fee":
		return o.fee, nil
	case "sellMatcherFee":
		return o.sellMatcherFee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideExchangeTransaction) copy() rideType {
	return newRideExchangeTransaction(o.proofs, o.buyOrder, o.sellOrder, o.id, o.bodyBytes, o.senderPublicKey, o.timestamp, o.price, o.amount, o.version, o.buyMatcherFee, o.fee, o.sellMatcherFee, o.sender)
}

func (o rideExchangeTransaction) lines() []string {
	r := make([]string, 0, 16)
	r = append(r, "ExchangeTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("buyOrder", o.buyOrder.lines())...)
	r = append(r, fieldLines("price", o.price.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("sellOrder", o.sellOrder.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("buyMatcherFee", o.buyMatcherFee.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("sellMatcherFee", o.sellMatcherFee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideExchangeTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideExchangeTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideExchangeTransaction) getProofs() rideList {
	return o.proofs
}

type rideGenesisTransaction struct {
	recipient rideType
	id        rideByteVector
	timestamp rideInt
	amount    rideInt
	version   rideInt
	fee       rideInt
}

func newRideGenesisTransaction(recipient rideType, id rideByteVector, timestamp rideInt, amount rideInt, version rideInt, fee rideInt) rideGenesisTransaction {
	return rideGenesisTransaction{
		recipient: recipient,
		id:        id,
		timestamp: timestamp,
		amount:    amount,
		version:   version,
		fee:       fee,
	}
}

func (o rideGenesisTransaction) instanceOf() string {
	return "GenesisTransaction"
}

func (o rideGenesisTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideGenesisTransaction); ok {
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideGenesisTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("GenesisTransaction"), nil
	case "recipient":
		return o.recipient, nil
	case "id":
		return o.id, nil
	case "timestamp":
		return o.timestamp, nil
	case "amount":
		return o.amount, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideGenesisTransaction) copy() rideType {
	return newRideGenesisTransaction(o.recipient, o.id, o.timestamp, o.amount, o.version, o.fee)
}

func (o rideGenesisTransaction) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, "GenesisTransaction(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideGenesisTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvokeExpressionTransaction struct {
	proofs          rideList
	feeAssetId      rideType
	bodyBytes       rideByteVector
	id              rideByteVector
	expression      rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideInvokeExpressionTransaction(proofs rideList, feeAssetId rideType, bodyBytes rideByteVector, id rideByteVector, expression rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideInvokeExpressionTransaction {
	return rideInvokeExpressionTransaction{
		proofs:          proofs,
		feeAssetId:      feeAssetId,
		bodyBytes:       bodyBytes,
		id:              id,
		expression:      expression,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideInvokeExpressionTransaction) instanceOf() string {
	return "InvokeExpressionTransaction"
}

func (o rideInvokeExpressionTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideInvokeExpressionTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.expression.eq(oo.expression) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvokeExpressionTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("InvokeExpressionTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "expression":
		return o.expression, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvokeExpressionTransaction) copy() rideType {
	return newRideInvokeExpressionTransaction(o.proofs, o.feeAssetId, o.bodyBytes, o.id, o.expression, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideInvokeExpressionTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "InvokeExpressionTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("expression", o.expression.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvokeExpressionTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideInvokeExpressionTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideInvokeExpressionTransaction) getProofs() rideList {
	return o.proofs
}

type rideInvokeScriptTransactionV3 struct {
	proofs          rideList
	feeAssetId      rideType
	dApp            rideType
	function        rideString
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	payment         rideType
	args            rideList
	timestamp       rideInt
	fee             rideInt
	version         rideInt
	sender          rideAddress
}

func newRideInvokeScriptTransactionV3(proofs rideList, feeAssetId rideType, dApp rideType, function rideString, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, payment rideType, args rideList, timestamp rideInt, fee rideInt, version rideInt, sender rideAddress) rideInvokeScriptTransactionV3 {
	return rideInvokeScriptTransactionV3{
		proofs:          proofs,
		feeAssetId:      feeAssetId,
		dApp:            dApp,
		function:        function,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		payment:         payment,
		args:            args,
		timestamp:       timestamp,
		fee:             fee,
		version:         version,
		sender:          sender,
	}
}

func (o rideInvokeScriptTransactionV3) instanceOf() string {
	return "InvokeScriptTransaction"
}

func (o rideInvokeScriptTransactionV3) eq(other rideType) bool {
	if oo, ok := other.(rideInvokeScriptTransactionV3); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.dApp.eq(oo.dApp) {
			return false
		}
		if !o.function.eq(oo.function) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.payment.eq(oo.payment) {
			return false
		}
		if !o.args.eq(oo.args) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvokeScriptTransactionV3) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("InvokeScriptTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "dApp":
		return o.dApp, nil
	case "function":
		return o.function, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "payment":
		return o.payment, nil
	case "args":
		return o.args, nil
	case "timestamp":
		return o.timestamp, nil
	case "fee":
		return o.fee, nil
	case "version":
		return o.version, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvokeScriptTransactionV3) copy() rideType {
	return newRideInvokeScriptTransactionV3(o.proofs, o.feeAssetId, o.dApp, o.function, o.bodyBytes, o.id, o.senderPublicKey, o.payment, o.args, o.timestamp, o.fee, o.version, o.sender)
}

func (o rideInvokeScriptTransactionV3) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, "InvokeScriptTransaction(")
	r = append(r, fieldLines("payment", o.payment.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, fieldLines("dApp", o.dApp.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("function", o.function.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("args", o.args.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvokeScriptTransactionV3) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideInvokeScriptTransactionV3) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideInvokeScriptTransactionV3) getProofs() rideList {
	return o.proofs
}

type rideInvokeScriptTransactionV4 struct {
	proofs          rideList
	feeAssetId      rideType
	dApp            rideType
	function        rideString
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	payments        rideList
	args            rideList
	timestamp       rideInt
	fee             rideInt
	version         rideInt
	sender          rideAddress
}

func newRideInvokeScriptTransactionV4(proofs rideList, feeAssetId rideType, dApp rideType, function rideString, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, payments rideList, args rideList, timestamp rideInt, fee rideInt, version rideInt, sender rideAddress) rideInvokeScriptTransactionV4 {
	return rideInvokeScriptTransactionV4{
		proofs:          proofs,
		feeAssetId:      feeAssetId,
		dApp:            dApp,
		function:        function,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		payments:        payments,
		args:            args,
		timestamp:       timestamp,
		fee:             fee,
		version:         version,
		sender:          sender,
	}
}

func (o rideInvokeScriptTransactionV4) instanceOf() string {
	return "InvokeScriptTransaction"
}

func (o rideInvokeScriptTransactionV4) eq(other rideType) bool {
	if oo, ok := other.(rideInvokeScriptTransactionV4); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.dApp.eq(oo.dApp) {
			return false
		}
		if !o.function.eq(oo.function) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.payments.eq(oo.payments) {
			return false
		}
		if !o.args.eq(oo.args) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvokeScriptTransactionV4) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("InvokeScriptTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "dApp":
		return o.dApp, nil
	case "function":
		return o.function, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "payments":
		return o.payments, nil
	case "args":
		return o.args, nil
	case "timestamp":
		return o.timestamp, nil
	case "fee":
		return o.fee, nil
	case "version":
		return o.version, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvokeScriptTransactionV4) copy() rideType {
	return newRideInvokeScriptTransactionV4(o.proofs, o.feeAssetId, o.dApp, o.function, o.bodyBytes, o.id, o.senderPublicKey, o.payments, o.args, o.timestamp, o.fee, o.version, o.sender)
}

func (o rideInvokeScriptTransactionV4) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, "InvokeScriptTransaction(")
	r = append(r, fieldLines("payments", o.payments.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, fieldLines("dApp", o.dApp.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("function", o.function.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("args", o.args.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvokeScriptTransactionV4) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideInvokeScriptTransactionV4) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideInvokeScriptTransactionV4) getProofs() rideList {
	return o.proofs
}

type rideIssueTransaction struct {
	proofs          rideList
	script          rideType
	description     rideString
	name            rideString
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	quantity        rideInt
	decimals        rideInt
	reissuable      rideBoolean
	sender          rideAddress
}

func newRideIssueTransaction(proofs rideList, script rideType, description rideString, name rideString, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, version rideInt, fee rideInt, quantity rideInt, decimals rideInt, reissuable rideBoolean, sender rideAddress) rideIssueTransaction {
	return rideIssueTransaction{
		proofs:          proofs,
		script:          script,
		description:     description,
		name:            name,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		quantity:        quantity,
		decimals:        decimals,
		reissuable:      reissuable,
		sender:          sender,
	}
}

func (o rideIssueTransaction) instanceOf() string {
	return "IssueTransaction"
}

func (o rideIssueTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideIssueTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.script.eq(oo.script) {
			return false
		}
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideIssueTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("IssueTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "script":
		return o.script, nil
	case "description":
		return o.description, nil
	case "name":
		return o.name, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "quantity":
		return o.quantity, nil
	case "decimals":
		return o.decimals, nil
	case "reissuable":
		return o.reissuable, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideIssueTransaction) copy() rideType {
	return newRideIssueTransaction(o.proofs, o.script, o.description, o.name, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.quantity, o.decimals, o.reissuable, o.sender)
}

func (o rideIssueTransaction) lines() []string {
	r := make([]string, 0, 16)
	r = append(r, "IssueTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("description", o.description.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("script", o.script.lines())...)
	r = append(r, fieldLines("reissuable", o.reissuable.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, fieldLines("name", o.name.lines())...)
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("decimals", o.decimals.lines())...)
	r = append(r, ")")
	return r
}

func (o rideIssueTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideIssueTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideIssueTransaction) getProofs() rideList {
	return o.proofs
}

type rideLeaseCancelTransaction struct {
	proofs          rideList
	bodyBytes       rideByteVector
	senderPublicKey rideByteVector
	id              rideByteVector
	leaseId         rideByteVector
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideLeaseCancelTransaction(proofs rideList, bodyBytes rideByteVector, senderPublicKey rideByteVector, id rideByteVector, leaseId rideByteVector, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideLeaseCancelTransaction {
	return rideLeaseCancelTransaction{
		proofs:          proofs,
		bodyBytes:       bodyBytes,
		senderPublicKey: senderPublicKey,
		id:              id,
		leaseId:         leaseId,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideLeaseCancelTransaction) instanceOf() string {
	return "LeaseCancelTransaction"
}

func (o rideLeaseCancelTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideLeaseCancelTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.leaseId.eq(oo.leaseId) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideLeaseCancelTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("LeaseCancelTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "id":
		return o.id, nil
	case "leaseId":
		return o.leaseId, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLeaseCancelTransaction) copy() rideType {
	return newRideLeaseCancelTransaction(o.proofs, o.bodyBytes, o.senderPublicKey, o.id, o.leaseId, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideLeaseCancelTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, "LeaseCancelTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("leaseId", o.leaseId.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLeaseCancelTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideLeaseCancelTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideLeaseCancelTransaction) getProofs() rideList {
	return o.proofs
}

type rideLeaseTransaction struct {
	proofs          rideList
	recipient       rideType
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	amount          rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideLeaseTransaction(proofs rideList, recipient rideType, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, amount rideInt, version rideInt, fee rideInt, sender rideAddress) rideLeaseTransaction {
	return rideLeaseTransaction{
		proofs:          proofs,
		recipient:       recipient,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		amount:          amount,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideLeaseTransaction) instanceOf() string {
	return "LeaseTransaction"
}

func (o rideLeaseTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideLeaseTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideLeaseTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("LeaseTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "recipient":
		return o.recipient, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "amount":
		return o.amount, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLeaseTransaction) copy() rideType {
	return newRideLeaseTransaction(o.proofs, o.recipient, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.amount, o.version, o.fee, o.sender)
}

func (o rideLeaseTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "LeaseTransaction(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLeaseTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideLeaseTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideLeaseTransaction) getProofs() rideList {
	return o.proofs
}

type rideMassTransferTransaction struct {
	proofs          rideList
	assetId         rideType
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	attachment      rideByteVector
	transfers       rideList
	transferCount   rideInt
	timestamp       rideInt
	fee             rideInt
	totalAmount     rideInt
	version         rideInt
	sender          rideAddress
}

func newRideMassTransferTransaction(proofs rideList, assetId rideType, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, attachment rideByteVector, transfers rideList, transferCount rideInt, timestamp rideInt, fee rideInt, totalAmount rideInt, version rideInt, sender rideAddress) rideMassTransferTransaction {
	return rideMassTransferTransaction{
		proofs:          proofs,
		assetId:         assetId,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		attachment:      attachment,
		transfers:       transfers,
		transferCount:   transferCount,
		timestamp:       timestamp,
		fee:             fee,
		totalAmount:     totalAmount,
		version:         version,
		sender:          sender,
	}
}

func (o rideMassTransferTransaction) instanceOf() string {
	return "MassTransferTransaction"
}

func (o rideMassTransferTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideMassTransferTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.attachment.eq(oo.attachment) {
			return false
		}
		if !o.transfers.eq(oo.transfers) {
			return false
		}
		if !o.transferCount.eq(oo.transferCount) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.totalAmount.eq(oo.totalAmount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideMassTransferTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("MassTransferTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "assetId":
		return o.assetId, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "attachment":
		return o.attachment, nil
	case "transfers":
		return o.transfers, nil
	case "transferCount":
		return o.transferCount, nil
	case "timestamp":
		return o.timestamp, nil
	case "fee":
		return o.fee, nil
	case "totalAmount":
		return o.totalAmount, nil
	case "version":
		return o.version, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideMassTransferTransaction) copy() rideType {
	return newRideMassTransferTransaction(o.proofs, o.assetId, o.bodyBytes, o.id, o.senderPublicKey, o.attachment, o.transfers, o.transferCount, o.timestamp, o.fee, o.totalAmount, o.version, o.sender)
}

func (o rideMassTransferTransaction) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, "MassTransferTransaction(")
	r = append(r, fieldLines("transferCount", o.transferCount.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("attachment", o.attachment.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("transfers", o.transfers.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, fieldLines("totalAmount", o.totalAmount.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, ")")
	return r
}

func (o rideMassTransferTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideMassTransferTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideMassTransferTransaction) getProofs() rideList {
	return o.proofs
}

type ridePaymentTransaction struct {
	proofs          rideList
	recipient       rideType
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	amount          rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRidePaymentTransaction(proofs rideList, recipient rideType, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, amount rideInt, version rideInt, fee rideInt, sender rideAddress) ridePaymentTransaction {
	return ridePaymentTransaction{
		proofs:          proofs,
		recipient:       recipient,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		amount:          amount,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o ridePaymentTransaction) instanceOf() string {
	return "PaymentTransaction"
}

func (o ridePaymentTransaction) eq(other rideType) bool {
	if oo, ok := other.(ridePaymentTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o ridePaymentTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("PaymentTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "recipient":
		return o.recipient, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "amount":
		return o.amount, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o ridePaymentTransaction) copy() rideType {
	return newRidePaymentTransaction(o.proofs, o.recipient, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.amount, o.version, o.fee, o.sender)
}

func (o ridePaymentTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "PaymentTransaction(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o ridePaymentTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o ridePaymentTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o ridePaymentTransaction) getProofs() rideList {
	return o.proofs
}

type rideReissueTransaction struct {
	bodyBytes       rideByteVector
	proofs          rideList
	senderPublicKey rideByteVector
	assetId         rideByteVector
	id              rideByteVector
	timestamp       rideInt
	version         rideInt
	quantity        rideInt
	fee             rideInt
	sender          rideAddress
	reissuable      rideBoolean
}

func newRideReissueTransaction(bodyBytes rideByteVector, proofs rideList, senderPublicKey rideByteVector, assetId rideByteVector, id rideByteVector, timestamp rideInt, version rideInt, quantity rideInt, fee rideInt, sender rideAddress, reissuable rideBoolean) rideReissueTransaction {
	return rideReissueTransaction{
		bodyBytes:       bodyBytes,
		proofs:          proofs,
		senderPublicKey: senderPublicKey,
		assetId:         assetId,
		id:              id,
		timestamp:       timestamp,
		version:         version,
		quantity:        quantity,
		fee:             fee,
		sender:          sender,
		reissuable:      reissuable,
	}
}

func (o rideReissueTransaction) instanceOf() string {
	return "ReissueTransaction"
}

func (o rideReissueTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideReissueTransaction); ok {
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideReissueTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("ReissueTransaction"), nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "proofs":
		return o.proofs, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "assetId":
		return o.assetId, nil
	case "id":
		return o.id, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "quantity":
		return o.quantity, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	case "reissuable":
		return o.reissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideReissueTransaction) copy() rideType {
	return newRideReissueTransaction(o.bodyBytes, o.proofs, o.senderPublicKey, o.assetId, o.id, o.timestamp, o.version, o.quantity, o.fee, o.sender, o.reissuable)
}

func (o rideReissueTransaction) lines() []string {
	r := make([]string, 0, 13)
	r = append(r, "ReissueTransaction(")
	r = append(r, fieldLines("quantity", o.quantity.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("reissuable", o.reissuable.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideReissueTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideReissueTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideReissueTransaction) getProofs() rideList {
	return o.proofs
}

type rideSetAssetScriptTransaction struct {
	proofs          rideList
	script          rideType
	bodyBytes       rideByteVector
	assetId         rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideSetAssetScriptTransaction(proofs rideList, script rideType, bodyBytes rideByteVector, assetId rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideSetAssetScriptTransaction {
	return rideSetAssetScriptTransaction{
		proofs:          proofs,
		script:          script,
		bodyBytes:       bodyBytes,
		assetId:         assetId,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideSetAssetScriptTransaction) instanceOf() string {
	return "SetAssetScriptTransaction"
}

func (o rideSetAssetScriptTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideSetAssetScriptTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.script.eq(oo.script) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideSetAssetScriptTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("SetAssetScriptTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "script":
		return o.script, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "assetId":
		return o.assetId, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSetAssetScriptTransaction) copy() rideType {
	return newRideSetAssetScriptTransaction(o.proofs, o.script, o.bodyBytes, o.assetId, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideSetAssetScriptTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "SetAssetScriptTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("script", o.script.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSetAssetScriptTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideSetAssetScriptTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideSetAssetScriptTransaction) getProofs() rideList {
	return o.proofs
}

type rideSetScriptTransaction struct {
	proofs          rideList
	script          rideType
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideSetScriptTransaction(proofs rideList, script rideType, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideSetScriptTransaction {
	return rideSetScriptTransaction{
		proofs:          proofs,
		script:          script,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideSetScriptTransaction) instanceOf() string {
	return "SetScriptTransaction"
}

func (o rideSetScriptTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideSetScriptTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.script.eq(oo.script) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideSetScriptTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("SetScriptTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "script":
		return o.script, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSetScriptTransaction) copy() rideType {
	return newRideSetScriptTransaction(o.proofs, o.script, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideSetScriptTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, "SetScriptTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("script", o.script.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSetScriptTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideSetScriptTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideSetScriptTransaction) getProofs() rideList {
	return o.proofs
}

type rideSponsorFeeTransaction struct {
	proofs               rideList
	minSponsoredAssetFee rideType
	bodyBytes            rideByteVector
	assetId              rideByteVector
	id                   rideByteVector
	senderPublicKey      rideByteVector
	timestamp            rideInt
	version              rideInt
	fee                  rideInt
	sender               rideAddress
}

func newRideSponsorFeeTransaction(proofs rideList, minSponsoredAssetFee rideType, bodyBytes rideByteVector, assetId rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideSponsorFeeTransaction {
	return rideSponsorFeeTransaction{
		proofs:               proofs,
		minSponsoredAssetFee: minSponsoredAssetFee,
		bodyBytes:            bodyBytes,
		assetId:              assetId,
		id:                   id,
		senderPublicKey:      senderPublicKey,
		timestamp:            timestamp,
		version:              version,
		fee:                  fee,
		sender:               sender,
	}
}

func (o rideSponsorFeeTransaction) instanceOf() string {
	return "SponsorFeeTransaction"
}

func (o rideSponsorFeeTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideSponsorFeeTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.minSponsoredAssetFee.eq(oo.minSponsoredAssetFee) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideSponsorFeeTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("SponsorFeeTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "minSponsoredAssetFee":
		return o.minSponsoredAssetFee, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "assetId":
		return o.assetId, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSponsorFeeTransaction) copy() rideType {
	return newRideSponsorFeeTransaction(o.proofs, o.minSponsoredAssetFee, o.bodyBytes, o.assetId, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideSponsorFeeTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, "SponsorFeeTransaction(")
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("minSponsoredAssetFee", o.minSponsoredAssetFee.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSponsorFeeTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideSponsorFeeTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideSponsorFeeTransaction) getProofs() rideList {
	return o.proofs
}

type rideTransferTransaction struct {
	assetId         rideType
	bodyBytes       rideByteVector
	feeAssetId      rideType
	version         rideType
	attachment      rideType
	proofs          rideList
	fee             rideType
	recipient       rideType
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	amount          rideInt
	sender          rideAddress
}

func newRideTransferTransaction(assetId rideType, bodyBytes rideByteVector, feeAssetId rideType, version rideType, attachment rideType, proofs rideList, fee rideType, recipient rideType, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, amount rideInt, sender rideAddress) rideTransferTransaction {
	return rideTransferTransaction{
		assetId:         assetId,
		bodyBytes:       bodyBytes,
		feeAssetId:      feeAssetId,
		version:         version,
		attachment:      attachment,
		proofs:          proofs,
		fee:             fee,
		recipient:       recipient,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		amount:          amount,
		sender:          sender,
	}
}

func (o rideTransferTransaction) instanceOf() string {
	return "TransferTransaction"
}

func (o rideTransferTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideTransferTransaction); ok {
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.feeAssetId.eq(oo.feeAssetId) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.attachment.eq(oo.attachment) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideTransferTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("TransferTransaction"), nil
	case "assetId":
		return o.assetId, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "feeAssetId":
		return o.feeAssetId, nil
	case "version":
		return o.version, nil
	case "attachment":
		return o.attachment, nil
	case "proofs":
		return o.proofs, nil
	case "fee":
		return o.fee, nil
	case "recipient":
		return o.recipient, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "amount":
		return o.amount, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideTransferTransaction) copy() rideType {
	return newRideTransferTransaction(o.assetId, o.bodyBytes, o.feeAssetId, o.version, o.attachment, o.proofs, o.fee, o.recipient, o.id, o.senderPublicKey, o.timestamp, o.amount, o.sender)
}

func (o rideTransferTransaction) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, "TransferTransaction(")
	r = append(r, fieldLines("recipient", o.recipient.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("feeAssetId", o.feeAssetId.lines())...)
	r = append(r, fieldLines("amount", o.amount.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("attachment", o.attachment.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideTransferTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideTransferTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideTransferTransaction) getProofs() rideList {
	return o.proofs
}

type rideUpdateAssetInfoTransaction struct {
	proofs          rideList
	assetId         rideType
	name            rideString
	description     rideString
	bodyBytes       rideByteVector
	id              rideByteVector
	senderPublicKey rideByteVector
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideUpdateAssetInfoTransaction(proofs rideList, assetId rideType, name rideString, description rideString, bodyBytes rideByteVector, id rideByteVector, senderPublicKey rideByteVector, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideUpdateAssetInfoTransaction {
	return rideUpdateAssetInfoTransaction{
		proofs:          proofs,
		assetId:         assetId,
		name:            name,
		description:     description,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideUpdateAssetInfoTransaction) instanceOf() string {
	return "UpdateAssetInfoTransaction"
}

func (o rideUpdateAssetInfoTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideUpdateAssetInfoTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.assetId.eq(oo.assetId) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideUpdateAssetInfoTransaction) get(prop string) (rideType, error) {
	switch prop {
	case "$instance":
		return rideString("UpdateAssetInfoTransaction"), nil
	case "proofs":
		return o.proofs, nil
	case "assetId":
		return o.assetId, nil
	case "name":
		return o.name, nil
	case "description":
		return o.description, nil
	case "bodyBytes":
		return o.bodyBytes, nil
	case "id":
		return o.id, nil
	case "senderPublicKey":
		return o.senderPublicKey, nil
	case "timestamp":
		return o.timestamp, nil
	case "version":
		return o.version, nil
	case "fee":
		return o.fee, nil
	case "sender":
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideUpdateAssetInfoTransaction) copy() rideType {
	return newRideUpdateAssetInfoTransaction(o.proofs, o.assetId, o.name, o.description, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideUpdateAssetInfoTransaction) lines() []string {
	r := make([]string, 0, 13)
	r = append(r, "UpdateAssetInfoTransaction(")
	r = append(r, fieldLines("name", o.name.lines())...)
	r = append(r, fieldLines("timestamp", o.timestamp.lines())...)
	r = append(r, fieldLines("bodyBytes", o.bodyBytes.lines())...)
	r = append(r, fieldLines("assetId", o.assetId.lines())...)
	r = append(r, fieldLines("description", o.description.lines())...)
	r = append(r, fieldLines("version", o.version.lines())...)
	r = append(r, fieldLines("id", o.id.lines())...)
	r = append(r, fieldLines("senderPublicKey", o.senderPublicKey.lines())...)
	r = append(r, fieldLines("sender", o.sender.lines())...)
	r = append(r, fieldLines("proofs", o.proofs.lines())...)
	r = append(r, fieldLines("fee", o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideUpdateAssetInfoTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideUpdateAssetInfoTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideUpdateAssetInfoTransaction) getProofs() rideList {
	return o.proofs
}

func resetProofs(obj rideType) error {
	switch tx := obj.(type) {
	case rideProven:
		tx.setProofs(rideList{})
	default:
		return errors.Errorf("type '%s' is not tx", obj.instanceOf())
	}
	return nil
}
