// Code generated by ride/generate/main.go. DO NOT EDIT.

package ride

import (
	"github.com/pkg/errors"
	"strings"
)

type rideAssetV3 struct {
	issuePublicKey rideBytes
	id             rideBytes
	quantity       rideInt
	decimals       rideInt
	issuer         rideAddress
	scripted       rideBoolean
	sponsored      rideBoolean
	reissuable     rideBoolean
}

func newRideAssetV3(issuePublicKey rideBytes, id rideBytes, quantity rideInt, decimals rideInt, issuer rideAddress, scripted rideBoolean, sponsored rideBoolean, reissuable rideBoolean) rideAssetV3 {
	return rideAssetV3{
		issuePublicKey: issuePublicKey,
		id:             id,
		quantity:       quantity,
		decimals:       decimals,
		issuer:         issuer,
		scripted:       scripted,
		sponsored:      sponsored,
		reissuable:     reissuable,
	}
}

func (o rideAssetV3) instanceOf() string {
	return assetTypeName
}

func (o rideAssetV3) eq(other rideType) bool {
	if oo, ok := other.(rideAssetV3); ok {
		if !o.issuePublicKey.eq(oo.issuePublicKey) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.issuer.eq(oo.issuer) {
			return false
		}
		if !o.scripted.eq(oo.scripted) {
			return false
		}
		if !o.sponsored.eq(oo.sponsored) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideAssetV3) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(assetTypeName), nil
	case issuePublicKeyField:
		return o.issuePublicKey, nil
	case idField:
		return o.id, nil
	case quantityField:
		return o.quantity, nil
	case decimalsField:
		return o.decimals, nil
	case issuerField:
		return o.issuer, nil
	case scriptedField:
		return o.scripted, nil
	case sponsoredField:
		return o.sponsored, nil
	case reissuableField:
		return o.reissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAssetV3) copy() rideType {
	return newRideAssetV3(o.issuePublicKey, o.id, o.quantity, o.decimals, o.issuer, o.scripted, o.sponsored, o.reissuable)
}

func (o rideAssetV3) lines() []string {
	r := make([]string, 0, 10)
	r = append(r, assetTypeName+"(")
	r = append(r, fieldLines(issuerField, o.issuer.lines())...)
	r = append(r, fieldLines(scriptedField, o.scripted.lines())...)
	r = append(r, fieldLines(issuePublicKeyField, o.issuePublicKey.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(decimalsField, o.decimals.lines())...)
	r = append(r, fieldLines(reissuableField, o.reissuable.lines())...)
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, fieldLines(sponsoredField, o.sponsored.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAssetV3) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideAssetV4 struct {
	description     rideString
	name            rideString
	issuePublicKey  rideBytes
	id              rideBytes
	minSponsoredFee rideType
	decimals        rideInt
	quantity        rideInt
	issuer          rideAddress
	reissuable      rideBoolean
	scripted        rideBoolean
}

func newRideAssetV4(description rideString, name rideString, issuePublicKey rideBytes, id rideBytes, minSponsoredFee rideType, decimals rideInt, quantity rideInt, issuer rideAddress, reissuable rideBoolean, scripted rideBoolean) rideAssetV4 {
	return rideAssetV4{
		description:     description,
		name:            name,
		issuePublicKey:  issuePublicKey,
		id:              id,
		minSponsoredFee: minSponsoredFee,
		decimals:        decimals,
		quantity:        quantity,
		issuer:          issuer,
		reissuable:      reissuable,
		scripted:        scripted,
	}
}

func (o rideAssetV4) instanceOf() string {
	return assetTypeName
}

func (o rideAssetV4) eq(other rideType) bool {
	if oo, ok := other.(rideAssetV4); ok {
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.issuePublicKey.eq(oo.issuePublicKey) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.minSponsoredFee.eq(oo.minSponsoredFee) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.issuer.eq(oo.issuer) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		if !o.scripted.eq(oo.scripted) {
			return false
		}
		return true
	}
	return false
}

func (o rideAssetV4) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(assetTypeName), nil
	case descriptionField:
		return o.description, nil
	case nameField:
		return o.name, nil
	case issuePublicKeyField:
		return o.issuePublicKey, nil
	case idField:
		return o.id, nil
	case minSponsoredFeeField:
		return o.minSponsoredFee, nil
	case decimalsField:
		return o.decimals, nil
	case quantityField:
		return o.quantity, nil
	case issuerField:
		return o.issuer, nil
	case reissuableField:
		return o.reissuable, nil
	case scriptedField:
		return o.scripted, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAssetV4) copy() rideType {
	return newRideAssetV4(o.description, o.name, o.issuePublicKey, o.id, o.minSponsoredFee, o.decimals, o.quantity, o.issuer, o.reissuable, o.scripted)
}

func (o rideAssetV4) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, assetTypeName+"(")
	r = append(r, fieldLines(descriptionField, o.description.lines())...)
	r = append(r, fieldLines(issuerField, o.issuer.lines())...)
	r = append(r, fieldLines(scriptedField, o.scripted.lines())...)
	r = append(r, fieldLines(issuePublicKeyField, o.issuePublicKey.lines())...)
	r = append(r, fieldLines(minSponsoredFeeField, o.minSponsoredFee.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(decimalsField, o.decimals.lines())...)
	r = append(r, fieldLines(reissuableField, o.reissuable.lines())...)
	r = append(r, fieldLines(nameField, o.name.lines())...)
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAssetV4) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideAssetPair struct {
	amountAsset rideType
	priceAsset  rideType
}

func newRideAssetPair(amountAsset rideType, priceAsset rideType) rideAssetPair {
	return rideAssetPair{
		amountAsset: amountAsset,
		priceAsset:  priceAsset,
	}
}

func (o rideAssetPair) instanceOf() string {
	return assetPairTypeName
}

func (o rideAssetPair) eq(other rideType) bool {
	if oo, ok := other.(rideAssetPair); ok {
		if !o.amountAsset.eq(oo.amountAsset) {
			return false
		}
		if !o.priceAsset.eq(oo.priceAsset) {
			return false
		}
		return true
	}
	return false
}

func (o rideAssetPair) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(assetPairTypeName), nil
	case amountAssetField:
		return o.amountAsset, nil
	case priceAssetField:
		return o.priceAsset, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAssetPair) copy() rideType {
	return newRideAssetPair(o.amountAsset, o.priceAsset)
}

func (o rideAssetPair) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, assetPairTypeName+"(")
	r = append(r, fieldLines(amountAssetField, o.amountAsset.lines())...)
	r = append(r, fieldLines(priceAssetField, o.priceAsset.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAssetPair) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideAttachedPayment struct {
	assetID rideType
	amount  rideInt
}

func newRideAttachedPayment(assetID rideType, amount rideInt) rideAttachedPayment {
	return rideAttachedPayment{
		assetID: assetID,
		amount:  amount,
	}
}

func (o rideAttachedPayment) instanceOf() string {
	return attachedPaymentTypeName
}

func (o rideAttachedPayment) eq(other rideType) bool {
	if oo, ok := other.(rideAttachedPayment); ok {
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		return true
	}
	return false
}

func (o rideAttachedPayment) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(attachedPaymentTypeName), nil
	case assetIDField:
		return o.assetID, nil
	case amountField:
		return o.amount, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideAttachedPayment) copy() rideType {
	return newRideAttachedPayment(o.assetID, o.amount)
}

func (o rideAttachedPayment) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, attachedPaymentTypeName+"(")
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, ")")
	return r
}

func (o rideAttachedPayment) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBalanceDetails struct {
	available  rideInt
	regular    rideInt
	generating rideInt
	effective  rideInt
}

func newRideBalanceDetails(available rideInt, regular rideInt, generating rideInt, effective rideInt) rideBalanceDetails {
	return rideBalanceDetails{
		available:  available,
		regular:    regular,
		generating: generating,
		effective:  effective,
	}
}

func (o rideBalanceDetails) instanceOf() string {
	return balanceDetailsTypeName
}

func (o rideBalanceDetails) eq(other rideType) bool {
	if oo, ok := other.(rideBalanceDetails); ok {
		if !o.available.eq(oo.available) {
			return false
		}
		if !o.regular.eq(oo.regular) {
			return false
		}
		if !o.generating.eq(oo.generating) {
			return false
		}
		if !o.effective.eq(oo.effective) {
			return false
		}
		return true
	}
	return false
}

func (o rideBalanceDetails) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(balanceDetailsTypeName), nil
	case availableField:
		return o.available, nil
	case regularField:
		return o.regular, nil
	case generatingField:
		return o.generating, nil
	case effectiveField:
		return o.effective, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBalanceDetails) copy() rideType {
	return newRideBalanceDetails(o.available, o.regular, o.generating, o.effective)
}

func (o rideBalanceDetails) lines() []string {
	r := make([]string, 0, 6)
	r = append(r, balanceDetailsTypeName+"(")
	r = append(r, fieldLines(availableField, o.available.lines())...)
	r = append(r, fieldLines(regularField, o.regular.lines())...)
	r = append(r, fieldLines(generatingField, o.generating.lines())...)
	r = append(r, fieldLines(effectiveField, o.effective.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBalanceDetails) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBinaryEntry struct {
	key   rideString
	value rideBytes
}

func newRideBinaryEntry(key rideString, value rideBytes) rideBinaryEntry {
	return rideBinaryEntry{
		key:   key,
		value: value,
	}
}

func (o rideBinaryEntry) instanceOf() string {
	return binaryEntryTypeName
}

func (o rideBinaryEntry) eq(other rideType) bool {
	if oo, ok := other.(rideBinaryEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideBinaryEntry) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(binaryEntryTypeName), nil
	case keyField:
		return o.key, nil
	case valueField:
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBinaryEntry) copy() rideType {
	return newRideBinaryEntry(o.key, o.value)
}

func (o rideBinaryEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, binaryEntryTypeName+"(")
	r = append(r, fieldLines(keyField, o.key.lines())...)
	r = append(r, fieldLines(valueField, o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBinaryEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBlockInfoV3 struct {
	generationSignature rideBytes
	generatorPublicKey  rideBytes
	baseTarget          rideInt
	timestamp           rideInt
	height              rideInt
	generator           rideAddress
}

func newRideBlockInfoV3(generationSignature rideBytes, generatorPublicKey rideBytes, baseTarget rideInt, timestamp rideInt, height rideInt, generator rideAddress) rideBlockInfoV3 {
	return rideBlockInfoV3{
		generationSignature: generationSignature,
		generatorPublicKey:  generatorPublicKey,
		baseTarget:          baseTarget,
		timestamp:           timestamp,
		height:              height,
		generator:           generator,
	}
}

func (o rideBlockInfoV3) instanceOf() string {
	return blockInfoTypeName
}

func (o rideBlockInfoV3) eq(other rideType) bool {
	if oo, ok := other.(rideBlockInfoV3); ok {
		if !o.generationSignature.eq(oo.generationSignature) {
			return false
		}
		if !o.generatorPublicKey.eq(oo.generatorPublicKey) {
			return false
		}
		if !o.baseTarget.eq(oo.baseTarget) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.height.eq(oo.height) {
			return false
		}
		if !o.generator.eq(oo.generator) {
			return false
		}
		return true
	}
	return false
}

func (o rideBlockInfoV3) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(blockInfoTypeName), nil
	case generationSignatureField:
		return o.generationSignature, nil
	case generatorPublicKeyField:
		return o.generatorPublicKey, nil
	case baseTargetField:
		return o.baseTarget, nil
	case timestampField:
		return o.timestamp, nil
	case heightField:
		return o.height, nil
	case generatorField:
		return o.generator, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBlockInfoV3) copy() rideType {
	return newRideBlockInfoV3(o.generationSignature, o.generatorPublicKey, o.baseTarget, o.timestamp, o.height, o.generator)
}

func (o rideBlockInfoV3) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, blockInfoTypeName+"(")
	r = append(r, fieldLines(baseTargetField, o.baseTarget.lines())...)
	r = append(r, fieldLines(generatorField, o.generator.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(heightField, o.height.lines())...)
	r = append(r, fieldLines(generationSignatureField, o.generationSignature.lines())...)
	r = append(r, fieldLines(generatorPublicKeyField, o.generatorPublicKey.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBlockInfoV3) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBlockInfoV4 struct {
	vrf                 rideType
	generationSignature rideBytes
	generatorPublicKey  rideBytes
	baseTarget          rideInt
	timestamp           rideInt
	height              rideInt
	generator           rideAddress
}

func newRideBlockInfoV4(vrf rideType, generationSignature rideBytes, generatorPublicKey rideBytes, baseTarget rideInt, timestamp rideInt, height rideInt, generator rideAddress) rideBlockInfoV4 {
	return rideBlockInfoV4{
		vrf:                 vrf,
		generationSignature: generationSignature,
		generatorPublicKey:  generatorPublicKey,
		baseTarget:          baseTarget,
		timestamp:           timestamp,
		height:              height,
		generator:           generator,
	}
}

func (o rideBlockInfoV4) instanceOf() string {
	return blockInfoTypeName
}

func (o rideBlockInfoV4) eq(other rideType) bool {
	if oo, ok := other.(rideBlockInfoV4); ok {
		if !o.vrf.eq(oo.vrf) {
			return false
		}
		if !o.generationSignature.eq(oo.generationSignature) {
			return false
		}
		if !o.generatorPublicKey.eq(oo.generatorPublicKey) {
			return false
		}
		if !o.baseTarget.eq(oo.baseTarget) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.height.eq(oo.height) {
			return false
		}
		if !o.generator.eq(oo.generator) {
			return false
		}
		return true
	}
	return false
}

func (o rideBlockInfoV4) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(blockInfoTypeName), nil
	case vrfField:
		return o.vrf, nil
	case generationSignatureField:
		return o.generationSignature, nil
	case generatorPublicKeyField:
		return o.generatorPublicKey, nil
	case baseTargetField:
		return o.baseTarget, nil
	case timestampField:
		return o.timestamp, nil
	case heightField:
		return o.height, nil
	case generatorField:
		return o.generator, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBlockInfoV4) copy() rideType {
	return newRideBlockInfoV4(o.vrf, o.generationSignature, o.generatorPublicKey, o.baseTarget, o.timestamp, o.height, o.generator)
}

func (o rideBlockInfoV4) lines() []string {
	r := make([]string, 0, 9)
	r = append(r, blockInfoTypeName+"(")
	r = append(r, fieldLines(baseTargetField, o.baseTarget.lines())...)
	r = append(r, fieldLines(generatorField, o.generator.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(vrfField, o.vrf.lines())...)
	r = append(r, fieldLines(heightField, o.height.lines())...)
	r = append(r, fieldLines(generationSignatureField, o.generationSignature.lines())...)
	r = append(r, fieldLines(generatorPublicKeyField, o.generatorPublicKey.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBlockInfoV4) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBooleanEntry struct {
	key   rideString
	value rideBoolean
}

func newRideBooleanEntry(key rideString, value rideBoolean) rideBooleanEntry {
	return rideBooleanEntry{
		key:   key,
		value: value,
	}
}

func (o rideBooleanEntry) instanceOf() string {
	return booleanEntryTypeName
}

func (o rideBooleanEntry) eq(other rideType) bool {
	if oo, ok := other.(rideBooleanEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideBooleanEntry) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(booleanEntryTypeName), nil
	case keyField:
		return o.key, nil
	case valueField:
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBooleanEntry) copy() rideType {
	return newRideBooleanEntry(o.key, o.value)
}

func (o rideBooleanEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, booleanEntryTypeName+"(")
	r = append(r, fieldLines(keyField, o.key.lines())...)
	r = append(r, fieldLines(valueField, o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBooleanEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBurn struct {
	assetID  rideBytes
	quantity rideInt
}

func newRideBurn(assetID rideBytes, quantity rideInt) rideBurn {
	return rideBurn{
		assetID:  assetID,
		quantity: quantity,
	}
}

func (o rideBurn) instanceOf() string {
	return burnTypeName
}

func (o rideBurn) eq(other rideType) bool {
	if oo, ok := other.(rideBurn); ok {
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		return true
	}
	return false
}

func (o rideBurn) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(burnTypeName), nil
	case assetIDField:
		return o.assetID, nil
	case quantityField:
		return o.quantity, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBurn) copy() rideType {
	return newRideBurn(o.assetID, o.quantity)
}

func (o rideBurn) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, burnTypeName+"(")
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBurn) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideDataEntry struct {
	value rideType
	key   rideString
}

func newRideDataEntry(value rideType, key rideString) rideDataEntry {
	return rideDataEntry{
		value: value,
		key:   key,
	}
}

func (o rideDataEntry) instanceOf() string {
	return dataEntryTypeName
}

func (o rideDataEntry) eq(other rideType) bool {
	if oo, ok := other.(rideDataEntry); ok {
		if !o.value.eq(oo.value) {
			return false
		}
		if !o.key.eq(oo.key) {
			return false
		}
		return true
	}
	return false
}

func (o rideDataEntry) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(dataEntryTypeName), nil
	case valueField:
		return o.value, nil
	case keyField:
		return o.key, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideDataEntry) copy() rideType {
	return newRideDataEntry(o.value, o.key)
}

func (o rideDataEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, dataEntryTypeName+"(")
	r = append(r, fieldLines(keyField, o.key.lines())...)
	r = append(r, fieldLines(valueField, o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideDataEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideDeleteEntry struct {
	key rideString
}

func newRideDeleteEntry(key rideString) rideDeleteEntry {
	return rideDeleteEntry{
		key: key,
	}
}

func (o rideDeleteEntry) instanceOf() string {
	return deleteEntryTypeName
}

func (o rideDeleteEntry) eq(other rideType) bool {
	if oo, ok := other.(rideDeleteEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		return true
	}
	return false
}

func (o rideDeleteEntry) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(deleteEntryTypeName), nil
	case keyField:
		return o.key, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideDeleteEntry) copy() rideType {
	return newRideDeleteEntry(o.key)
}

func (o rideDeleteEntry) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, deleteEntryTypeName+"(")
	r = append(r, fieldLines(keyField, o.key.lines())...)
	r = append(r, ")")
	return r
}

func (o rideDeleteEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideIntegerEntry struct {
	key   rideString
	value rideInt
}

func newRideIntegerEntry(key rideString, value rideInt) rideIntegerEntry {
	return rideIntegerEntry{
		key:   key,
		value: value,
	}
}

func (o rideIntegerEntry) instanceOf() string {
	return integerEntryTypeName
}

func (o rideIntegerEntry) eq(other rideType) bool {
	if oo, ok := other.(rideIntegerEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideIntegerEntry) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(integerEntryTypeName), nil
	case keyField:
		return o.key, nil
	case valueField:
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideIntegerEntry) copy() rideType {
	return newRideIntegerEntry(o.key, o.value)
}

func (o rideIntegerEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, integerEntryTypeName+"(")
	r = append(r, fieldLines(keyField, o.key.lines())...)
	r = append(r, fieldLines(valueField, o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideIntegerEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvocationV3 struct {
	payment         rideType
	callerPublicKey rideBytes
	feeAssetID      rideType
	transactionID   rideBytes
	caller          rideAddress
	fee             rideInt
}

func newRideInvocationV3(payment rideType, callerPublicKey rideBytes, feeAssetID rideType, transactionID rideBytes, caller rideAddress, fee rideInt) rideInvocationV3 {
	return rideInvocationV3{
		payment:         payment,
		callerPublicKey: callerPublicKey,
		feeAssetID:      feeAssetID,
		transactionID:   transactionID,
		caller:          caller,
		fee:             fee,
	}
}

func (o rideInvocationV3) instanceOf() string {
	return invocationTypeName
}

func (o rideInvocationV3) eq(other rideType) bool {
	if oo, ok := other.(rideInvocationV3); ok {
		if !o.payment.eq(oo.payment) {
			return false
		}
		if !o.callerPublicKey.eq(oo.callerPublicKey) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.transactionID.eq(oo.transactionID) {
			return false
		}
		if !o.caller.eq(oo.caller) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvocationV3) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(invocationTypeName), nil
	case paymentField:
		return o.payment, nil
	case callerPublicKeyField:
		return o.callerPublicKey, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case transactionIDField:
		return o.transactionID, nil
	case callerField:
		return o.caller, nil
	case feeField:
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvocationV3) copy() rideType {
	return newRideInvocationV3(o.payment, o.callerPublicKey, o.feeAssetID, o.transactionID, o.caller, o.fee)
}

func (o rideInvocationV3) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, invocationTypeName+"(")
	r = append(r, fieldLines(paymentField, o.payment.lines())...)
	r = append(r, fieldLines(callerPublicKeyField, o.callerPublicKey.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(transactionIDField, o.transactionID.lines())...)
	r = append(r, fieldLines(callerField, o.caller.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvocationV3) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvocationV4 struct {
	payments        rideList
	callerPublicKey rideBytes
	feeAssetID      rideType
	transactionID   rideBytes
	caller          rideAddress
	fee             rideInt
}

func newRideInvocationV4(payments rideList, callerPublicKey rideBytes, feeAssetID rideType, transactionID rideBytes, caller rideAddress, fee rideInt) rideInvocationV4 {
	return rideInvocationV4{
		payments:        payments,
		callerPublicKey: callerPublicKey,
		feeAssetID:      feeAssetID,
		transactionID:   transactionID,
		caller:          caller,
		fee:             fee,
	}
}

func (o rideInvocationV4) instanceOf() string {
	return invocationTypeName
}

func (o rideInvocationV4) eq(other rideType) bool {
	if oo, ok := other.(rideInvocationV4); ok {
		if !o.payments.eq(oo.payments) {
			return false
		}
		if !o.callerPublicKey.eq(oo.callerPublicKey) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.transactionID.eq(oo.transactionID) {
			return false
		}
		if !o.caller.eq(oo.caller) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvocationV4) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(invocationTypeName), nil
	case paymentsField:
		return o.payments, nil
	case callerPublicKeyField:
		return o.callerPublicKey, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case transactionIDField:
		return o.transactionID, nil
	case callerField:
		return o.caller, nil
	case feeField:
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvocationV4) copy() rideType {
	return newRideInvocationV4(o.payments, o.callerPublicKey, o.feeAssetID, o.transactionID, o.caller, o.fee)
}

func (o rideInvocationV4) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, invocationTypeName+"(")
	r = append(r, fieldLines(paymentsField, o.payments.lines())...)
	r = append(r, fieldLines(callerPublicKeyField, o.callerPublicKey.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(transactionIDField, o.transactionID.lines())...)
	r = append(r, fieldLines(callerField, o.caller.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvocationV4) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvocationV5 struct {
	originCaller          rideType
	payments              rideList
	callerPublicKey       rideBytes
	feeAssetID            rideType
	originCallerPublicKey rideType
	transactionID         rideBytes
	caller                rideAddress
	fee                   rideInt
}

func newRideInvocationV5(originCaller rideType, payments rideList, callerPublicKey rideBytes, feeAssetID rideType, originCallerPublicKey rideType, transactionID rideBytes, caller rideAddress, fee rideInt) rideInvocationV5 {
	return rideInvocationV5{
		originCaller:          originCaller,
		payments:              payments,
		callerPublicKey:       callerPublicKey,
		feeAssetID:            feeAssetID,
		originCallerPublicKey: originCallerPublicKey,
		transactionID:         transactionID,
		caller:                caller,
		fee:                   fee,
	}
}

func (o rideInvocationV5) instanceOf() string {
	return invocationTypeName
}

func (o rideInvocationV5) eq(other rideType) bool {
	if oo, ok := other.(rideInvocationV5); ok {
		if !o.originCaller.eq(oo.originCaller) {
			return false
		}
		if !o.payments.eq(oo.payments) {
			return false
		}
		if !o.callerPublicKey.eq(oo.callerPublicKey) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.originCallerPublicKey.eq(oo.originCallerPublicKey) {
			return false
		}
		if !o.transactionID.eq(oo.transactionID) {
			return false
		}
		if !o.caller.eq(oo.caller) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvocationV5) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(invocationTypeName), nil
	case originCallerField:
		return o.originCaller, nil
	case paymentsField:
		return o.payments, nil
	case callerPublicKeyField:
		return o.callerPublicKey, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case originCallerPublicKeyField:
		return o.originCallerPublicKey, nil
	case transactionIDField:
		return o.transactionID, nil
	case callerField:
		return o.caller, nil
	case feeField:
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvocationV5) copy() rideType {
	return newRideInvocationV5(o.originCaller, o.payments, o.callerPublicKey, o.feeAssetID, o.originCallerPublicKey, o.transactionID, o.caller, o.fee)
}

func (o rideInvocationV5) lines() []string {
	r := make([]string, 0, 10)
	r = append(r, invocationTypeName+"(")
	r = append(r, fieldLines(originCallerField, o.originCaller.lines())...)
	r = append(r, fieldLines(paymentsField, o.payments.lines())...)
	r = append(r, fieldLines(callerPublicKeyField, o.callerPublicKey.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(originCallerPublicKeyField, o.originCallerPublicKey.lines())...)
	r = append(r, fieldLines(transactionIDField, o.transactionID.lines())...)
	r = append(r, fieldLines(callerField, o.caller.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvocationV5) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideIssue struct {
	compiledScript rideType
	name           rideString
	description    rideString
	nonce          rideInt
	decimals       rideInt
	quantity       rideInt
	isReissuable   rideBoolean
}

func newRideIssue(compiledScript rideType, name rideString, description rideString, nonce rideInt, decimals rideInt, quantity rideInt, isReissuable rideBoolean) rideIssue {
	return rideIssue{
		compiledScript: compiledScript,
		name:           name,
		description:    description,
		nonce:          nonce,
		decimals:       decimals,
		quantity:       quantity,
		isReissuable:   isReissuable,
	}
}

func (o rideIssue) instanceOf() string {
	return issueTypeName
}

func (o rideIssue) eq(other rideType) bool {
	if oo, ok := other.(rideIssue); ok {
		if !o.compiledScript.eq(oo.compiledScript) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.nonce.eq(oo.nonce) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.isReissuable.eq(oo.isReissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideIssue) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(issueTypeName), nil
	case compiledScriptField:
		return o.compiledScript, nil
	case nameField:
		return o.name, nil
	case descriptionField:
		return o.description, nil
	case nonceField:
		return o.nonce, nil
	case decimalsField:
		return o.decimals, nil
	case quantityField:
		return o.quantity, nil
	case isReissuableField:
		return o.isReissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideIssue) copy() rideType {
	return newRideIssue(o.compiledScript, o.name, o.description, o.nonce, o.decimals, o.quantity, o.isReissuable)
}

func (o rideIssue) lines() []string {
	r := make([]string, 0, 9)
	r = append(r, issueTypeName+"(")
	r = append(r, fieldLines(isReissuableField, o.isReissuable.lines())...)
	r = append(r, fieldLines(nonceField, o.nonce.lines())...)
	r = append(r, fieldLines(descriptionField, o.description.lines())...)
	r = append(r, fieldLines(decimalsField, o.decimals.lines())...)
	r = append(r, fieldLines(compiledScriptField, o.compiledScript.lines())...)
	r = append(r, fieldLines(nameField, o.name.lines())...)
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, ")")
	return r
}

func (o rideIssue) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideLeaseCancel struct {
	leaseID rideBytes
}

func newRideLeaseCancel(leaseID rideBytes) rideLeaseCancel {
	return rideLeaseCancel{
		leaseID: leaseID,
	}
}

func (o rideLeaseCancel) instanceOf() string {
	return leaseCancelTypeName
}

func (o rideLeaseCancel) eq(other rideType) bool {
	if oo, ok := other.(rideLeaseCancel); ok {
		if !o.leaseID.eq(oo.leaseID) {
			return false
		}
		return true
	}
	return false
}

func (o rideLeaseCancel) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(leaseCancelTypeName), nil
	case leaseIDField:
		return o.leaseID, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLeaseCancel) copy() rideType {
	return newRideLeaseCancel(o.leaseID)
}

func (o rideLeaseCancel) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, leaseCancelTypeName+"(")
	r = append(r, fieldLines(leaseIDField, o.leaseID.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLeaseCancel) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideLease struct {
	recipient rideType
	amount    rideInt
	nonce     rideInt
}

func newRideLease(recipient rideType, amount rideInt, nonce rideInt) rideLease {
	return rideLease{
		recipient: recipient,
		amount:    amount,
		nonce:     nonce,
	}
}

func (o rideLease) instanceOf() string {
	return leaseTypeName
}

func (o rideLease) eq(other rideType) bool {
	if oo, ok := other.(rideLease); ok {
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.nonce.eq(oo.nonce) {
			return false
		}
		return true
	}
	return false
}

func (o rideLease) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(leaseTypeName), nil
	case recipientField:
		return o.recipient, nil
	case amountField:
		return o.amount, nil
	case nonceField:
		return o.nonce, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLease) copy() rideType {
	return newRideLease(o.recipient, o.amount, o.nonce)
}

func (o rideLease) lines() []string {
	r := make([]string, 0, 5)
	r = append(r, leaseTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(nonceField, o.nonce.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLease) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideOrder struct {
	assetPair         rideType
	orderType         rideType
	matcherFeeAssetID rideType
	proofs            rideList
	bodyBytes         rideBytes
	id                rideBytes
	senderPublicKey   rideBytes
	matcherPublicKey  rideBytes
	amount            rideInt
	timestamp         rideInt
	expiration        rideInt
	matcherFee        rideInt
	price             rideInt
	sender            rideAddress
}

func newRideOrder(assetPair rideType, orderType rideType, matcherFeeAssetID rideType, proofs rideList, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, matcherPublicKey rideBytes, amount rideInt, timestamp rideInt, expiration rideInt, matcherFee rideInt, price rideInt, sender rideAddress) rideOrder {
	return rideOrder{
		assetPair:         assetPair,
		orderType:         orderType,
		matcherFeeAssetID: matcherFeeAssetID,
		proofs:            proofs,
		bodyBytes:         bodyBytes,
		id:                id,
		senderPublicKey:   senderPublicKey,
		matcherPublicKey:  matcherPublicKey,
		amount:            amount,
		timestamp:         timestamp,
		expiration:        expiration,
		matcherFee:        matcherFee,
		price:             price,
		sender:            sender,
	}
}

func (o rideOrder) instanceOf() string {
	return orderTypeName
}

func (o rideOrder) eq(other rideType) bool {
	if oo, ok := other.(rideOrder); ok {
		if !o.assetPair.eq(oo.assetPair) {
			return false
		}
		if !o.orderType.eq(oo.orderType) {
			return false
		}
		if !o.matcherFeeAssetID.eq(oo.matcherFeeAssetID) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.matcherPublicKey.eq(oo.matcherPublicKey) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.expiration.eq(oo.expiration) {
			return false
		}
		if !o.matcherFee.eq(oo.matcherFee) {
			return false
		}
		if !o.price.eq(oo.price) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideOrder) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(orderTypeName), nil
	case assetPairField:
		return o.assetPair, nil
	case orderTypeField:
		return o.orderType, nil
	case matcherFeeAssetIDField:
		return o.matcherFeeAssetID, nil
	case proofsField:
		return o.proofs, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case matcherPublicKeyField:
		return o.matcherPublicKey, nil
	case amountField:
		return o.amount, nil
	case timestampField:
		return o.timestamp, nil
	case expirationField:
		return o.expiration, nil
	case matcherFeeField:
		return o.matcherFee, nil
	case priceField:
		return o.price, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideOrder) copy() rideType {
	return newRideOrder(o.assetPair, o.orderType, o.matcherFeeAssetID, o.proofs, o.bodyBytes, o.id, o.senderPublicKey, o.matcherPublicKey, o.amount, o.timestamp, o.expiration, o.matcherFee, o.price, o.sender)
}

func (o rideOrder) lines() []string {
	r := make([]string, 0, 16)
	r = append(r, orderTypeName+"(")
	r = append(r, fieldLines(assetPairField, o.assetPair.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(matcherFeeAssetIDField, o.matcherFeeAssetID.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(matcherPublicKeyField, o.matcherPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(orderTypeField, o.orderType.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(expirationField, o.expiration.lines())...)
	r = append(r, fieldLines(matcherFeeField, o.matcherFee.lines())...)
	r = append(r, fieldLines(priceField, o.price.lines())...)
	r = append(r, ")")
	return r
}

func (o rideOrder) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideOrder) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideOrder) getProofs() rideList {
	return o.proofs
}

type rideReissue struct {
	assetID      rideBytes
	quantity     rideInt
	isReissuable rideBoolean
}

func newRideReissue(assetID rideBytes, quantity rideInt, isReissuable rideBoolean) rideReissue {
	return rideReissue{
		assetID:      assetID,
		quantity:     quantity,
		isReissuable: isReissuable,
	}
}

func (o rideReissue) instanceOf() string {
	return reissueTypeName
}

func (o rideReissue) eq(other rideType) bool {
	if oo, ok := other.(rideReissue); ok {
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.isReissuable.eq(oo.isReissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideReissue) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(reissueTypeName), nil
	case assetIDField:
		return o.assetID, nil
	case quantityField:
		return o.quantity, nil
	case isReissuableField:
		return o.isReissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideReissue) copy() rideType {
	return newRideReissue(o.assetID, o.quantity, o.isReissuable)
}

func (o rideReissue) lines() []string {
	r := make([]string, 0, 5)
	r = append(r, reissueTypeName+"(")
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, fieldLines(isReissuableField, o.isReissuable.lines())...)
	r = append(r, ")")
	return r
}

func (o rideReissue) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideScriptResult struct {
	writeSet    rideWriteSet
	transferSet rideTransferSet
}

func newRideScriptResult(writeSet rideWriteSet, transferSet rideTransferSet) rideScriptResult {
	return rideScriptResult{
		writeSet:    writeSet,
		transferSet: transferSet,
	}
}

func (o rideScriptResult) instanceOf() string {
	return scriptResultTypeName
}

func (o rideScriptResult) eq(other rideType) bool {
	if oo, ok := other.(rideScriptResult); ok {
		if !o.writeSet.eq(oo.writeSet) {
			return false
		}
		if !o.transferSet.eq(oo.transferSet) {
			return false
		}
		return true
	}
	return false
}

func (o rideScriptResult) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(scriptResultTypeName), nil
	case writeSetField:
		return o.writeSet, nil
	case transferSetField:
		return o.transferSet, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideScriptResult) copy() rideType {
	return newRideScriptResult(o.writeSet, o.transferSet)
}

func (o rideScriptResult) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, scriptResultTypeName+"(")
	r = append(r, fieldLines(writeSetField, o.writeSet.lines())...)
	r = append(r, fieldLines(transferSetField, o.transferSet.lines())...)
	r = append(r, ")")
	return r
}

func (o rideScriptResult) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideScriptTransfer struct {
	asset     rideType
	recipient rideType
	amount    rideInt
}

func newRideScriptTransfer(asset rideType, recipient rideType, amount rideInt) rideScriptTransfer {
	return rideScriptTransfer{
		asset:     asset,
		recipient: recipient,
		amount:    amount,
	}
}

func (o rideScriptTransfer) instanceOf() string {
	return scriptTransferTypeName
}

func (o rideScriptTransfer) eq(other rideType) bool {
	if oo, ok := other.(rideScriptTransfer); ok {
		if !o.asset.eq(oo.asset) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		return true
	}
	return false
}

func (o rideScriptTransfer) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(scriptTransferTypeName), nil
	case assetField:
		return o.asset, nil
	case recipientField:
		return o.recipient, nil
	case amountField:
		return o.amount, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideScriptTransfer) copy() rideType {
	return newRideScriptTransfer(o.asset, o.recipient, o.amount)
}

func (o rideScriptTransfer) lines() []string {
	r := make([]string, 0, 5)
	r = append(r, scriptTransferTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(assetField, o.asset.lines())...)
	r = append(r, ")")
	return r
}

func (o rideScriptTransfer) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideSponsorFee struct {
	assetID              rideBytes
	minSponsoredAssetFee rideInt
}

func newRideSponsorFee(assetID rideBytes, minSponsoredAssetFee rideInt) rideSponsorFee {
	return rideSponsorFee{
		assetID:              assetID,
		minSponsoredAssetFee: minSponsoredAssetFee,
	}
}

func (o rideSponsorFee) instanceOf() string {
	return sponsorFeeTypeName
}

func (o rideSponsorFee) eq(other rideType) bool {
	if oo, ok := other.(rideSponsorFee); ok {
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.minSponsoredAssetFee.eq(oo.minSponsoredAssetFee) {
			return false
		}
		return true
	}
	return false
}

func (o rideSponsorFee) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(sponsorFeeTypeName), nil
	case assetIDField:
		return o.assetID, nil
	case minSponsoredAssetFeeField:
		return o.minSponsoredAssetFee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSponsorFee) copy() rideType {
	return newRideSponsorFee(o.assetID, o.minSponsoredAssetFee)
}

func (o rideSponsorFee) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, sponsorFeeTypeName+"(")
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(minSponsoredAssetFeeField, o.minSponsoredAssetFee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSponsorFee) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideStringEntry struct {
	key   rideString
	value rideString
}

func newRideStringEntry(key rideString, value rideString) rideStringEntry {
	return rideStringEntry{
		key:   key,
		value: value,
	}
}

func (o rideStringEntry) instanceOf() string {
	return stringEntryTypeName
}

func (o rideStringEntry) eq(other rideType) bool {
	if oo, ok := other.(rideStringEntry); ok {
		if !o.key.eq(oo.key) {
			return false
		}
		if !o.value.eq(oo.value) {
			return false
		}
		return true
	}
	return false
}

func (o rideStringEntry) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(stringEntryTypeName), nil
	case keyField:
		return o.key, nil
	case valueField:
		return o.value, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideStringEntry) copy() rideType {
	return newRideStringEntry(o.key, o.value)
}

func (o rideStringEntry) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, stringEntryTypeName+"(")
	r = append(r, fieldLines(keyField, o.key.lines())...)
	r = append(r, fieldLines(valueField, o.value.lines())...)
	r = append(r, ")")
	return r
}

func (o rideStringEntry) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideTransfer struct {
	recipient rideType
	amount    rideInt
}

func newRideTransfer(recipient rideType, amount rideInt) rideTransfer {
	return rideTransfer{
		recipient: recipient,
		amount:    amount,
	}
}

func (o rideTransfer) instanceOf() string {
	return transferTypeName
}

func (o rideTransfer) eq(other rideType) bool {
	if oo, ok := other.(rideTransfer); ok {
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		return true
	}
	return false
}

func (o rideTransfer) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(transferTypeName), nil
	case recipientField:
		return o.recipient, nil
	case amountField:
		return o.amount, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideTransfer) copy() rideType {
	return newRideTransfer(o.recipient, o.amount)
}

func (o rideTransfer) lines() []string {
	r := make([]string, 0, 4)
	r = append(r, transferTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, ")")
	return r
}

func (o rideTransfer) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideTransferSet struct {
	transfers rideList
}

func newRideTransferSet(transfers rideList) rideTransferSet {
	return rideTransferSet{
		transfers: transfers,
	}
}

func (o rideTransferSet) instanceOf() string {
	return transferSetTypeName
}

func (o rideTransferSet) eq(other rideType) bool {
	if oo, ok := other.(rideTransferSet); ok {
		if !o.transfers.eq(oo.transfers) {
			return false
		}
		return true
	}
	return false
}

func (o rideTransferSet) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(transferSetTypeName), nil
	case transfersField:
		return o.transfers, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideTransferSet) copy() rideType {
	return newRideTransferSet(o.transfers)
}

func (o rideTransferSet) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, transferSetTypeName+"(")
	r = append(r, fieldLines(transfersField, o.transfers.lines())...)
	r = append(r, ")")
	return r
}

func (o rideTransferSet) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideWriteSet struct {
	data rideList
}

func newRideWriteSet(data rideList) rideWriteSet {
	return rideWriteSet{
		data: data,
	}
}

func (o rideWriteSet) instanceOf() string {
	return writeSetTypeName
}

func (o rideWriteSet) eq(other rideType) bool {
	if oo, ok := other.(rideWriteSet); ok {
		if !o.data.eq(oo.data) {
			return false
		}
		return true
	}
	return false
}

func (o rideWriteSet) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(writeSetTypeName), nil
	case dataField:
		return o.data, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideWriteSet) copy() rideType {
	return newRideWriteSet(o.data)
}

func (o rideWriteSet) lines() []string {
	r := make([]string, 0, 3)
	r = append(r, writeSetTypeName+"(")
	r = append(r, fieldLines(dataField, o.data.lines())...)
	r = append(r, ")")
	return r
}

func (o rideWriteSet) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideBurnTransaction struct {
	bodyBytes       rideType
	proofs          rideList
	senderPublicKey rideBytes
	assetID         rideBytes
	id              rideBytes
	timestamp       rideInt
	version         rideInt
	quantity        rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideBurnTransaction(bodyBytes rideType, proofs rideList, senderPublicKey rideBytes, assetID rideBytes, id rideBytes, timestamp rideInt, version rideInt, quantity rideInt, fee rideInt, sender rideAddress) rideBurnTransaction {
	return rideBurnTransaction{
		bodyBytes:       bodyBytes,
		proofs:          proofs,
		senderPublicKey: senderPublicKey,
		assetID:         assetID,
		id:              id,
		timestamp:       timestamp,
		version:         version,
		quantity:        quantity,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideBurnTransaction) instanceOf() string {
	return burnTransactionTypeName
}

func (o rideBurnTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideBurnTransaction); ok {
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideBurnTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(burnTransactionTypeName), nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case proofsField:
		return o.proofs, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case assetIDField:
		return o.assetID, nil
	case idField:
		return o.id, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case quantityField:
		return o.quantity, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideBurnTransaction) copy() rideType {
	return newRideBurnTransaction(o.bodyBytes, o.proofs, o.senderPublicKey, o.assetID, o.id, o.timestamp, o.version, o.quantity, o.fee, o.sender)
}

func (o rideBurnTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, burnTransactionTypeName+"(")
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideBurnTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideBurnTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideBurnTransaction) getProofs() rideList {
	return o.proofs
}

type rideCreateAliasTransaction struct {
	proofs          rideList
	alias           rideString
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	fee             rideInt
	version         rideInt
	sender          rideAddress
}

func newRideCreateAliasTransaction(proofs rideList, alias rideString, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, fee rideInt, version rideInt, sender rideAddress) rideCreateAliasTransaction {
	return rideCreateAliasTransaction{
		proofs:          proofs,
		alias:           alias,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		fee:             fee,
		version:         version,
		sender:          sender,
	}
}

func (o rideCreateAliasTransaction) instanceOf() string {
	return createAliasTransactionTypeName
}

func (o rideCreateAliasTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideCreateAliasTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.alias.eq(oo.alias) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideCreateAliasTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(createAliasTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case aliasField:
		return o.alias, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case feeField:
		return o.fee, nil
	case versionField:
		return o.version, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideCreateAliasTransaction) copy() rideType {
	return newRideCreateAliasTransaction(o.proofs, o.alias, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.fee, o.version, o.sender)
}

func (o rideCreateAliasTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, createAliasTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, fieldLines(aliasField, o.alias.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, ")")
	return r
}

func (o rideCreateAliasTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideCreateAliasTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideCreateAliasTransaction) getProofs() rideList {
	return o.proofs
}

type rideDataTransaction struct {
	proofs          rideList
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	data            rideList
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideDataTransaction(proofs rideList, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, data rideList, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideDataTransaction {
	return rideDataTransaction{
		proofs:          proofs,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		data:            data,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideDataTransaction) instanceOf() string {
	return dataTransactionTypeName
}

func (o rideDataTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideDataTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.data.eq(oo.data) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideDataTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(dataTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case dataField:
		return o.data, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideDataTransaction) copy() rideType {
	return newRideDataTransaction(o.proofs, o.bodyBytes, o.id, o.senderPublicKey, o.data, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideDataTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, dataTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(dataField, o.data.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideDataTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideDataTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideDataTransaction) getProofs() rideList {
	return o.proofs
}

type rideExchangeTransaction struct {
	proofs          rideList
	buyOrder        rideType
	sellOrder       rideType
	id              rideBytes
	bodyBytes       rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	price           rideInt
	amount          rideInt
	version         rideInt
	buyMatcherFee   rideInt
	fee             rideInt
	sellMatcherFee  rideInt
	sender          rideAddress
}

func newRideExchangeTransaction(proofs rideList, buyOrder rideType, sellOrder rideType, id rideBytes, bodyBytes rideBytes, senderPublicKey rideBytes, timestamp rideInt, price rideInt, amount rideInt, version rideInt, buyMatcherFee rideInt, fee rideInt, sellMatcherFee rideInt, sender rideAddress) rideExchangeTransaction {
	return rideExchangeTransaction{
		proofs:          proofs,
		buyOrder:        buyOrder,
		sellOrder:       sellOrder,
		id:              id,
		bodyBytes:       bodyBytes,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		price:           price,
		amount:          amount,
		version:         version,
		buyMatcherFee:   buyMatcherFee,
		fee:             fee,
		sellMatcherFee:  sellMatcherFee,
		sender:          sender,
	}
}

func (o rideExchangeTransaction) instanceOf() string {
	return exchangeTransactionTypeName
}

func (o rideExchangeTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideExchangeTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.buyOrder.eq(oo.buyOrder) {
			return false
		}
		if !o.sellOrder.eq(oo.sellOrder) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.price.eq(oo.price) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.buyMatcherFee.eq(oo.buyMatcherFee) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sellMatcherFee.eq(oo.sellMatcherFee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideExchangeTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(exchangeTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case buyOrderField:
		return o.buyOrder, nil
	case sellOrderField:
		return o.sellOrder, nil
	case idField:
		return o.id, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case priceField:
		return o.price, nil
	case amountField:
		return o.amount, nil
	case versionField:
		return o.version, nil
	case buyMatcherFeeField:
		return o.buyMatcherFee, nil
	case feeField:
		return o.fee, nil
	case sellMatcherFeeField:
		return o.sellMatcherFee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideExchangeTransaction) copy() rideType {
	return newRideExchangeTransaction(o.proofs, o.buyOrder, o.sellOrder, o.id, o.bodyBytes, o.senderPublicKey, o.timestamp, o.price, o.amount, o.version, o.buyMatcherFee, o.fee, o.sellMatcherFee, o.sender)
}

func (o rideExchangeTransaction) lines() []string {
	r := make([]string, 0, 16)
	r = append(r, exchangeTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(buyOrderField, o.buyOrder.lines())...)
	r = append(r, fieldLines(priceField, o.price.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(sellOrderField, o.sellOrder.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(buyMatcherFeeField, o.buyMatcherFee.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(sellMatcherFeeField, o.sellMatcherFee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideExchangeTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideExchangeTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideExchangeTransaction) getProofs() rideList {
	return o.proofs
}

type rideGenesisTransaction struct {
	recipient rideType
	id        rideBytes
	timestamp rideInt
	amount    rideInt
	version   rideInt
	fee       rideInt
}

func newRideGenesisTransaction(recipient rideType, id rideBytes, timestamp rideInt, amount rideInt, version rideInt, fee rideInt) rideGenesisTransaction {
	return rideGenesisTransaction{
		recipient: recipient,
		id:        id,
		timestamp: timestamp,
		amount:    amount,
		version:   version,
		fee:       fee,
	}
}

func (o rideGenesisTransaction) instanceOf() string {
	return genesisTransactionTypeName
}

func (o rideGenesisTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideGenesisTransaction); ok {
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		return true
	}
	return false
}

func (o rideGenesisTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(genesisTransactionTypeName), nil
	case recipientField:
		return o.recipient, nil
	case idField:
		return o.id, nil
	case timestampField:
		return o.timestamp, nil
	case amountField:
		return o.amount, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideGenesisTransaction) copy() rideType {
	return newRideGenesisTransaction(o.recipient, o.id, o.timestamp, o.amount, o.version, o.fee)
}

func (o rideGenesisTransaction) lines() []string {
	r := make([]string, 0, 8)
	r = append(r, genesisTransactionTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideGenesisTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

type rideInvokeExpressionTransaction struct {
	proofs          rideList
	feeAssetID      rideType
	bodyBytes       rideBytes
	id              rideBytes
	expression      rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideInvokeExpressionTransaction(proofs rideList, feeAssetID rideType, bodyBytes rideBytes, id rideBytes, expression rideBytes, senderPublicKey rideBytes, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideInvokeExpressionTransaction {
	return rideInvokeExpressionTransaction{
		proofs:          proofs,
		feeAssetID:      feeAssetID,
		bodyBytes:       bodyBytes,
		id:              id,
		expression:      expression,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideInvokeExpressionTransaction) instanceOf() string {
	return invokeExpressionTransactionTypeName
}

func (o rideInvokeExpressionTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideInvokeExpressionTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.expression.eq(oo.expression) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvokeExpressionTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(invokeExpressionTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case expressionField:
		return o.expression, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvokeExpressionTransaction) copy() rideType {
	return newRideInvokeExpressionTransaction(o.proofs, o.feeAssetID, o.bodyBytes, o.id, o.expression, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideInvokeExpressionTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, invokeExpressionTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(expressionField, o.expression.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvokeExpressionTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideInvokeExpressionTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideInvokeExpressionTransaction) getProofs() rideList {
	return o.proofs
}

type rideInvokeScriptTransactionV3 struct {
	proofs          rideList
	feeAssetID      rideType
	dApp            rideType
	function        rideString
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	payment         rideType
	args            rideList
	timestamp       rideInt
	fee             rideInt
	version         rideInt
	sender          rideAddress
}

func newRideInvokeScriptTransactionV3(proofs rideList, feeAssetID rideType, dApp rideType, function rideString, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, payment rideType, args rideList, timestamp rideInt, fee rideInt, version rideInt, sender rideAddress) rideInvokeScriptTransactionV3 {
	return rideInvokeScriptTransactionV3{
		proofs:          proofs,
		feeAssetID:      feeAssetID,
		dApp:            dApp,
		function:        function,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		payment:         payment,
		args:            args,
		timestamp:       timestamp,
		fee:             fee,
		version:         version,
		sender:          sender,
	}
}

func (o rideInvokeScriptTransactionV3) instanceOf() string {
	return invokeScriptTransactionTypeName
}

func (o rideInvokeScriptTransactionV3) eq(other rideType) bool {
	if oo, ok := other.(rideInvokeScriptTransactionV3); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.dApp.eq(oo.dApp) {
			return false
		}
		if !o.function.eq(oo.function) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.payment.eq(oo.payment) {
			return false
		}
		if !o.args.eq(oo.args) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvokeScriptTransactionV3) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(invokeScriptTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case dAppField:
		return o.dApp, nil
	case functionField:
		return o.function, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case paymentField:
		return o.payment, nil
	case argsField:
		return o.args, nil
	case timestampField:
		return o.timestamp, nil
	case feeField:
		return o.fee, nil
	case versionField:
		return o.version, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvokeScriptTransactionV3) copy() rideType {
	return newRideInvokeScriptTransactionV3(o.proofs, o.feeAssetID, o.dApp, o.function, o.bodyBytes, o.id, o.senderPublicKey, o.payment, o.args, o.timestamp, o.fee, o.version, o.sender)
}

func (o rideInvokeScriptTransactionV3) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, invokeScriptTransactionTypeName+"(")
	r = append(r, fieldLines(paymentField, o.payment.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, fieldLines(dAppField, o.dApp.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(functionField, o.function.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(argsField, o.args.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvokeScriptTransactionV3) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideInvokeScriptTransactionV3) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideInvokeScriptTransactionV3) getProofs() rideList {
	return o.proofs
}

type rideInvokeScriptTransactionV4 struct {
	proofs          rideList
	feeAssetID      rideType
	dApp            rideType
	function        rideString
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	payments        rideList
	args            rideList
	timestamp       rideInt
	fee             rideInt
	version         rideInt
	sender          rideAddress
}

func newRideInvokeScriptTransactionV4(proofs rideList, feeAssetID rideType, dApp rideType, function rideString, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, payments rideList, args rideList, timestamp rideInt, fee rideInt, version rideInt, sender rideAddress) rideInvokeScriptTransactionV4 {
	return rideInvokeScriptTransactionV4{
		proofs:          proofs,
		feeAssetID:      feeAssetID,
		dApp:            dApp,
		function:        function,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		payments:        payments,
		args:            args,
		timestamp:       timestamp,
		fee:             fee,
		version:         version,
		sender:          sender,
	}
}

func (o rideInvokeScriptTransactionV4) instanceOf() string {
	return invokeScriptTransactionTypeName
}

func (o rideInvokeScriptTransactionV4) eq(other rideType) bool {
	if oo, ok := other.(rideInvokeScriptTransactionV4); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.dApp.eq(oo.dApp) {
			return false
		}
		if !o.function.eq(oo.function) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.payments.eq(oo.payments) {
			return false
		}
		if !o.args.eq(oo.args) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideInvokeScriptTransactionV4) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(invokeScriptTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case dAppField:
		return o.dApp, nil
	case functionField:
		return o.function, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case paymentsField:
		return o.payments, nil
	case argsField:
		return o.args, nil
	case timestampField:
		return o.timestamp, nil
	case feeField:
		return o.fee, nil
	case versionField:
		return o.version, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideInvokeScriptTransactionV4) copy() rideType {
	return newRideInvokeScriptTransactionV4(o.proofs, o.feeAssetID, o.dApp, o.function, o.bodyBytes, o.id, o.senderPublicKey, o.payments, o.args, o.timestamp, o.fee, o.version, o.sender)
}

func (o rideInvokeScriptTransactionV4) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, invokeScriptTransactionTypeName+"(")
	r = append(r, fieldLines(paymentsField, o.payments.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, fieldLines(dAppField, o.dApp.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(functionField, o.function.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(argsField, o.args.lines())...)
	r = append(r, ")")
	return r
}

func (o rideInvokeScriptTransactionV4) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideInvokeScriptTransactionV4) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideInvokeScriptTransactionV4) getProofs() rideList {
	return o.proofs
}

type rideIssueTransaction struct {
	proofs          rideList
	script          rideType
	description     rideString
	name            rideString
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	quantity        rideInt
	decimals        rideInt
	reissuable      rideBoolean
	sender          rideAddress
}

func newRideIssueTransaction(proofs rideList, script rideType, description rideString, name rideString, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, version rideInt, fee rideInt, quantity rideInt, decimals rideInt, reissuable rideBoolean, sender rideAddress) rideIssueTransaction {
	return rideIssueTransaction{
		proofs:          proofs,
		script:          script,
		description:     description,
		name:            name,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		quantity:        quantity,
		decimals:        decimals,
		reissuable:      reissuable,
		sender:          sender,
	}
}

func (o rideIssueTransaction) instanceOf() string {
	return issueTransactionTypeName
}

func (o rideIssueTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideIssueTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.script.eq(oo.script) {
			return false
		}
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.decimals.eq(oo.decimals) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideIssueTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(issueTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case scriptField:
		return o.script, nil
	case descriptionField:
		return o.description, nil
	case nameField:
		return o.name, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case quantityField:
		return o.quantity, nil
	case decimalsField:
		return o.decimals, nil
	case reissuableField:
		return o.reissuable, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideIssueTransaction) copy() rideType {
	return newRideIssueTransaction(o.proofs, o.script, o.description, o.name, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.quantity, o.decimals, o.reissuable, o.sender)
}

func (o rideIssueTransaction) lines() []string {
	r := make([]string, 0, 16)
	r = append(r, issueTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(descriptionField, o.description.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(scriptField, o.script.lines())...)
	r = append(r, fieldLines(reissuableField, o.reissuable.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, fieldLines(nameField, o.name.lines())...)
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(decimalsField, o.decimals.lines())...)
	r = append(r, ")")
	return r
}

func (o rideIssueTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideIssueTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideIssueTransaction) getProofs() rideList {
	return o.proofs
}

type rideLeaseCancelTransaction struct {
	proofs          rideList
	bodyBytes       rideBytes
	senderPublicKey rideBytes
	id              rideBytes
	leaseID         rideBytes
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideLeaseCancelTransaction(proofs rideList, bodyBytes rideBytes, senderPublicKey rideBytes, id rideBytes, leaseID rideBytes, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideLeaseCancelTransaction {
	return rideLeaseCancelTransaction{
		proofs:          proofs,
		bodyBytes:       bodyBytes,
		senderPublicKey: senderPublicKey,
		id:              id,
		leaseID:         leaseID,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideLeaseCancelTransaction) instanceOf() string {
	return leaseCancelTransactionTypeName
}

func (o rideLeaseCancelTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideLeaseCancelTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.leaseID.eq(oo.leaseID) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideLeaseCancelTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(leaseCancelTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case idField:
		return o.id, nil
	case leaseIDField:
		return o.leaseID, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLeaseCancelTransaction) copy() rideType {
	return newRideLeaseCancelTransaction(o.proofs, o.bodyBytes, o.senderPublicKey, o.id, o.leaseID, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideLeaseCancelTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, leaseCancelTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(leaseIDField, o.leaseID.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLeaseCancelTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideLeaseCancelTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideLeaseCancelTransaction) getProofs() rideList {
	return o.proofs
}

type rideLeaseTransaction struct {
	proofs          rideList
	recipient       rideType
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	amount          rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideLeaseTransaction(proofs rideList, recipient rideType, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, amount rideInt, version rideInt, fee rideInt, sender rideAddress) rideLeaseTransaction {
	return rideLeaseTransaction{
		proofs:          proofs,
		recipient:       recipient,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		amount:          amount,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideLeaseTransaction) instanceOf() string {
	return leaseTransactionTypeName
}

func (o rideLeaseTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideLeaseTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideLeaseTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(leaseTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case recipientField:
		return o.recipient, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case amountField:
		return o.amount, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideLeaseTransaction) copy() rideType {
	return newRideLeaseTransaction(o.proofs, o.recipient, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.amount, o.version, o.fee, o.sender)
}

func (o rideLeaseTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, leaseTransactionTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideLeaseTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideLeaseTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideLeaseTransaction) getProofs() rideList {
	return o.proofs
}

type rideMassTransferTransaction struct {
	proofs          rideList
	assetID         rideType
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	attachment      rideBytes
	transfers       rideList
	transfersCount  rideInt
	timestamp       rideInt
	fee             rideInt
	totalAmount     rideInt
	version         rideInt
	sender          rideAddress
}

func newRideMassTransferTransaction(proofs rideList, assetID rideType, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, attachment rideBytes, transfers rideList, transfersCount rideInt, timestamp rideInt, fee rideInt, totalAmount rideInt, version rideInt, sender rideAddress) rideMassTransferTransaction {
	return rideMassTransferTransaction{
		proofs:          proofs,
		assetID:         assetID,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		attachment:      attachment,
		transfers:       transfers,
		transfersCount:  transfersCount,
		timestamp:       timestamp,
		fee:             fee,
		totalAmount:     totalAmount,
		version:         version,
		sender:          sender,
	}
}

func (o rideMassTransferTransaction) instanceOf() string {
	return massTransferTransactionTypeName
}

func (o rideMassTransferTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideMassTransferTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.attachment.eq(oo.attachment) {
			return false
		}
		if !o.transfers.eq(oo.transfers) {
			return false
		}
		if !o.transfersCount.eq(oo.transfersCount) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.totalAmount.eq(oo.totalAmount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideMassTransferTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(massTransferTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case assetIDField:
		return o.assetID, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case attachmentField:
		return o.attachment, nil
	case transfersField:
		return o.transfers, nil
	case transfersCountField:
		return o.transfersCount, nil
	case timestampField:
		return o.timestamp, nil
	case feeField:
		return o.fee, nil
	case totalAmountField:
		return o.totalAmount, nil
	case versionField:
		return o.version, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideMassTransferTransaction) copy() rideType {
	return newRideMassTransferTransaction(o.proofs, o.assetID, o.bodyBytes, o.id, o.senderPublicKey, o.attachment, o.transfers, o.transfersCount, o.timestamp, o.fee, o.totalAmount, o.version, o.sender)
}

func (o rideMassTransferTransaction) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, massTransferTransactionTypeName+"(")
	r = append(r, fieldLines(transfersCountField, o.transfersCount.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(attachmentField, o.attachment.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(transfersField, o.transfers.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, fieldLines(totalAmountField, o.totalAmount.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, ")")
	return r
}

func (o rideMassTransferTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideMassTransferTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideMassTransferTransaction) getProofs() rideList {
	return o.proofs
}

type ridePaymentTransaction struct {
	proofs          rideList
	recipient       rideType
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	amount          rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRidePaymentTransaction(proofs rideList, recipient rideType, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, amount rideInt, version rideInt, fee rideInt, sender rideAddress) ridePaymentTransaction {
	return ridePaymentTransaction{
		proofs:          proofs,
		recipient:       recipient,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		amount:          amount,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o ridePaymentTransaction) instanceOf() string {
	return paymentTransactionTypeName
}

func (o ridePaymentTransaction) eq(other rideType) bool {
	if oo, ok := other.(ridePaymentTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o ridePaymentTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(paymentTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case recipientField:
		return o.recipient, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case amountField:
		return o.amount, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o ridePaymentTransaction) copy() rideType {
	return newRidePaymentTransaction(o.proofs, o.recipient, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.amount, o.version, o.fee, o.sender)
}

func (o ridePaymentTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, paymentTransactionTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o ridePaymentTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o ridePaymentTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o ridePaymentTransaction) getProofs() rideList {
	return o.proofs
}

type rideReissueTransaction struct {
	bodyBytes       rideType
	proofs          rideList
	senderPublicKey rideBytes
	assetID         rideBytes
	id              rideBytes
	timestamp       rideInt
	version         rideInt
	quantity        rideInt
	fee             rideInt
	sender          rideAddress
	reissuable      rideBoolean
}

func newRideReissueTransaction(bodyBytes rideType, proofs rideList, senderPublicKey rideBytes, assetID rideBytes, id rideBytes, timestamp rideInt, version rideInt, quantity rideInt, fee rideInt, sender rideAddress, reissuable rideBoolean) rideReissueTransaction {
	return rideReissueTransaction{
		bodyBytes:       bodyBytes,
		proofs:          proofs,
		senderPublicKey: senderPublicKey,
		assetID:         assetID,
		id:              id,
		timestamp:       timestamp,
		version:         version,
		quantity:        quantity,
		fee:             fee,
		sender:          sender,
		reissuable:      reissuable,
	}
}

func (o rideReissueTransaction) instanceOf() string {
	return reissueTransactionTypeName
}

func (o rideReissueTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideReissueTransaction); ok {
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.quantity.eq(oo.quantity) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		if !o.reissuable.eq(oo.reissuable) {
			return false
		}
		return true
	}
	return false
}

func (o rideReissueTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(reissueTransactionTypeName), nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case proofsField:
		return o.proofs, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case assetIDField:
		return o.assetID, nil
	case idField:
		return o.id, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case quantityField:
		return o.quantity, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	case reissuableField:
		return o.reissuable, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideReissueTransaction) copy() rideType {
	return newRideReissueTransaction(o.bodyBytes, o.proofs, o.senderPublicKey, o.assetID, o.id, o.timestamp, o.version, o.quantity, o.fee, o.sender, o.reissuable)
}

func (o rideReissueTransaction) lines() []string {
	r := make([]string, 0, 13)
	r = append(r, reissueTransactionTypeName+"(")
	r = append(r, fieldLines(quantityField, o.quantity.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(reissuableField, o.reissuable.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideReissueTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideReissueTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideReissueTransaction) getProofs() rideList {
	return o.proofs
}

type rideSetAssetScriptTransaction struct {
	proofs          rideList
	script          rideType
	bodyBytes       rideBytes
	assetID         rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideSetAssetScriptTransaction(proofs rideList, script rideType, bodyBytes rideBytes, assetID rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideSetAssetScriptTransaction {
	return rideSetAssetScriptTransaction{
		proofs:          proofs,
		script:          script,
		bodyBytes:       bodyBytes,
		assetID:         assetID,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideSetAssetScriptTransaction) instanceOf() string {
	return setAssetScriptTransactionTypeName
}

func (o rideSetAssetScriptTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideSetAssetScriptTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.script.eq(oo.script) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideSetAssetScriptTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(setAssetScriptTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case scriptField:
		return o.script, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case assetIDField:
		return o.assetID, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSetAssetScriptTransaction) copy() rideType {
	return newRideSetAssetScriptTransaction(o.proofs, o.script, o.bodyBytes, o.assetID, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideSetAssetScriptTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, setAssetScriptTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(scriptField, o.script.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSetAssetScriptTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideSetAssetScriptTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideSetAssetScriptTransaction) getProofs() rideList {
	return o.proofs
}

type rideSetScriptTransaction struct {
	proofs          rideList
	script          rideType
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideSetScriptTransaction(proofs rideList, script rideType, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideSetScriptTransaction {
	return rideSetScriptTransaction{
		proofs:          proofs,
		script:          script,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideSetScriptTransaction) instanceOf() string {
	return setScriptTransactionTypeName
}

func (o rideSetScriptTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideSetScriptTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.script.eq(oo.script) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideSetScriptTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(setScriptTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case scriptField:
		return o.script, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSetScriptTransaction) copy() rideType {
	return newRideSetScriptTransaction(o.proofs, o.script, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideSetScriptTransaction) lines() []string {
	r := make([]string, 0, 11)
	r = append(r, setScriptTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(scriptField, o.script.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSetScriptTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideSetScriptTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideSetScriptTransaction) getProofs() rideList {
	return o.proofs
}

type rideSponsorFeeTransaction struct {
	proofs               rideList
	minSponsoredAssetFee rideType
	bodyBytes            rideBytes
	assetID              rideBytes
	id                   rideBytes
	senderPublicKey      rideBytes
	timestamp            rideInt
	version              rideInt
	fee                  rideInt
	sender               rideAddress
}

func newRideSponsorFeeTransaction(proofs rideList, minSponsoredAssetFee rideType, bodyBytes rideBytes, assetID rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideSponsorFeeTransaction {
	return rideSponsorFeeTransaction{
		proofs:               proofs,
		minSponsoredAssetFee: minSponsoredAssetFee,
		bodyBytes:            bodyBytes,
		assetID:              assetID,
		id:                   id,
		senderPublicKey:      senderPublicKey,
		timestamp:            timestamp,
		version:              version,
		fee:                  fee,
		sender:               sender,
	}
}

func (o rideSponsorFeeTransaction) instanceOf() string {
	return sponsorFeeTransactionTypeName
}

func (o rideSponsorFeeTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideSponsorFeeTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.minSponsoredAssetFee.eq(oo.minSponsoredAssetFee) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideSponsorFeeTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(sponsorFeeTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case minSponsoredAssetFeeField:
		return o.minSponsoredAssetFee, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case assetIDField:
		return o.assetID, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideSponsorFeeTransaction) copy() rideType {
	return newRideSponsorFeeTransaction(o.proofs, o.minSponsoredAssetFee, o.bodyBytes, o.assetID, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideSponsorFeeTransaction) lines() []string {
	r := make([]string, 0, 12)
	r = append(r, sponsorFeeTransactionTypeName+"(")
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(minSponsoredAssetFeeField, o.minSponsoredAssetFee.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideSponsorFeeTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideSponsorFeeTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideSponsorFeeTransaction) getProofs() rideList {
	return o.proofs
}

type rideTransferTransaction struct {
	assetID         rideType
	bodyBytes       rideType
	feeAssetID      rideType
	version         rideType
	attachment      rideType
	proofs          rideList
	fee             rideType
	recipient       rideType
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	amount          rideInt
	sender          rideAddress
}

func newRideTransferTransaction(assetID rideType, bodyBytes rideType, feeAssetID rideType, version rideType, attachment rideType, proofs rideList, fee rideType, recipient rideType, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, amount rideInt, sender rideAddress) rideTransferTransaction {
	return rideTransferTransaction{
		assetID:         assetID,
		bodyBytes:       bodyBytes,
		feeAssetID:      feeAssetID,
		version:         version,
		attachment:      attachment,
		proofs:          proofs,
		fee:             fee,
		recipient:       recipient,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		amount:          amount,
		sender:          sender,
	}
}

func (o rideTransferTransaction) instanceOf() string {
	return transferTransactionTypeName
}

func (o rideTransferTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideTransferTransaction); ok {
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.feeAssetID.eq(oo.feeAssetID) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.attachment.eq(oo.attachment) {
			return false
		}
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.recipient.eq(oo.recipient) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.amount.eq(oo.amount) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideTransferTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(transferTransactionTypeName), nil
	case assetIDField:
		return o.assetID, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case feeAssetIDField:
		return o.feeAssetID, nil
	case versionField:
		return o.version, nil
	case attachmentField:
		return o.attachment, nil
	case proofsField:
		return o.proofs, nil
	case feeField:
		return o.fee, nil
	case recipientField:
		return o.recipient, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case amountField:
		return o.amount, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideTransferTransaction) copy() rideType {
	return newRideTransferTransaction(o.assetID, o.bodyBytes, o.feeAssetID, o.version, o.attachment, o.proofs, o.fee, o.recipient, o.id, o.senderPublicKey, o.timestamp, o.amount, o.sender)
}

func (o rideTransferTransaction) lines() []string {
	r := make([]string, 0, 15)
	r = append(r, transferTransactionTypeName+"(")
	r = append(r, fieldLines(recipientField, o.recipient.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(feeAssetIDField, o.feeAssetID.lines())...)
	r = append(r, fieldLines(amountField, o.amount.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(attachmentField, o.attachment.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideTransferTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideTransferTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideTransferTransaction) getProofs() rideList {
	return o.proofs
}

type rideUpdateAssetInfoTransaction struct {
	proofs          rideList
	assetID         rideType
	name            rideString
	description     rideString
	bodyBytes       rideBytes
	id              rideBytes
	senderPublicKey rideBytes
	timestamp       rideInt
	version         rideInt
	fee             rideInt
	sender          rideAddress
}

func newRideUpdateAssetInfoTransaction(proofs rideList, assetID rideType, name rideString, description rideString, bodyBytes rideBytes, id rideBytes, senderPublicKey rideBytes, timestamp rideInt, version rideInt, fee rideInt, sender rideAddress) rideUpdateAssetInfoTransaction {
	return rideUpdateAssetInfoTransaction{
		proofs:          proofs,
		assetID:         assetID,
		name:            name,
		description:     description,
		bodyBytes:       bodyBytes,
		id:              id,
		senderPublicKey: senderPublicKey,
		timestamp:       timestamp,
		version:         version,
		fee:             fee,
		sender:          sender,
	}
}

func (o rideUpdateAssetInfoTransaction) instanceOf() string {
	return updateAssetInfoTransactionTypeName
}

func (o rideUpdateAssetInfoTransaction) eq(other rideType) bool {
	if oo, ok := other.(rideUpdateAssetInfoTransaction); ok {
		if !o.proofs.eq(oo.proofs) {
			return false
		}
		if !o.assetID.eq(oo.assetID) {
			return false
		}
		if !o.name.eq(oo.name) {
			return false
		}
		if !o.description.eq(oo.description) {
			return false
		}
		if !o.bodyBytes.eq(oo.bodyBytes) {
			return false
		}
		if !o.id.eq(oo.id) {
			return false
		}
		if !o.senderPublicKey.eq(oo.senderPublicKey) {
			return false
		}
		if !o.timestamp.eq(oo.timestamp) {
			return false
		}
		if !o.version.eq(oo.version) {
			return false
		}
		if !o.fee.eq(oo.fee) {
			return false
		}
		if !o.sender.eq(oo.sender) {
			return false
		}
		return true
	}
	return false
}

func (o rideUpdateAssetInfoTransaction) get(prop string) (rideType, error) {
	switch prop {
	case instanceField:
		return rideString(updateAssetInfoTransactionTypeName), nil
	case proofsField:
		return o.proofs, nil
	case assetIDField:
		return o.assetID, nil
	case nameField:
		return o.name, nil
	case descriptionField:
		return o.description, nil
	case bodyBytesField:
		return o.bodyBytes, nil
	case idField:
		return o.id, nil
	case senderPublicKeyField:
		return o.senderPublicKey, nil
	case timestampField:
		return o.timestamp, nil
	case versionField:
		return o.version, nil
	case feeField:
		return o.fee, nil
	case senderField:
		return o.sender, nil
	default:
		return nil, errors.Errorf("type '%s' has no property '%s'", o.instanceOf(), prop)
	}
}

func (o rideUpdateAssetInfoTransaction) copy() rideType {
	return newRideUpdateAssetInfoTransaction(o.proofs, o.assetID, o.name, o.description, o.bodyBytes, o.id, o.senderPublicKey, o.timestamp, o.version, o.fee, o.sender)
}

func (o rideUpdateAssetInfoTransaction) lines() []string {
	r := make([]string, 0, 13)
	r = append(r, updateAssetInfoTransactionTypeName+"(")
	r = append(r, fieldLines(nameField, o.name.lines())...)
	r = append(r, fieldLines(timestampField, o.timestamp.lines())...)
	r = append(r, fieldLines(bodyBytesField, o.bodyBytes.lines())...)
	r = append(r, fieldLines(assetIDField, o.assetID.lines())...)
	r = append(r, fieldLines(descriptionField, o.description.lines())...)
	r = append(r, fieldLines(versionField, o.version.lines())...)
	r = append(r, fieldLines(idField, o.id.lines())...)
	r = append(r, fieldLines(senderPublicKeyField, o.senderPublicKey.lines())...)
	r = append(r, fieldLines(senderField, o.sender.lines())...)
	r = append(r, fieldLines(proofsField, o.proofs.lines())...)
	r = append(r, fieldLines(feeField, o.fee.lines())...)
	r = append(r, ")")
	return r
}

func (o rideUpdateAssetInfoTransaction) String() string {
	return strings.Join(o.lines(), "\n")
}

func (o rideUpdateAssetInfoTransaction) setProofs(proofs rideList) rideProven {
	o.proofs = proofs
	return o
}

func (o rideUpdateAssetInfoTransaction) getProofs() rideList {
	return o.proofs
}

func resetProofs(obj rideType) error {
	switch tx := obj.(type) {
	case rideProven:
		tx.setProofs(rideList{})
	default:
		return errors.Errorf("type '%s' is not tx", obj.instanceOf())
	}
	return nil
}
