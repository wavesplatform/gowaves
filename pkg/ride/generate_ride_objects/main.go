package main

import (
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"
)

func getType(types []string) string {
	if len(types) == 1 {
		return types[0]
	}
	return "rideType"
}

func main() {
	s, err := parseConfig()
	if err != nil {
		panic(err)
	}
	sb := new(strings.Builder)
	sb.WriteString("// Code generated by ride/generate_ride_objects/main.go. DO NOT EDIT.\n")
	sb.WriteString("\n")
	sb.WriteString("package ride\n")
	sb.WriteString("\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"strings\"\n\n")
	sb.WriteString("\t\"github.com/pkg/errors\"\n")
	sb.WriteString(")\n\n")

	for _, act := range s.Actions {
		// Struct Implementation
		sb.WriteString(fmt.Sprintf("type ride%s struct {\n", act.StructName))
		for _, field := range act.Fields {
			sb.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, getType(field.Types)))
		}
		sb.WriteString("}\n\n")

		// Constructor
		sb.WriteString(fmt.Sprintf("func newRide%s(", act.StructName))
		for i, field := range act.Fields {
			sb.WriteString(fmt.Sprintf("%s %s", field.Name, getType(field.Types)))
			if i < len(act.Fields) {
				sb.WriteString(", ")
			}
		}
		sb.WriteString(fmt.Sprintf(") ride%s {\n", act.StructName))
		sb.WriteString(fmt.Sprintf("\treturn ride%s{\n", act.StructName))
		for _, field := range act.Fields {
			sb.WriteString(fmt.Sprintf("\t\t%s: %s,\n", field.Name, field.Name))
		}
		sb.WriteString("\t}\n")
		sb.WriteString("}\n\n")

		// instanceOf method
		sb.WriteString(fmt.Sprintf("func (o ride%s) instanceOf() string {\n", act.StructName))
		sb.WriteString(fmt.Sprintf("\treturn %sTypeName\n", act.Name))
		sb.WriteString("}\n\n")

		// qe method
		sb.WriteString(fmt.Sprintf("func (o ride%s) eq(other rideType) bool {\n", act.StructName))
		sb.WriteString(fmt.Sprintf("\tif oo, ok := other.(ride%s); ok {\n", act.StructName))
		for _, field := range act.Fields {
			sb.WriteString(fmt.Sprintf("\t\tif !o.%s.eq(oo.%s) {\n", field.Name, field.Name))
			sb.WriteString("\t\t\treturn false\n")
			sb.WriteString("\t\t}\n")
		}
		sb.WriteString("\t\treturn true\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn false\n")
		sb.WriteString("}\n\n")

		// get method
		sb.WriteString(fmt.Sprintf("func (o ride%s) get(prop string) (rideType, error) {\n", act.StructName))
		sb.WriteString("\tswitch prop {\n")
		sb.WriteString("\tcase instanceField:\n")
		sb.WriteString(fmt.Sprintf("\t\treturn rideString(%sTypeName), nil\n", act.Name))
		for _, field := range act.Fields {
			sb.WriteString(fmt.Sprintf("\tcase %sField:\n", field.Name))
			sb.WriteString(fmt.Sprintf("\t\treturn o.%s, nil\n", field.Name))
		}
		sb.WriteString("\tdefault:\n")
		sb.WriteString("\t\treturn nil, errors.Errorf(\"type '%s' has no property '%s'\", o.instanceOf(), prop)\n")
		sb.WriteString("\t}\n")
		sb.WriteString("}\n\n")

		//copy method
		sb.WriteString(fmt.Sprintf("func (o ride%s) copy() rideType {\n", act.StructName))
		sb.WriteString(fmt.Sprintf("\treturn newRide%s(", act.StructName))
		for i, field := range act.Fields {
			sb.WriteString(fmt.Sprintf("o.%s", field.Name))
			if i < len(act.Fields) {
				sb.WriteString(", ")
			}
		}
		sb.WriteString(")\n")
		sb.WriteString("}\n\n")

		// lines method
		sb.WriteString(fmt.Sprintf("func (o ride%s) lines() []string {\n", act.StructName))
		sb.WriteString(fmt.Sprintf("\tr := make([]string, 0, %d)\n", len(act.Fields)+2))
		sb.WriteString(fmt.Sprintf("\tr = append(r, %sTypeName + \"(\")\n", act.Name))
		sort.SliceStable(act.Fields, func(i, j int) bool {
			return act.Fields[i].Order < act.Fields[j].Order
		})
		for _, field := range act.Fields {
			if field.Order != -1 {
				sb.WriteString(fmt.Sprintf("\tr = append(r, fieldLines(%sField, o.%s.lines())...)\n", field.Name, field.Name))
			}
		}
		sb.WriteString("\tr = append(r, \")\")\n")
		sb.WriteString("\treturn r\n")
		sb.WriteString("}\n\n")

		// String method
		sb.WriteString(fmt.Sprintf("func (o ride%s) String() string {\n", act.StructName))
		sb.WriteString("\treturn strings.Join(o.lines(), \"\\n\")\n")
		sb.WriteString("}\n\n")

		// SetProofs (only for transactions)
		if act.SetProofs {
			sb.WriteString(fmt.Sprintf("func (o ride%s) setProofs(proofs rideList) rideProven {\n", act.StructName))
			sb.WriteString("\to.proofs = proofs\n")
			sb.WriteString("\treturn o\n")
			sb.WriteString("}\n\n")
			sb.WriteString(fmt.Sprintf("func (o ride%s) getProofs() rideList {\n", act.StructName))
			sb.WriteString("\treturn o.proofs\n")
			sb.WriteString("}\n\n")
		}
	}
	// ResetProofs (only for transactions)
	sb.WriteString("func resetProofs(obj rideType) error {\n")
	sb.WriteString("\tswitch tx := obj.(type) {\n")
	sb.WriteString("\tcase rideProven:\n")
	sb.WriteString("\t\ttx.setProofs(rideList{})\n")
	sb.WriteString("\tdefault:\n")
	sb.WriteString("\t\treturn errors.Errorf(\"type '%s' is not tx\", obj.instanceOf())\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	code := sb.String()
	b, err := format.Source([]byte(code))
	if err != nil {
		println(code)
		panic(err)
	}
	err = os.WriteFile("ride_objects.gen.go", b, 0600)
	if err != nil {
		panic(err)
	}
}
