package ride

import (
	"encoding/base64"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/wavesplatform/gowaves/pkg/proto"
	"github.com/wavesplatform/gowaves/pkg/types"
)

var (
	nativeFoldTestState = &MockSmartState{}
	nativeFoldTestEnv   = &mockRideEnvironment{
		schemeFunc: func() byte {
			return proto.TestNetScheme
		},
		validateInternalPaymentsFunc: func() bool {
			return false
		},
		stateFunc: func() types.SmartState {
			return nativeFoldTestState
		},
		libVersionFunc: func() int {
			return 5
		},
		rideV6ActivatedFunc: func() bool {
			return true
		},
	}
)

func evaluateFold(t *testing.T, code string) {
	src, err := base64.StdEncoding.DecodeString(code)
	require.NoError(t, err)

	tree, err := Parse(src)
	require.NoError(t, err)
	assert.NotNil(t, tree)

	res, err := CallVerifier(nativeFoldTestEnv, tree)
	require.NoError(t, err)
	r, ok := res.(ScriptResult)
	require.True(t, ok)
	require.True(t, r.res)
}

func TestNativeFoldEvaluationCorrectLeftFold(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}

		func sum(a: String, b: Int) = "(" + a + "+" + toString(b) + ")"

		fold_20([1,2,3,4,5,6,7,8,9,10,11,12,13], "0", sum) == "(((((((((((((0+1)+2)+3)+4)+5)+6)+7)+8)+9)+10)+11)+12)+13)"
	*/
	code := "BgoBAAAAA3N1bQAAAAIAAAABYQAAAAFiCQABLAAAAAIJAAEsAAAAAgkAASwAAAACCQABLAAAAAICAAAAASgFAAAAAWECAAAAASsJAAGkAAAAAQUAAAABYgIAAAABKQkAAAAAAAACCQABwgAAAAMJAARMAAAAAgAAAAAAAAAAAQkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAMJAARMAAAAAgAAAAAAAAAABAkABEwAAAACAAAAAAAAAAAFCQAETAAAAAIAAAAAAAAAAAYJAARMAAAAAgAAAAAAAAAABwkABEwAAAACAAAAAAAAAAAICQAETAAAAAIAAAAAAAAAAAkJAARMAAAAAgAAAAAAAAAACgkABEwAAAACAAAAAAAAAAALCQAETAAAAAIAAAAAAAAAAAwJAARMAAAAAgAAAAAAAAAADQUAAAADbmlsAgAAAAEwAgAAAANzdW0CAAAAOSgoKCgoKCgoKCgoKCgwKzEpKzIpKzMpKzQpKzUpKzYpKzcpKzgpKzkpKzEwKSsxMSkrMTIpKzEzKcR/pfs="
	evaluateFold(t, code)
}

func TestNativeFoldSum(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}

		func sum(a: Int, b: Int) = a + b

		fold_20([1,2,3,4,5,6,7,8,9,10,11,12,13], 0, sum) == 91
	*/
	code := "BgoBAAAAA3N1bQAAAAIAAAABYQAAAAFiCQAAZAAAAAIFAAAAAWEFAAAAAWIJAAAAAAAAAgkAAcIAAAADCQAETAAAAAIAAAAAAAAAAAEJAARMAAAAAgAAAAAAAAAAAgkABEwAAAACAAAAAAAAAAADCQAETAAAAAIAAAAAAAAAAAQJAARMAAAAAgAAAAAAAAAABQkABEwAAAACAAAAAAAAAAAGCQAETAAAAAIAAAAAAAAAAAcJAARMAAAAAgAAAAAAAAAACAkABEwAAAACAAAAAAAAAAAJCQAETAAAAAIAAAAAAAAAAAoJAARMAAAAAgAAAAAAAAAACwkABEwAAAACAAAAAAAAAAAMCQAETAAAAAIAAAAAAAAAAA0FAAAAA25pbAAAAAAAAAAAAAIAAAADc3VtAAAAAAAAAABbj0yYhw=="
	evaluateFold(t, code)
}

func TestNativeFoldFilter(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func filter(a: List[Int], b: Int) = if b % 2 == 0 then a ++ [b] else a
		fold_20([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [], filter) == [2, 4, 6, 8, 10, 12]
	*/
	code := "BgoBAAAABmZpbHRlcgAAAAIAAAABYQAAAAFiAwkAAAAAAAACCQAAagAAAAIFAAAAAWIAAAAAAAAAAAIAAAAAAAAAAAAJAAROAAAAAgUAAAABYQkABEwAAAACBQAAAAFiBQAAAANuaWwFAAAAAWEJAAAAAAAAAgkAAcIAAAADCQAETAAAAAIAAAAAAAAAAAEJAARMAAAAAgAAAAAAAAAAAgkABEwAAAACAAAAAAAAAAADCQAETAAAAAIAAAAAAAAAAAQJAARMAAAAAgAAAAAAAAAABQkABEwAAAACAAAAAAAAAAAGCQAETAAAAAIAAAAAAAAAAAcJAARMAAAAAgAAAAAAAAAACAkABEwAAAACAAAAAAAAAAAJCQAETAAAAAIAAAAAAAAAAAoJAARMAAAAAgAAAAAAAAAACwkABEwAAAACAAAAAAAAAAAMCQAETAAAAAIAAAAAAAAAAA0FAAAAA25pbAUAAAADbmlsAgAAAAZmaWx0ZXIJAARMAAAAAgAAAAAAAAAAAgkABEwAAAACAAAAAAAAAAAECQAETAAAAAIAAAAAAAAAAAYJAARMAAAAAgAAAAAAAAAACAkABEwAAAACAAAAAAAAAAAKCQAETAAAAAIAAAAAAAAAAAwFAAAAA25pbFX5Kak="
	evaluateFold(t, code)
}

func TestNativeFoldExampleSum(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func sum(accum: Int, next: Int) = accum + next
		let arr = [1,2,3,4,5]
		fold_20(arr, 0, sum) == 15
	*/
	code := "BgoBAAAAA3N1bQAAAAIAAAAFYWNjdW0AAAAEbmV4dAkAAGQAAAACBQAAAAVhY2N1bQUAAAAEbmV4dAQAAAADYXJyCQAETAAAAAIAAAAAAAAAAAEJAARMAAAAAgAAAAAAAAAAAgkABEwAAAACAAAAAAAAAAADCQAETAAAAAIAAAAAAAAAAAQJAARMAAAAAgAAAAAAAAAABQUAAAADbmlsCQAAAAAAAAIJAAHCAAAAAwUAAAADYXJyAAAAAAAAAAAAAgAAAANzdW0AAAAAAAAAAA+mhsJ5"
	evaluateFold(t, code)
}

func TestNativeFoldExampleProduct(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func mult(accum: Int, next: Int) = accum * next
		let arr = [1,2,3,4,5]
		fold_20(arr, 1, mult) == 120
	*/
	code := "BgoBAAAABG11bHQAAAACAAAABWFjY3VtAAAABG5leHQJAABoAAAAAgUAAAAFYWNjdW0FAAAABG5leHQEAAAAA2FycgkABEwAAAACAAAAAAAAAAABCQAETAAAAAIAAAAAAAAAAAIJAARMAAAAAgAAAAAAAAAAAwkABEwAAAACAAAAAAAAAAAECQAETAAAAAIAAAAAAAAAAAUFAAAAA25pbAkAAAAAAAACCQABwgAAAAMFAAAAA2FycgAAAAAAAAAAAQIAAAAEbXVsdAAAAAAAAAAAeNeAQ8I="
	evaluateFold(t, code)
}

func TestNativeFoldExampleFilter(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func filterEven(accum: List[Int], next: Int) = if (next % 2 == 0) then accum :+ next else accum
		let arr = [1,2,3,4,5]
		fold_20(arr, [], filterEven) == [2, 4]
	*/
	code := "BgoBAAAACmZpbHRlckV2ZW4AAAACAAAABWFjY3VtAAAABG5leHQDCQAAAAAAAAIJAABqAAAAAgUAAAAEbmV4dAAAAAAAAAAAAgAAAAAAAAAAAAkABE0AAAACBQAAAAVhY2N1bQUAAAAEbmV4dAUAAAAFYWNjdW0EAAAAA2FycgkABEwAAAACAAAAAAAAAAABCQAETAAAAAIAAAAAAAAAAAIJAARMAAAAAgAAAAAAAAAAAwkABEwAAAACAAAAAAAAAAAECQAETAAAAAIAAAAAAAAAAAUFAAAAA25pbAkAAAAAAAACCQABwgAAAAMFAAAAA2FycgUAAAADbmlsAgAAAApmaWx0ZXJFdmVuCQAETAAAAAIAAAAAAAAAAAIJAARMAAAAAgAAAAAAAAAABAUAAAADbmls1YTNrA=="
	evaluateFold(t, code)
}

func TestNativeFoldExampleMap(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func map(accum: List[Int], next: Int) = (next - 1) :: accum
		let arr = [1, 2, 3, 4, 5]
		fold_20(arr, [], map) == [4, 3, 2, 1, 0]
	*/
	code := "BgoBAAAAA21hcAAAAAIAAAAFYWNjdW0AAAAEbmV4dAkABEwAAAACCQAAZQAAAAIFAAAABG5leHQAAAAAAAAAAAEFAAAABWFjY3VtBAAAAANhcnIJAARMAAAAAgAAAAAAAAAAAQkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAMJAARMAAAAAgAAAAAAAAAABAkABEwAAAACAAAAAAAAAAAFBQAAAANuaWwJAAAAAAAAAgkAAcIAAAADBQAAAANhcnIFAAAAA25pbAIAAAADbWFwCQAETAAAAAIAAAAAAAAAAAQJAARMAAAAAgAAAAAAAAAAAwkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAEJAARMAAAAAgAAAAAAAAAAAAUAAAADbmls57+XUw=="
	evaluateFold(t, code)
}

func TestFoldFunctionOverlap(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		let a = 4
		func g(b: Int) = a
		func f(x: Int , a: Int) = x + g(a)
		let arr = [1,2,3,4,5]
		fold_20(arr, 0, f) == 20
	*/
	code := "BgQAAAABYQAAAAAAAAAABAoBAAAAAWcAAAABAAAAAWIFAAAAAWEKAQAAAAFmAAAAAgAAAAF4AAAAAWEJAABkAAAAAgUAAAABeAkBAAAAAWcAAAABBQAAAAFhBAAAAANhcnIJAARMAAAAAgAAAAAAAAAAAQkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAMJAARMAAAAAgAAAAAAAAAABAkABEwAAAACAAAAAAAAAAAFBQAAAANuaWwJAAAAAAAAAgkAAcIAAAADBQAAAANhcnIAAAAAAAAAAAACAAAAAWYAAAAAAAAAABQhKn1s"
	evaluateFold(t, code)
}

func TestFoldNestedFunctions(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func f() = {
		    func f() = {
		        func f() = {1}
		        f()
		    }
		    f()
		}
		func s(x: Int , a: Int) = x + f()
		let arr = [1,2,3,4,5]
		fold_20(arr, 0, s) == 5
	*/
	code := "BgoBAAAAAWYAAAAACgEAAAABZgAAAAAKAQAAAAFmAAAAAAAAAAAAAAAAAQkBAAAAAWYAAAAACQEAAAABZgAAAAAKAQAAAAFzAAAAAgAAAAF4AAAAAWEJAABkAAAAAgUAAAABeAkBAAAAAWYAAAAABAAAAANhcnIJAARMAAAAAgAAAAAAAAAAAQkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAMJAARMAAAAAgAAAAAAAAAABAkABEwAAAACAAAAAAAAAAAFBQAAAANuaWwJAAAAAAAAAgkAAcIAAAADBQAAAANhcnIAAAAAAAAAAAACAAAAAXMAAAAAAAAAAAVq2v0Z"
	evaluateFold(t, code)
}

func TestNestedFolds(t *testing.T) {
	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func f(a: Int, n: Int) = a + n
		func f1(a: Int, n: List[Int]) = {
			a + fold_20(n, 0, f)
		}
		let arr = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
		fold_20(arr, 0, f1) == 18
	*/
	code := "BgoBAAAAAWYAAAACAAAAAWEAAAABbgkAAGQAAAACBQAAAAFhBQAAAAFuCgEAAAACZjEAAAACAAAAAWEAAAABbgkAAGQAAAACBQAAAAFhCQABwgAAAAMFAAAAAW4AAAAAAAAAAAACAAAAAWYEAAAAA2FycgkABEwAAAACCQAETAAAAAIAAAAAAAAAAAEJAARMAAAAAgAAAAAAAAAAAgkABEwAAAACAAAAAAAAAAADBQAAAANuaWwJAARMAAAAAgkABEwAAAACAAAAAAAAAAABCQAETAAAAAIAAAAAAAAAAAIJAARMAAAAAgAAAAAAAAAAAwUAAAADbmlsCQAETAAAAAIJAARMAAAAAgAAAAAAAAAAAQkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAMFAAAAA25pbAUAAAADbmlsCQAAAAAAAAIJAAHCAAAAAwUAAAADYXJyAAAAAAAAAAAAAgAAAAJmMQAAAAAAAAAAEuwjL7E="
	evaluateFold(t, code)

	/*
		{-# STDLIB_VERSION 6 #-}
		{-# CONTENT_TYPE EXPRESSION #-}
		{-# SCRIPT_TYPE ACCOUNT #-}
		func f1(a: Int, n: List[Int]) = {
		    func f(a: Int, n: Int) = a + n
		    a + fold_20(n, 0, f)
		}
		let arr = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
		fold_20(arr, 0, f1) == 18
	*/
	code = "BgoBAAAAAmYxAAAAAgAAAAFhAAAAAW4KAQAAAAFmAAAAAgAAAAFhAAAAAW4JAABkAAAAAgUAAAABYQUAAAABbgkAAGQAAAACBQAAAAFhCQABwgAAAAMFAAAAAW4AAAAAAAAAAAACAAAAAWYEAAAAA2FycgkABEwAAAACCQAETAAAAAIAAAAAAAAAAAEJAARMAAAAAgAAAAAAAAAAAgkABEwAAAACAAAAAAAAAAADBQAAAANuaWwJAARMAAAAAgkABEwAAAACAAAAAAAAAAABCQAETAAAAAIAAAAAAAAAAAIJAARMAAAAAgAAAAAAAAAAAwUAAAADbmlsCQAETAAAAAIJAARMAAAAAgAAAAAAAAAAAQkABEwAAAACAAAAAAAAAAACCQAETAAAAAIAAAAAAAAAAAMFAAAAA25pbAUAAAADbmlsCQAAAAAAAAIJAAHCAAAAAwUAAAADYXJyAAAAAAAAAAAAAgAAAAJmMQAAAAAAAAAAEvRyQB8="
	evaluateFold(t, code)
}

func TestEvaluateInvalidNativeFoldCall(t *testing.T) {
	code := "BgoBAAAAA3N1bQAAAAIAAAABYQAAAAFuCQAAZAAAAAIFAAAAAWEFAAAAAW4EAAAAA2FycgkABEwAAAACAAAAAAAAAAABCQAETAAAAAIAAAAAAAAAAAIJAARMAAAAAgAAAAAAAAAAAwkABEwAAAACAAAAAAAAAAAECQAETAAAAAIAAAAAAAAAAAUFAAAAA25pbAkAAAAAAAACCQABwgAAAAMFAAAAA2FycgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADyZkt1Y="

	src, err := base64.StdEncoding.DecodeString(code)
	require.NoError(t, err)

	tree, err := Parse(src)
	require.NoError(t, err)
	assert.NotNil(t, tree)

	_, err = CallVerifier(nativeFoldTestEnv, tree)
	require.Error(t, err)
}
