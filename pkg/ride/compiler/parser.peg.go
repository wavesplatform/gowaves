package compiler

// Code generated by peg -output=parser.peg.go ride.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleCode
	ruleDAppRoot
	ruleScriptRoot
	ruleWS
	ruleNewLine
	ruleComment
	ruleWhiteSpace
	rule_
	ruleEOF
	ruleDirectiveName
	ruleUpperCaseString
	ruleIntString
	rulePathString
	ruleDirective
	ruleDeclaration
	ruleVariable
	ruleFunc
	ruleFuncArg
	ruleFuncArgSeq
	ruleAnnotatedFunc
	ruleAnnotation
	ruleIdentifierAtomSeq
	ruleAnnotationSeq
	ruleOrOp
	ruleAndOp
	ruleEqGroupOp
	ruleEqOp
	ruleNeOp
	ruleCompareGroupOp
	ruleGtOp
	ruleGeOp
	ruleLtOp
	ruleLeOp
	ruleConsOp
	ruleSumGroupOp
	ruleSumOp
	ruleSubOp
	ruleMultGroupOp
	ruleMulOp
	ruleDivOp
	ruleModOp
	ruleUnaryOp
	rulePositiveOp
	ruleNegativeOp
	ruleNotOp
	ruleReservedWords
	ruleConstAtom
	ruleIdentifierAtom
	ruleReferenceAtom
	ruleGenericTypesAtom
	ruleOneGenericTypeAtom
	ruleTypesAtom
	ruleOneTypeAtom
	ruleByteVectorAtom
	ruleBooleanAtom
	ruleStringAtom
	ruleUnicodeCharAtom
	ruleHexDigit
	ruleEscapedCharAtom
	ruleCharAtom
	ruleChar
	ruleIntegerAtom
	ruleDigit
	ruleListAtom
	ruleExprSeq
	ruleAtomExpr
	ruleMultGroupOpAtom
	ruleSumGroupOpAtom
	ruleConsOpAtom
	ruleCompareGroupOpAtom
	ruleEqualityGroupOpAtom
	ruleAndOpAtom
	ruleOrOpAtom
	ruleExpr
	ruleParExpr
	ruleGettableExpr
	ruleFunctionCallAccess
	ruleIdentifierAtomAccess
	ruleListAccess
	ruleBlock
	ruleBlockWithoutPar
	ruleBlockDecExprSep
	ruleFunctionCall
	ruleFoldMacro
	ruleIfWithError
	ruleIf
	ruleFailedIfWithoutElse
	ruleMatch
	ruleMatchCase
	ruleDefaultMatchCasePart
)

var rul3s = [...]string{
	"Unknown",
	"Code",
	"DAppRoot",
	"ScriptRoot",
	"WS",
	"NewLine",
	"Comment",
	"WhiteSpace",
	"_",
	"EOF",
	"DirectiveName",
	"UpperCaseString",
	"IntString",
	"PathString",
	"Directive",
	"Declaration",
	"Variable",
	"Func",
	"FuncArg",
	"FuncArgSeq",
	"AnnotatedFunc",
	"Annotation",
	"IdentifierAtomSeq",
	"AnnotationSeq",
	"OrOp",
	"AndOp",
	"EqGroupOp",
	"EqOp",
	"NeOp",
	"CompareGroupOp",
	"GtOp",
	"GeOp",
	"LtOp",
	"LeOp",
	"ConsOp",
	"SumGroupOp",
	"SumOp",
	"SubOp",
	"MultGroupOp",
	"MulOp",
	"DivOp",
	"ModOp",
	"UnaryOp",
	"PositiveOp",
	"NegativeOp",
	"NotOp",
	"ReservedWords",
	"ConstAtom",
	"IdentifierAtom",
	"ReferenceAtom",
	"GenericTypesAtom",
	"OneGenericTypeAtom",
	"TypesAtom",
	"OneTypeAtom",
	"ByteVectorAtom",
	"BooleanAtom",
	"StringAtom",
	"UnicodeCharAtom",
	"HexDigit",
	"EscapedCharAtom",
	"CharAtom",
	"Char",
	"IntegerAtom",
	"Digit",
	"ListAtom",
	"ExprSeq",
	"AtomExpr",
	"MultGroupOpAtom",
	"SumGroupOpAtom",
	"ConsOpAtom",
	"CompareGroupOpAtom",
	"EqualityGroupOpAtom",
	"AndOpAtom",
	"OrOpAtom",
	"Expr",
	"ParExpr",
	"GettableExpr",
	"FunctionCallAccess",
	"IdentifierAtomAccess",
	"ListAccess",
	"Block",
	"BlockWithoutPar",
	"BlockDecExprSep",
	"FunctionCall",
	"FoldMacro",
	"IfWithError",
	"If",
	"FailedIfWithoutElse",
	"Match",
	"MatchCase",
	"DefaultMatchCasePart",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Parser struct {
	Buffer string
	buffer []rune
	rules  [91]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*Parser) error {
	return func(p *Parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Parser) error {
	return func(p *Parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Parser) Init(options ...func(*Parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Code <- <(DAppRoot / ScriptRoot)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[ruleDAppRoot]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[ruleScriptRoot]() {
						goto l0
					}
				}
			l2:
				add(ruleCode, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 DAppRoot <- <(_ (Directive _)* (_ Declaration)* (_ AnnotatedFunc)* _ EOF)> */
		func() bool {
			position4, tokenIndex4 := position, tokenIndex
			{
				position5 := position
				if !_rules[rule_]() {
					goto l4
				}
			l6:
				{
					position7, tokenIndex7 := position, tokenIndex
					if !_rules[ruleDirective]() {
						goto l7
					}
					if !_rules[rule_]() {
						goto l7
					}
					goto l6
				l7:
					position, tokenIndex = position7, tokenIndex7
				}
			l8:
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[rule_]() {
						goto l9
					}
					if !_rules[ruleDeclaration]() {
						goto l9
					}
					goto l8
				l9:
					position, tokenIndex = position9, tokenIndex9
				}
			l10:
				{
					position11, tokenIndex11 := position, tokenIndex
					if !_rules[rule_]() {
						goto l11
					}
					if !_rules[ruleAnnotatedFunc]() {
						goto l11
					}
					goto l10
				l11:
					position, tokenIndex = position11, tokenIndex11
				}
				if !_rules[rule_]() {
					goto l4
				}
				if !_rules[ruleEOF]() {
					goto l4
				}
				add(ruleDAppRoot, position5)
			}
			return true
		l4:
			position, tokenIndex = position4, tokenIndex4
			return false
		},
		/* 2 ScriptRoot <- <(_ (Directive _)* (_ Declaration)* _ BlockDecExprSep? _ Expr _ EOF)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[rule_]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleDirective]() {
						goto l15
					}
					if !_rules[rule_]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
			l16:
				{
					position17, tokenIndex17 := position, tokenIndex
					if !_rules[rule_]() {
						goto l17
					}
					if !_rules[ruleDeclaration]() {
						goto l17
					}
					goto l16
				l17:
					position, tokenIndex = position17, tokenIndex17
				}
				if !_rules[rule_]() {
					goto l12
				}
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleBlockDecExprSep]() {
						goto l18
					}
					goto l19
				l18:
					position, tokenIndex = position18, tokenIndex18
				}
			l19:
				if !_rules[rule_]() {
					goto l12
				}
				if !_rules[ruleExpr]() {
					goto l12
				}
				if !_rules[rule_]() {
					goto l12
				}
				if !_rules[ruleEOF]() {
					goto l12
				}
				add(ruleScriptRoot, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 WS <- <(' ' / '\t')+> */
		func() bool {
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				{
					position24, tokenIndex24 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l25
					}
					position++
					goto l24
				l25:
					position, tokenIndex = position24, tokenIndex24
					if buffer[position] != rune('\t') {
						goto l20
					}
					position++
				}
			l24:
			l22:
				{
					position23, tokenIndex23 := position, tokenIndex
					{
						position26, tokenIndex26 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l27
						}
						position++
						goto l26
					l27:
						position, tokenIndex = position26, tokenIndex26
						if buffer[position] != rune('\t') {
							goto l23
						}
						position++
					}
				l26:
					goto l22
				l23:
					position, tokenIndex = position23, tokenIndex23
				}
				add(ruleWS, position21)
			}
			return true
		l20:
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 4 NewLine <- <(' ' / '\t' / '\n' / '\r' / '\f')+> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position32, tokenIndex32 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l33
					}
					position++
					goto l32
				l33:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\t') {
						goto l34
					}
					position++
					goto l32
				l34:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
					goto l32
				l35:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\r') {
						goto l36
					}
					position++
					goto l32
				l36:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\f') {
						goto l28
					}
					position++
				}
			l32:
			l30:
				{
					position31, tokenIndex31 := position, tokenIndex
					{
						position37, tokenIndex37 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l38
						}
						position++
						goto l37
					l38:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\t') {
							goto l39
						}
						position++
						goto l37
					l39:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\n') {
							goto l40
						}
						position++
						goto l37
					l40:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\r') {
							goto l41
						}
						position++
						goto l37
					l41:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\f') {
							goto l31
						}
						position++
					}
				l37:
					goto l30
				l31:
					position, tokenIndex = position31, tokenIndex31
				}
				add(ruleNewLine, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 5 Comment <- <('#' !('-' '}') (!('\r' / '\n') .)+ ('\r' / '\n'))> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				if buffer[position] != rune('#') {
					goto l42
				}
				position++
				{
					position44, tokenIndex44 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l44
					}
					position++
					if buffer[position] != rune('}') {
						goto l44
					}
					position++
					goto l42
				l44:
					position, tokenIndex = position44, tokenIndex44
				}
				{
					position47, tokenIndex47 := position, tokenIndex
					{
						position48, tokenIndex48 := position, tokenIndex
						if buffer[position] != rune('\r') {
							goto l49
						}
						position++
						goto l48
					l49:
						position, tokenIndex = position48, tokenIndex48
						if buffer[position] != rune('\n') {
							goto l47
						}
						position++
					}
				l48:
					goto l42
				l47:
					position, tokenIndex = position47, tokenIndex47
				}
				if !matchDot() {
					goto l42
				}
			l45:
				{
					position46, tokenIndex46 := position, tokenIndex
					{
						position50, tokenIndex50 := position, tokenIndex
						{
							position51, tokenIndex51 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l52
							}
							position++
							goto l51
						l52:
							position, tokenIndex = position51, tokenIndex51
							if buffer[position] != rune('\n') {
								goto l50
							}
							position++
						}
					l51:
						goto l46
					l50:
						position, tokenIndex = position50, tokenIndex50
					}
					if !matchDot() {
						goto l46
					}
					goto l45
				l46:
					position, tokenIndex = position46, tokenIndex46
				}
				{
					position53, tokenIndex53 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l54
					}
					position++
					goto l53
				l54:
					position, tokenIndex = position53, tokenIndex53
					if buffer[position] != rune('\n') {
						goto l42
					}
					position++
				}
			l53:
				add(ruleComment, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 6 WhiteSpace <- <(NewLine / Comment)*> */
		func() bool {
			{
				position56 := position
			l57:
				{
					position58, tokenIndex58 := position, tokenIndex
					{
						position59, tokenIndex59 := position, tokenIndex
						if !_rules[ruleNewLine]() {
							goto l60
						}
						goto l59
					l60:
						position, tokenIndex = position59, tokenIndex59
						if !_rules[ruleComment]() {
							goto l58
						}
					}
				l59:
					goto l57
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
				add(ruleWhiteSpace, position56)
			}
			return true
		},
		/* 7 _ <- <WhiteSpace> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if !_rules[ruleWhiteSpace]() {
					goto l61
				}
				add(rule_, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 8 EOF <- <!.> */
		func() bool {
			position63, tokenIndex63 := position, tokenIndex
			{
				position64 := position
				{
					position65, tokenIndex65 := position, tokenIndex
					if !matchDot() {
						goto l65
					}
					goto l63
				l65:
					position, tokenIndex = position65, tokenIndex65
				}
				add(ruleEOF, position64)
			}
			return true
		l63:
			position, tokenIndex = position63, tokenIndex63
			return false
		},
		/* 9 DirectiveName <- <([A-Z]+ ('_' / [A-Z])*)> */
		func() bool {
			position66, tokenIndex66 := position, tokenIndex
			{
				position67 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l66
				}
				position++
			l68:
				{
					position69, tokenIndex69 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l69
					}
					position++
					goto l68
				l69:
					position, tokenIndex = position69, tokenIndex69
				}
			l70:
				{
					position71, tokenIndex71 := position, tokenIndex
					{
						position72, tokenIndex72 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l73
						}
						position++
						goto l72
					l73:
						position, tokenIndex = position72, tokenIndex72
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l71
						}
						position++
					}
				l72:
					goto l70
				l71:
					position, tokenIndex = position71, tokenIndex71
				}
				add(ruleDirectiveName, position67)
			}
			return true
		l66:
			position, tokenIndex = position66, tokenIndex66
			return false
		},
		/* 10 UpperCaseString <- <[A-Z]+> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l74
				}
				position++
			l76:
				{
					position77, tokenIndex77 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l77
					}
					position++
					goto l76
				l77:
					position, tokenIndex = position77, tokenIndex77
				}
				add(ruleUpperCaseString, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 11 IntString <- <[0-9]+> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l78
				}
				position++
			l80:
				{
					position81, tokenIndex81 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l81
					}
					position++
					goto l80
				l81:
					position, tokenIndex = position81, tokenIndex81
				}
				add(ruleIntString, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 12 PathString <- <('_' / [a-z] / [A-Z] / [0-9] / '-' / '/' / ',' / '.')+> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				{
					position86, tokenIndex86 := position, tokenIndex
					if buffer[position] != rune('_') {
						goto l87
					}
					position++
					goto l86
				l87:
					position, tokenIndex = position86, tokenIndex86
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l88
					}
					position++
					goto l86
				l88:
					position, tokenIndex = position86, tokenIndex86
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l89
					}
					position++
					goto l86
				l89:
					position, tokenIndex = position86, tokenIndex86
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l90
					}
					position++
					goto l86
				l90:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune('-') {
						goto l91
					}
					position++
					goto l86
				l91:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune('/') {
						goto l92
					}
					position++
					goto l86
				l92:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune(',') {
						goto l93
					}
					position++
					goto l86
				l93:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune('.') {
						goto l82
					}
					position++
				}
			l86:
			l84:
				{
					position85, tokenIndex85 := position, tokenIndex
					{
						position94, tokenIndex94 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l95
						}
						position++
						goto l94
					l95:
						position, tokenIndex = position94, tokenIndex94
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l96
						}
						position++
						goto l94
					l96:
						position, tokenIndex = position94, tokenIndex94
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l97
						}
						position++
						goto l94
					l97:
						position, tokenIndex = position94, tokenIndex94
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l98
						}
						position++
						goto l94
					l98:
						position, tokenIndex = position94, tokenIndex94
						if buffer[position] != rune('-') {
							goto l99
						}
						position++
						goto l94
					l99:
						position, tokenIndex = position94, tokenIndex94
						if buffer[position] != rune('/') {
							goto l100
						}
						position++
						goto l94
					l100:
						position, tokenIndex = position94, tokenIndex94
						if buffer[position] != rune(',') {
							goto l101
						}
						position++
						goto l94
					l101:
						position, tokenIndex = position94, tokenIndex94
						if buffer[position] != rune('.') {
							goto l85
						}
						position++
					}
				l94:
					goto l84
				l85:
					position, tokenIndex = position85, tokenIndex85
				}
				add(rulePathString, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 13 Directive <- <('{' '-' '#' WS DirectiveName WS (IntString / UpperCaseString / PathString) WS ('#' '-' '}'))> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				if buffer[position] != rune('{') {
					goto l102
				}
				position++
				if buffer[position] != rune('-') {
					goto l102
				}
				position++
				if buffer[position] != rune('#') {
					goto l102
				}
				position++
				if !_rules[ruleWS]() {
					goto l102
				}
				if !_rules[ruleDirectiveName]() {
					goto l102
				}
				if !_rules[ruleWS]() {
					goto l102
				}
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[ruleIntString]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleUpperCaseString]() {
						goto l106
					}
					goto l104
				l106:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[rulePathString]() {
						goto l102
					}
				}
			l104:
				if !_rules[ruleWS]() {
					goto l102
				}
				if buffer[position] != rune('#') {
					goto l102
				}
				position++
				if buffer[position] != rune('-') {
					goto l102
				}
				position++
				if buffer[position] != rune('}') {
					goto l102
				}
				position++
				add(ruleDirective, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 14 Declaration <- <(Variable / Func)> */
		func() bool {
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if !_rules[ruleVariable]() {
						goto l110
					}
					goto l109
				l110:
					position, tokenIndex = position109, tokenIndex109
					if !_rules[ruleFunc]() {
						goto l107
					}
				}
			l109:
				add(ruleDeclaration, position108)
			}
			return true
		l107:
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 15 Variable <- <(('l' / 'L') ('e' / 'E') ('t' / 'T') _ IdentifierAtom _ '=' _ Expr)> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				{
					position113, tokenIndex113 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l114
					}
					position++
					goto l113
				l114:
					position, tokenIndex = position113, tokenIndex113
					if buffer[position] != rune('L') {
						goto l111
					}
					position++
				}
			l113:
				{
					position115, tokenIndex115 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l116
					}
					position++
					goto l115
				l116:
					position, tokenIndex = position115, tokenIndex115
					if buffer[position] != rune('E') {
						goto l111
					}
					position++
				}
			l115:
				{
					position117, tokenIndex117 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l118
					}
					position++
					goto l117
				l118:
					position, tokenIndex = position117, tokenIndex117
					if buffer[position] != rune('T') {
						goto l111
					}
					position++
				}
			l117:
				if !_rules[rule_]() {
					goto l111
				}
				if !_rules[ruleIdentifierAtom]() {
					goto l111
				}
				if !_rules[rule_]() {
					goto l111
				}
				if buffer[position] != rune('=') {
					goto l111
				}
				position++
				if !_rules[rule_]() {
					goto l111
				}
				if !_rules[ruleExpr]() {
					goto l111
				}
				add(ruleVariable, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 16 Func <- <(('f' / 'F') ('u' / 'U') ('n' / 'N') ('c' / 'C') _ IdentifierAtom _ '(' _ FuncArgSeq? _ ')' _ '=' _ Expr)> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l122
					}
					position++
					goto l121
				l122:
					position, tokenIndex = position121, tokenIndex121
					if buffer[position] != rune('F') {
						goto l119
					}
					position++
				}
			l121:
				{
					position123, tokenIndex123 := position, tokenIndex
					if buffer[position] != rune('u') {
						goto l124
					}
					position++
					goto l123
				l124:
					position, tokenIndex = position123, tokenIndex123
					if buffer[position] != rune('U') {
						goto l119
					}
					position++
				}
			l123:
				{
					position125, tokenIndex125 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l126
					}
					position++
					goto l125
				l126:
					position, tokenIndex = position125, tokenIndex125
					if buffer[position] != rune('N') {
						goto l119
					}
					position++
				}
			l125:
				{
					position127, tokenIndex127 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l128
					}
					position++
					goto l127
				l128:
					position, tokenIndex = position127, tokenIndex127
					if buffer[position] != rune('C') {
						goto l119
					}
					position++
				}
			l127:
				if !_rules[rule_]() {
					goto l119
				}
				if !_rules[ruleIdentifierAtom]() {
					goto l119
				}
				if !_rules[rule_]() {
					goto l119
				}
				if buffer[position] != rune('(') {
					goto l119
				}
				position++
				if !_rules[rule_]() {
					goto l119
				}
				{
					position129, tokenIndex129 := position, tokenIndex
					if !_rules[ruleFuncArgSeq]() {
						goto l129
					}
					goto l130
				l129:
					position, tokenIndex = position129, tokenIndex129
				}
			l130:
				if !_rules[rule_]() {
					goto l119
				}
				if buffer[position] != rune(')') {
					goto l119
				}
				position++
				if !_rules[rule_]() {
					goto l119
				}
				if buffer[position] != rune('=') {
					goto l119
				}
				position++
				if !_rules[rule_]() {
					goto l119
				}
				if !_rules[ruleExpr]() {
					goto l119
				}
				add(ruleFunc, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 17 FuncArg <- <(IdentifierAtom _ ':' _ GenericTypesAtom)> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l131
				}
				if !_rules[rule_]() {
					goto l131
				}
				if buffer[position] != rune(':') {
					goto l131
				}
				position++
				if !_rules[rule_]() {
					goto l131
				}
				if !_rules[ruleGenericTypesAtom]() {
					goto l131
				}
				add(ruleFuncArg, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 18 FuncArgSeq <- <(FuncArg ((_ ',' _ FuncArgSeq) / FuncArg)?)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if !_rules[ruleFuncArg]() {
					goto l133
				}
				{
					position135, tokenIndex135 := position, tokenIndex
					{
						position137, tokenIndex137 := position, tokenIndex
						if !_rules[rule_]() {
							goto l138
						}
						if buffer[position] != rune(',') {
							goto l138
						}
						position++
						if !_rules[rule_]() {
							goto l138
						}
						if !_rules[ruleFuncArgSeq]() {
							goto l138
						}
						goto l137
					l138:
						position, tokenIndex = position137, tokenIndex137
						if !_rules[ruleFuncArg]() {
							goto l135
						}
					}
				l137:
					goto l136
				l135:
					position, tokenIndex = position135, tokenIndex135
				}
			l136:
				add(ruleFuncArgSeq, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 19 AnnotatedFunc <- <(AnnotationSeq _ Func)> */
		func() bool {
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				if !_rules[ruleAnnotationSeq]() {
					goto l139
				}
				if !_rules[rule_]() {
					goto l139
				}
				if !_rules[ruleFunc]() {
					goto l139
				}
				add(ruleAnnotatedFunc, position140)
			}
			return true
		l139:
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 20 Annotation <- <('@' IdentifierAtom _ '(' _ IdentifierAtomSeq _ ')')> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				if buffer[position] != rune('@') {
					goto l141
				}
				position++
				if !_rules[ruleIdentifierAtom]() {
					goto l141
				}
				if !_rules[rule_]() {
					goto l141
				}
				if buffer[position] != rune('(') {
					goto l141
				}
				position++
				if !_rules[rule_]() {
					goto l141
				}
				if !_rules[ruleIdentifierAtomSeq]() {
					goto l141
				}
				if !_rules[rule_]() {
					goto l141
				}
				if buffer[position] != rune(')') {
					goto l141
				}
				position++
				add(ruleAnnotation, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 21 IdentifierAtomSeq <- <(IdentifierAtom ((_ ',' _ IdentifierAtomSeq) / IdentifierAtom)?)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l143
				}
				{
					position145, tokenIndex145 := position, tokenIndex
					{
						position147, tokenIndex147 := position, tokenIndex
						if !_rules[rule_]() {
							goto l148
						}
						if buffer[position] != rune(',') {
							goto l148
						}
						position++
						if !_rules[rule_]() {
							goto l148
						}
						if !_rules[ruleIdentifierAtomSeq]() {
							goto l148
						}
						goto l147
					l148:
						position, tokenIndex = position147, tokenIndex147
						if !_rules[ruleIdentifierAtom]() {
							goto l145
						}
					}
				l147:
					goto l146
				l145:
					position, tokenIndex = position145, tokenIndex145
				}
			l146:
				add(ruleIdentifierAtomSeq, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 22 AnnotationSeq <- <(Annotation ((_ AnnotationSeq) / Annotation)?)> */
		func() bool {
			position149, tokenIndex149 := position, tokenIndex
			{
				position150 := position
				if !_rules[ruleAnnotation]() {
					goto l149
				}
				{
					position151, tokenIndex151 := position, tokenIndex
					{
						position153, tokenIndex153 := position, tokenIndex
						if !_rules[rule_]() {
							goto l154
						}
						if !_rules[ruleAnnotationSeq]() {
							goto l154
						}
						goto l153
					l154:
						position, tokenIndex = position153, tokenIndex153
						if !_rules[ruleAnnotation]() {
							goto l151
						}
					}
				l153:
					goto l152
				l151:
					position, tokenIndex = position151, tokenIndex151
				}
			l152:
				add(ruleAnnotationSeq, position150)
			}
			return true
		l149:
			position, tokenIndex = position149, tokenIndex149
			return false
		},
		/* 23 OrOp <- <('|' '|')> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				if buffer[position] != rune('|') {
					goto l155
				}
				position++
				if buffer[position] != rune('|') {
					goto l155
				}
				position++
				add(ruleOrOp, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 24 AndOp <- <('&' '&')> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				if buffer[position] != rune('&') {
					goto l157
				}
				position++
				if buffer[position] != rune('&') {
					goto l157
				}
				position++
				add(ruleAndOp, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
		/* 25 EqGroupOp <- <(EqOp / NeOp)> */
		func() bool {
			position159, tokenIndex159 := position, tokenIndex
			{
				position160 := position
				{
					position161, tokenIndex161 := position, tokenIndex
					if !_rules[ruleEqOp]() {
						goto l162
					}
					goto l161
				l162:
					position, tokenIndex = position161, tokenIndex161
					if !_rules[ruleNeOp]() {
						goto l159
					}
				}
			l161:
				add(ruleEqGroupOp, position160)
			}
			return true
		l159:
			position, tokenIndex = position159, tokenIndex159
			return false
		},
		/* 26 EqOp <- <('=' '=')> */
		func() bool {
			position163, tokenIndex163 := position, tokenIndex
			{
				position164 := position
				if buffer[position] != rune('=') {
					goto l163
				}
				position++
				if buffer[position] != rune('=') {
					goto l163
				}
				position++
				add(ruleEqOp, position164)
			}
			return true
		l163:
			position, tokenIndex = position163, tokenIndex163
			return false
		},
		/* 27 NeOp <- <('!' '=')> */
		func() bool {
			position165, tokenIndex165 := position, tokenIndex
			{
				position166 := position
				if buffer[position] != rune('!') {
					goto l165
				}
				position++
				if buffer[position] != rune('=') {
					goto l165
				}
				position++
				add(ruleNeOp, position166)
			}
			return true
		l165:
			position, tokenIndex = position165, tokenIndex165
			return false
		},
		/* 28 CompareGroupOp <- <(GtOp / GeOp / LtOp / LeOp)> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				{
					position169, tokenIndex169 := position, tokenIndex
					if !_rules[ruleGtOp]() {
						goto l170
					}
					goto l169
				l170:
					position, tokenIndex = position169, tokenIndex169
					if !_rules[ruleGeOp]() {
						goto l171
					}
					goto l169
				l171:
					position, tokenIndex = position169, tokenIndex169
					if !_rules[ruleLtOp]() {
						goto l172
					}
					goto l169
				l172:
					position, tokenIndex = position169, tokenIndex169
					if !_rules[ruleLeOp]() {
						goto l167
					}
				}
			l169:
				add(ruleCompareGroupOp, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 29 GtOp <- <('>' !'=')> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('>') {
					goto l173
				}
				position++
				{
					position175, tokenIndex175 := position, tokenIndex
					if buffer[position] != rune('=') {
						goto l175
					}
					position++
					goto l173
				l175:
					position, tokenIndex = position175, tokenIndex175
				}
				add(ruleGtOp, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 30 GeOp <- <('>' '=')> */
		func() bool {
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				if buffer[position] != rune('>') {
					goto l176
				}
				position++
				if buffer[position] != rune('=') {
					goto l176
				}
				position++
				add(ruleGeOp, position177)
			}
			return true
		l176:
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 31 LtOp <- <('<' !'=')> */
		func() bool {
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				if buffer[position] != rune('<') {
					goto l178
				}
				position++
				{
					position180, tokenIndex180 := position, tokenIndex
					if buffer[position] != rune('=') {
						goto l180
					}
					position++
					goto l178
				l180:
					position, tokenIndex = position180, tokenIndex180
				}
				add(ruleLtOp, position179)
			}
			return true
		l178:
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 32 LeOp <- <('<' '=')> */
		func() bool {
			position181, tokenIndex181 := position, tokenIndex
			{
				position182 := position
				if buffer[position] != rune('<') {
					goto l181
				}
				position++
				if buffer[position] != rune('=') {
					goto l181
				}
				position++
				add(ruleLeOp, position182)
			}
			return true
		l181:
			position, tokenIndex = position181, tokenIndex181
			return false
		},
		/* 33 ConsOp <- <(':' ':')> */
		func() bool {
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				if buffer[position] != rune(':') {
					goto l183
				}
				position++
				if buffer[position] != rune(':') {
					goto l183
				}
				position++
				add(ruleConsOp, position184)
			}
			return true
		l183:
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 34 SumGroupOp <- <(SumOp / SubOp)> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				{
					position187, tokenIndex187 := position, tokenIndex
					if !_rules[ruleSumOp]() {
						goto l188
					}
					goto l187
				l188:
					position, tokenIndex = position187, tokenIndex187
					if !_rules[ruleSubOp]() {
						goto l185
					}
				}
			l187:
				add(ruleSumGroupOp, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 35 SumOp <- <'+'> */
		func() bool {
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				if buffer[position] != rune('+') {
					goto l189
				}
				position++
				add(ruleSumOp, position190)
			}
			return true
		l189:
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 36 SubOp <- <'-'> */
		func() bool {
			position191, tokenIndex191 := position, tokenIndex
			{
				position192 := position
				if buffer[position] != rune('-') {
					goto l191
				}
				position++
				add(ruleSubOp, position192)
			}
			return true
		l191:
			position, tokenIndex = position191, tokenIndex191
			return false
		},
		/* 37 MultGroupOp <- <(MulOp / DivOp / ModOp)> */
		func() bool {
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				{
					position195, tokenIndex195 := position, tokenIndex
					if !_rules[ruleMulOp]() {
						goto l196
					}
					goto l195
				l196:
					position, tokenIndex = position195, tokenIndex195
					if !_rules[ruleDivOp]() {
						goto l197
					}
					goto l195
				l197:
					position, tokenIndex = position195, tokenIndex195
					if !_rules[ruleModOp]() {
						goto l193
					}
				}
			l195:
				add(ruleMultGroupOp, position194)
			}
			return true
		l193:
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 38 MulOp <- <'*'> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if buffer[position] != rune('*') {
					goto l198
				}
				position++
				add(ruleMulOp, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 39 DivOp <- <'/'> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				if buffer[position] != rune('/') {
					goto l200
				}
				position++
				add(ruleDivOp, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 40 ModOp <- <'%'> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				if buffer[position] != rune('%') {
					goto l202
				}
				position++
				add(ruleModOp, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 41 UnaryOp <- <(PositiveOp / NegativeOp / NotOp)> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				{
					position206, tokenIndex206 := position, tokenIndex
					if !_rules[rulePositiveOp]() {
						goto l207
					}
					goto l206
				l207:
					position, tokenIndex = position206, tokenIndex206
					if !_rules[ruleNegativeOp]() {
						goto l208
					}
					goto l206
				l208:
					position, tokenIndex = position206, tokenIndex206
					if !_rules[ruleNotOp]() {
						goto l204
					}
				}
			l206:
				add(ruleUnaryOp, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 42 PositiveOp <- <'+'> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if buffer[position] != rune('+') {
					goto l209
				}
				position++
				add(rulePositiveOp, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 43 NegativeOp <- <'-'> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if buffer[position] != rune('-') {
					goto l211
				}
				position++
				add(ruleNegativeOp, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 44 NotOp <- <'!'> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				if buffer[position] != rune('!') {
					goto l213
				}
				position++
				add(ruleNotOp, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 45 ReservedWords <- <((('l' / 'L') ('e' / 'E') ('t' / 'T')) / (('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') '1' '6') / (('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') '5' '8') / (('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') '6' '4') / (('t' / 'T') ('r' / 'R') ('u' / 'U') ('e' / 'E')) / (('f' / 'F') ('a' / 'A') ('l' / 'L') ('s' / 'S') ('e' / 'E')) / (('i' / 'I') ('f' / 'F')) / (('t' / 'T') ('h' / 'H') ('e' / 'E') ('n' / 'N')) / (('e' / 'E') ('l' / 'L') ('s' / 'S') ('e' / 'E')) / (('m' / 'M') ('a' / 'A') ('t' / 'T') ('c' / 'C') ('h' / 'H')) / (('c' / 'C') ('a' / 'A') ('s' / 'S') ('e' / 'E')) / (('f' / 'F') ('u' / 'U') ('n' / 'N') ('c' / 'C')))> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				{
					position217, tokenIndex217 := position, tokenIndex
					{
						position219, tokenIndex219 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l220
						}
						position++
						goto l219
					l220:
						position, tokenIndex = position219, tokenIndex219
						if buffer[position] != rune('L') {
							goto l218
						}
						position++
					}
				l219:
					{
						position221, tokenIndex221 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l222
						}
						position++
						goto l221
					l222:
						position, tokenIndex = position221, tokenIndex221
						if buffer[position] != rune('E') {
							goto l218
						}
						position++
					}
				l221:
					{
						position223, tokenIndex223 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l224
						}
						position++
						goto l223
					l224:
						position, tokenIndex = position223, tokenIndex223
						if buffer[position] != rune('T') {
							goto l218
						}
						position++
					}
				l223:
					goto l217
				l218:
					position, tokenIndex = position217, tokenIndex217
					{
						position226, tokenIndex226 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l227
						}
						position++
						goto l226
					l227:
						position, tokenIndex = position226, tokenIndex226
						if buffer[position] != rune('B') {
							goto l225
						}
						position++
					}
				l226:
					{
						position228, tokenIndex228 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l229
						}
						position++
						goto l228
					l229:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('A') {
							goto l225
						}
						position++
					}
				l228:
					{
						position230, tokenIndex230 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l231
						}
						position++
						goto l230
					l231:
						position, tokenIndex = position230, tokenIndex230
						if buffer[position] != rune('S') {
							goto l225
						}
						position++
					}
				l230:
					{
						position232, tokenIndex232 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l233
						}
						position++
						goto l232
					l233:
						position, tokenIndex = position232, tokenIndex232
						if buffer[position] != rune('E') {
							goto l225
						}
						position++
					}
				l232:
					if buffer[position] != rune('1') {
						goto l225
					}
					position++
					if buffer[position] != rune('6') {
						goto l225
					}
					position++
					goto l217
				l225:
					position, tokenIndex = position217, tokenIndex217
					{
						position235, tokenIndex235 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l236
						}
						position++
						goto l235
					l236:
						position, tokenIndex = position235, tokenIndex235
						if buffer[position] != rune('B') {
							goto l234
						}
						position++
					}
				l235:
					{
						position237, tokenIndex237 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l238
						}
						position++
						goto l237
					l238:
						position, tokenIndex = position237, tokenIndex237
						if buffer[position] != rune('A') {
							goto l234
						}
						position++
					}
				l237:
					{
						position239, tokenIndex239 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l240
						}
						position++
						goto l239
					l240:
						position, tokenIndex = position239, tokenIndex239
						if buffer[position] != rune('S') {
							goto l234
						}
						position++
					}
				l239:
					{
						position241, tokenIndex241 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l242
						}
						position++
						goto l241
					l242:
						position, tokenIndex = position241, tokenIndex241
						if buffer[position] != rune('E') {
							goto l234
						}
						position++
					}
				l241:
					if buffer[position] != rune('5') {
						goto l234
					}
					position++
					if buffer[position] != rune('8') {
						goto l234
					}
					position++
					goto l217
				l234:
					position, tokenIndex = position217, tokenIndex217
					{
						position244, tokenIndex244 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l245
						}
						position++
						goto l244
					l245:
						position, tokenIndex = position244, tokenIndex244
						if buffer[position] != rune('B') {
							goto l243
						}
						position++
					}
				l244:
					{
						position246, tokenIndex246 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l247
						}
						position++
						goto l246
					l247:
						position, tokenIndex = position246, tokenIndex246
						if buffer[position] != rune('A') {
							goto l243
						}
						position++
					}
				l246:
					{
						position248, tokenIndex248 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l249
						}
						position++
						goto l248
					l249:
						position, tokenIndex = position248, tokenIndex248
						if buffer[position] != rune('S') {
							goto l243
						}
						position++
					}
				l248:
					{
						position250, tokenIndex250 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l251
						}
						position++
						goto l250
					l251:
						position, tokenIndex = position250, tokenIndex250
						if buffer[position] != rune('E') {
							goto l243
						}
						position++
					}
				l250:
					if buffer[position] != rune('6') {
						goto l243
					}
					position++
					if buffer[position] != rune('4') {
						goto l243
					}
					position++
					goto l217
				l243:
					position, tokenIndex = position217, tokenIndex217
					{
						position253, tokenIndex253 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l254
						}
						position++
						goto l253
					l254:
						position, tokenIndex = position253, tokenIndex253
						if buffer[position] != rune('T') {
							goto l252
						}
						position++
					}
				l253:
					{
						position255, tokenIndex255 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l256
						}
						position++
						goto l255
					l256:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('R') {
							goto l252
						}
						position++
					}
				l255:
					{
						position257, tokenIndex257 := position, tokenIndex
						if buffer[position] != rune('u') {
							goto l258
						}
						position++
						goto l257
					l258:
						position, tokenIndex = position257, tokenIndex257
						if buffer[position] != rune('U') {
							goto l252
						}
						position++
					}
				l257:
					{
						position259, tokenIndex259 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l260
						}
						position++
						goto l259
					l260:
						position, tokenIndex = position259, tokenIndex259
						if buffer[position] != rune('E') {
							goto l252
						}
						position++
					}
				l259:
					goto l217
				l252:
					position, tokenIndex = position217, tokenIndex217
					{
						position262, tokenIndex262 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l263
						}
						position++
						goto l262
					l263:
						position, tokenIndex = position262, tokenIndex262
						if buffer[position] != rune('F') {
							goto l261
						}
						position++
					}
				l262:
					{
						position264, tokenIndex264 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l265
						}
						position++
						goto l264
					l265:
						position, tokenIndex = position264, tokenIndex264
						if buffer[position] != rune('A') {
							goto l261
						}
						position++
					}
				l264:
					{
						position266, tokenIndex266 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l267
						}
						position++
						goto l266
					l267:
						position, tokenIndex = position266, tokenIndex266
						if buffer[position] != rune('L') {
							goto l261
						}
						position++
					}
				l266:
					{
						position268, tokenIndex268 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l269
						}
						position++
						goto l268
					l269:
						position, tokenIndex = position268, tokenIndex268
						if buffer[position] != rune('S') {
							goto l261
						}
						position++
					}
				l268:
					{
						position270, tokenIndex270 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l271
						}
						position++
						goto l270
					l271:
						position, tokenIndex = position270, tokenIndex270
						if buffer[position] != rune('E') {
							goto l261
						}
						position++
					}
				l270:
					goto l217
				l261:
					position, tokenIndex = position217, tokenIndex217
					{
						position273, tokenIndex273 := position, tokenIndex
						if buffer[position] != rune('i') {
							goto l274
						}
						position++
						goto l273
					l274:
						position, tokenIndex = position273, tokenIndex273
						if buffer[position] != rune('I') {
							goto l272
						}
						position++
					}
				l273:
					{
						position275, tokenIndex275 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l276
						}
						position++
						goto l275
					l276:
						position, tokenIndex = position275, tokenIndex275
						if buffer[position] != rune('F') {
							goto l272
						}
						position++
					}
				l275:
					goto l217
				l272:
					position, tokenIndex = position217, tokenIndex217
					{
						position278, tokenIndex278 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l279
						}
						position++
						goto l278
					l279:
						position, tokenIndex = position278, tokenIndex278
						if buffer[position] != rune('T') {
							goto l277
						}
						position++
					}
				l278:
					{
						position280, tokenIndex280 := position, tokenIndex
						if buffer[position] != rune('h') {
							goto l281
						}
						position++
						goto l280
					l281:
						position, tokenIndex = position280, tokenIndex280
						if buffer[position] != rune('H') {
							goto l277
						}
						position++
					}
				l280:
					{
						position282, tokenIndex282 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l283
						}
						position++
						goto l282
					l283:
						position, tokenIndex = position282, tokenIndex282
						if buffer[position] != rune('E') {
							goto l277
						}
						position++
					}
				l282:
					{
						position284, tokenIndex284 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l285
						}
						position++
						goto l284
					l285:
						position, tokenIndex = position284, tokenIndex284
						if buffer[position] != rune('N') {
							goto l277
						}
						position++
					}
				l284:
					goto l217
				l277:
					position, tokenIndex = position217, tokenIndex217
					{
						position287, tokenIndex287 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l288
						}
						position++
						goto l287
					l288:
						position, tokenIndex = position287, tokenIndex287
						if buffer[position] != rune('E') {
							goto l286
						}
						position++
					}
				l287:
					{
						position289, tokenIndex289 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l290
						}
						position++
						goto l289
					l290:
						position, tokenIndex = position289, tokenIndex289
						if buffer[position] != rune('L') {
							goto l286
						}
						position++
					}
				l289:
					{
						position291, tokenIndex291 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l292
						}
						position++
						goto l291
					l292:
						position, tokenIndex = position291, tokenIndex291
						if buffer[position] != rune('S') {
							goto l286
						}
						position++
					}
				l291:
					{
						position293, tokenIndex293 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l294
						}
						position++
						goto l293
					l294:
						position, tokenIndex = position293, tokenIndex293
						if buffer[position] != rune('E') {
							goto l286
						}
						position++
					}
				l293:
					goto l217
				l286:
					position, tokenIndex = position217, tokenIndex217
					{
						position296, tokenIndex296 := position, tokenIndex
						if buffer[position] != rune('m') {
							goto l297
						}
						position++
						goto l296
					l297:
						position, tokenIndex = position296, tokenIndex296
						if buffer[position] != rune('M') {
							goto l295
						}
						position++
					}
				l296:
					{
						position298, tokenIndex298 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l299
						}
						position++
						goto l298
					l299:
						position, tokenIndex = position298, tokenIndex298
						if buffer[position] != rune('A') {
							goto l295
						}
						position++
					}
				l298:
					{
						position300, tokenIndex300 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l301
						}
						position++
						goto l300
					l301:
						position, tokenIndex = position300, tokenIndex300
						if buffer[position] != rune('T') {
							goto l295
						}
						position++
					}
				l300:
					{
						position302, tokenIndex302 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l303
						}
						position++
						goto l302
					l303:
						position, tokenIndex = position302, tokenIndex302
						if buffer[position] != rune('C') {
							goto l295
						}
						position++
					}
				l302:
					{
						position304, tokenIndex304 := position, tokenIndex
						if buffer[position] != rune('h') {
							goto l305
						}
						position++
						goto l304
					l305:
						position, tokenIndex = position304, tokenIndex304
						if buffer[position] != rune('H') {
							goto l295
						}
						position++
					}
				l304:
					goto l217
				l295:
					position, tokenIndex = position217, tokenIndex217
					{
						position307, tokenIndex307 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l308
						}
						position++
						goto l307
					l308:
						position, tokenIndex = position307, tokenIndex307
						if buffer[position] != rune('C') {
							goto l306
						}
						position++
					}
				l307:
					{
						position309, tokenIndex309 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l310
						}
						position++
						goto l309
					l310:
						position, tokenIndex = position309, tokenIndex309
						if buffer[position] != rune('A') {
							goto l306
						}
						position++
					}
				l309:
					{
						position311, tokenIndex311 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l312
						}
						position++
						goto l311
					l312:
						position, tokenIndex = position311, tokenIndex311
						if buffer[position] != rune('S') {
							goto l306
						}
						position++
					}
				l311:
					{
						position313, tokenIndex313 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l314
						}
						position++
						goto l313
					l314:
						position, tokenIndex = position313, tokenIndex313
						if buffer[position] != rune('E') {
							goto l306
						}
						position++
					}
				l313:
					goto l217
				l306:
					position, tokenIndex = position217, tokenIndex217
					{
						position315, tokenIndex315 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l316
						}
						position++
						goto l315
					l316:
						position, tokenIndex = position315, tokenIndex315
						if buffer[position] != rune('F') {
							goto l215
						}
						position++
					}
				l315:
					{
						position317, tokenIndex317 := position, tokenIndex
						if buffer[position] != rune('u') {
							goto l318
						}
						position++
						goto l317
					l318:
						position, tokenIndex = position317, tokenIndex317
						if buffer[position] != rune('U') {
							goto l215
						}
						position++
					}
				l317:
					{
						position319, tokenIndex319 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l320
						}
						position++
						goto l319
					l320:
						position, tokenIndex = position319, tokenIndex319
						if buffer[position] != rune('N') {
							goto l215
						}
						position++
					}
				l319:
					{
						position321, tokenIndex321 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l322
						}
						position++
						goto l321
					l322:
						position, tokenIndex = position321, tokenIndex321
						if buffer[position] != rune('C') {
							goto l215
						}
						position++
					}
				l321:
				}
			l217:
				add(ruleReservedWords, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 46 ConstAtom <- <(IntegerAtom / StringAtom / ByteVectorAtom / BooleanAtom / ListAtom)> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				{
					position325, tokenIndex325 := position, tokenIndex
					if !_rules[ruleIntegerAtom]() {
						goto l326
					}
					goto l325
				l326:
					position, tokenIndex = position325, tokenIndex325
					if !_rules[ruleStringAtom]() {
						goto l327
					}
					goto l325
				l327:
					position, tokenIndex = position325, tokenIndex325
					if !_rules[ruleByteVectorAtom]() {
						goto l328
					}
					goto l325
				l328:
					position, tokenIndex = position325, tokenIndex325
					if !_rules[ruleBooleanAtom]() {
						goto l329
					}
					goto l325
				l329:
					position, tokenIndex = position325, tokenIndex325
					if !_rules[ruleListAtom]() {
						goto l323
					}
				}
			l325:
				add(ruleConstAtom, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 47 IdentifierAtom <- <((!ReservedWords Char (Char / Digit)*) / (ReservedWords (Char / Digit) (Char / Digit)*))> */
		func() bool {
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				{
					position332, tokenIndex332 := position, tokenIndex
					{
						position334, tokenIndex334 := position, tokenIndex
						if !_rules[ruleReservedWords]() {
							goto l334
						}
						goto l333
					l334:
						position, tokenIndex = position334, tokenIndex334
					}
					if !_rules[ruleChar]() {
						goto l333
					}
				l335:
					{
						position336, tokenIndex336 := position, tokenIndex
						{
							position337, tokenIndex337 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l338
							}
							goto l337
						l338:
							position, tokenIndex = position337, tokenIndex337
							if !_rules[ruleDigit]() {
								goto l336
							}
						}
					l337:
						goto l335
					l336:
						position, tokenIndex = position336, tokenIndex336
					}
					goto l332
				l333:
					position, tokenIndex = position332, tokenIndex332
					if !_rules[ruleReservedWords]() {
						goto l330
					}
					{
						position339, tokenIndex339 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l340
						}
						goto l339
					l340:
						position, tokenIndex = position339, tokenIndex339
						if !_rules[ruleDigit]() {
							goto l330
						}
					}
				l339:
				l341:
					{
						position342, tokenIndex342 := position, tokenIndex
						{
							position343, tokenIndex343 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l344
							}
							goto l343
						l344:
							position, tokenIndex = position343, tokenIndex343
							if !_rules[ruleDigit]() {
								goto l342
							}
						}
					l343:
						goto l341
					l342:
						position, tokenIndex = position342, tokenIndex342
					}
				}
			l332:
				add(ruleIdentifierAtom, position331)
			}
			return true
		l330:
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 48 ReferenceAtom <- <((!ReservedWords Char (Char / Digit)*) / (ReservedWords (Char / Digit) (Char / Digit)*))> */
		func() bool {
			position345, tokenIndex345 := position, tokenIndex
			{
				position346 := position
				{
					position347, tokenIndex347 := position, tokenIndex
					{
						position349, tokenIndex349 := position, tokenIndex
						if !_rules[ruleReservedWords]() {
							goto l349
						}
						goto l348
					l349:
						position, tokenIndex = position349, tokenIndex349
					}
					if !_rules[ruleChar]() {
						goto l348
					}
				l350:
					{
						position351, tokenIndex351 := position, tokenIndex
						{
							position352, tokenIndex352 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l353
							}
							goto l352
						l353:
							position, tokenIndex = position352, tokenIndex352
							if !_rules[ruleDigit]() {
								goto l351
							}
						}
					l352:
						goto l350
					l351:
						position, tokenIndex = position351, tokenIndex351
					}
					goto l347
				l348:
					position, tokenIndex = position347, tokenIndex347
					if !_rules[ruleReservedWords]() {
						goto l345
					}
					{
						position354, tokenIndex354 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l355
						}
						goto l354
					l355:
						position, tokenIndex = position354, tokenIndex354
						if !_rules[ruleDigit]() {
							goto l345
						}
					}
				l354:
				l356:
					{
						position357, tokenIndex357 := position, tokenIndex
						{
							position358, tokenIndex358 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l359
							}
							goto l358
						l359:
							position, tokenIndex = position358, tokenIndex358
							if !_rules[ruleDigit]() {
								goto l357
							}
						}
					l358:
						goto l356
					l357:
						position, tokenIndex = position357, tokenIndex357
					}
				}
			l347:
				add(ruleReferenceAtom, position346)
			}
			return true
		l345:
			position, tokenIndex = position345, tokenIndex345
			return false
		},
		/* 49 GenericTypesAtom <- <(OneGenericTypeAtom ((_ '|' _ GenericTypesAtom) / OneGenericTypeAtom)?)> */
		func() bool {
			position360, tokenIndex360 := position, tokenIndex
			{
				position361 := position
				if !_rules[ruleOneGenericTypeAtom]() {
					goto l360
				}
				{
					position362, tokenIndex362 := position, tokenIndex
					{
						position364, tokenIndex364 := position, tokenIndex
						if !_rules[rule_]() {
							goto l365
						}
						if buffer[position] != rune('|') {
							goto l365
						}
						position++
						if !_rules[rule_]() {
							goto l365
						}
						if !_rules[ruleGenericTypesAtom]() {
							goto l365
						}
						goto l364
					l365:
						position, tokenIndex = position364, tokenIndex364
						if !_rules[ruleOneGenericTypeAtom]() {
							goto l362
						}
					}
				l364:
					goto l363
				l362:
					position, tokenIndex = position362, tokenIndex362
				}
			l363:
				add(ruleGenericTypesAtom, position361)
			}
			return true
		l360:
			position, tokenIndex = position360, tokenIndex360
			return false
		},
		/* 50 OneGenericTypeAtom <- <(Char (Char / Digit)* (_ '[' _ OneTypeAtom _ ']' _)?)> */
		func() bool {
			position366, tokenIndex366 := position, tokenIndex
			{
				position367 := position
				if !_rules[ruleChar]() {
					goto l366
				}
			l368:
				{
					position369, tokenIndex369 := position, tokenIndex
					{
						position370, tokenIndex370 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l371
						}
						goto l370
					l371:
						position, tokenIndex = position370, tokenIndex370
						if !_rules[ruleDigit]() {
							goto l369
						}
					}
				l370:
					goto l368
				l369:
					position, tokenIndex = position369, tokenIndex369
				}
				{
					position372, tokenIndex372 := position, tokenIndex
					if !_rules[rule_]() {
						goto l372
					}
					if buffer[position] != rune('[') {
						goto l372
					}
					position++
					if !_rules[rule_]() {
						goto l372
					}
					if !_rules[ruleOneTypeAtom]() {
						goto l372
					}
					if !_rules[rule_]() {
						goto l372
					}
					if buffer[position] != rune(']') {
						goto l372
					}
					position++
					if !_rules[rule_]() {
						goto l372
					}
					goto l373
				l372:
					position, tokenIndex = position372, tokenIndex372
				}
			l373:
				add(ruleOneGenericTypeAtom, position367)
			}
			return true
		l366:
			position, tokenIndex = position366, tokenIndex366
			return false
		},
		/* 51 TypesAtom <- <(OneTypeAtom ((_ '|' _ TypesAtom) / OneTypeAtom)?)> */
		func() bool {
			position374, tokenIndex374 := position, tokenIndex
			{
				position375 := position
				if !_rules[ruleOneTypeAtom]() {
					goto l374
				}
				{
					position376, tokenIndex376 := position, tokenIndex
					{
						position378, tokenIndex378 := position, tokenIndex
						if !_rules[rule_]() {
							goto l379
						}
						if buffer[position] != rune('|') {
							goto l379
						}
						position++
						if !_rules[rule_]() {
							goto l379
						}
						if !_rules[ruleTypesAtom]() {
							goto l379
						}
						goto l378
					l379:
						position, tokenIndex = position378, tokenIndex378
						if !_rules[ruleOneTypeAtom]() {
							goto l376
						}
					}
				l378:
					goto l377
				l376:
					position, tokenIndex = position376, tokenIndex376
				}
			l377:
				add(ruleTypesAtom, position375)
			}
			return true
		l374:
			position, tokenIndex = position374, tokenIndex374
			return false
		},
		/* 52 OneTypeAtom <- <(Char (Char / Digit)*)> */
		func() bool {
			position380, tokenIndex380 := position, tokenIndex
			{
				position381 := position
				if !_rules[ruleChar]() {
					goto l380
				}
			l382:
				{
					position383, tokenIndex383 := position, tokenIndex
					{
						position384, tokenIndex384 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l385
						}
						goto l384
					l385:
						position, tokenIndex = position384, tokenIndex384
						if !_rules[ruleDigit]() {
							goto l383
						}
					}
				l384:
					goto l382
				l383:
					position, tokenIndex = position383, tokenIndex383
				}
				add(ruleOneTypeAtom, position381)
			}
			return true
		l380:
			position, tokenIndex = position380, tokenIndex380
			return false
		},
		/* 53 ByteVectorAtom <- <(('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') (('5' '8') / ('6' '4') / ('1' '6')) '\'' (!'\'' .)* '\'')> */
		func() bool {
			position386, tokenIndex386 := position, tokenIndex
			{
				position387 := position
				{
					position388, tokenIndex388 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l389
					}
					position++
					goto l388
				l389:
					position, tokenIndex = position388, tokenIndex388
					if buffer[position] != rune('B') {
						goto l386
					}
					position++
				}
			l388:
				{
					position390, tokenIndex390 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l391
					}
					position++
					goto l390
				l391:
					position, tokenIndex = position390, tokenIndex390
					if buffer[position] != rune('A') {
						goto l386
					}
					position++
				}
			l390:
				{
					position392, tokenIndex392 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l393
					}
					position++
					goto l392
				l393:
					position, tokenIndex = position392, tokenIndex392
					if buffer[position] != rune('S') {
						goto l386
					}
					position++
				}
			l392:
				{
					position394, tokenIndex394 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l395
					}
					position++
					goto l394
				l395:
					position, tokenIndex = position394, tokenIndex394
					if buffer[position] != rune('E') {
						goto l386
					}
					position++
				}
			l394:
				{
					position396, tokenIndex396 := position, tokenIndex
					if buffer[position] != rune('5') {
						goto l397
					}
					position++
					if buffer[position] != rune('8') {
						goto l397
					}
					position++
					goto l396
				l397:
					position, tokenIndex = position396, tokenIndex396
					if buffer[position] != rune('6') {
						goto l398
					}
					position++
					if buffer[position] != rune('4') {
						goto l398
					}
					position++
					goto l396
				l398:
					position, tokenIndex = position396, tokenIndex396
					if buffer[position] != rune('1') {
						goto l386
					}
					position++
					if buffer[position] != rune('6') {
						goto l386
					}
					position++
				}
			l396:
				if buffer[position] != rune('\'') {
					goto l386
				}
				position++
			l399:
				{
					position400, tokenIndex400 := position, tokenIndex
					{
						position401, tokenIndex401 := position, tokenIndex
						if buffer[position] != rune('\'') {
							goto l401
						}
						position++
						goto l400
					l401:
						position, tokenIndex = position401, tokenIndex401
					}
					if !matchDot() {
						goto l400
					}
					goto l399
				l400:
					position, tokenIndex = position400, tokenIndex400
				}
				if buffer[position] != rune('\'') {
					goto l386
				}
				position++
				add(ruleByteVectorAtom, position387)
			}
			return true
		l386:
			position, tokenIndex = position386, tokenIndex386
			return false
		},
		/* 54 BooleanAtom <- <((('t' / 'T') ('r' / 'R') ('u' / 'U') ('e' / 'E')) / (('f' / 'F') ('a' / 'A') ('l' / 'L') ('s' / 'S') ('e' / 'E')))> */
		func() bool {
			position402, tokenIndex402 := position, tokenIndex
			{
				position403 := position
				{
					position404, tokenIndex404 := position, tokenIndex
					{
						position406, tokenIndex406 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l407
						}
						position++
						goto l406
					l407:
						position, tokenIndex = position406, tokenIndex406
						if buffer[position] != rune('T') {
							goto l405
						}
						position++
					}
				l406:
					{
						position408, tokenIndex408 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l409
						}
						position++
						goto l408
					l409:
						position, tokenIndex = position408, tokenIndex408
						if buffer[position] != rune('R') {
							goto l405
						}
						position++
					}
				l408:
					{
						position410, tokenIndex410 := position, tokenIndex
						if buffer[position] != rune('u') {
							goto l411
						}
						position++
						goto l410
					l411:
						position, tokenIndex = position410, tokenIndex410
						if buffer[position] != rune('U') {
							goto l405
						}
						position++
					}
				l410:
					{
						position412, tokenIndex412 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l413
						}
						position++
						goto l412
					l413:
						position, tokenIndex = position412, tokenIndex412
						if buffer[position] != rune('E') {
							goto l405
						}
						position++
					}
				l412:
					goto l404
				l405:
					position, tokenIndex = position404, tokenIndex404
					{
						position414, tokenIndex414 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l415
						}
						position++
						goto l414
					l415:
						position, tokenIndex = position414, tokenIndex414
						if buffer[position] != rune('F') {
							goto l402
						}
						position++
					}
				l414:
					{
						position416, tokenIndex416 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l417
						}
						position++
						goto l416
					l417:
						position, tokenIndex = position416, tokenIndex416
						if buffer[position] != rune('A') {
							goto l402
						}
						position++
					}
				l416:
					{
						position418, tokenIndex418 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l419
						}
						position++
						goto l418
					l419:
						position, tokenIndex = position418, tokenIndex418
						if buffer[position] != rune('L') {
							goto l402
						}
						position++
					}
				l418:
					{
						position420, tokenIndex420 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l421
						}
						position++
						goto l420
					l421:
						position, tokenIndex = position420, tokenIndex420
						if buffer[position] != rune('S') {
							goto l402
						}
						position++
					}
				l420:
					{
						position422, tokenIndex422 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l423
						}
						position++
						goto l422
					l423:
						position, tokenIndex = position422, tokenIndex422
						if buffer[position] != rune('E') {
							goto l402
						}
						position++
					}
				l422:
				}
			l404:
				add(ruleBooleanAtom, position403)
			}
			return true
		l402:
			position, tokenIndex = position402, tokenIndex402
			return false
		},
		/* 55 StringAtom <- <('"' (UnicodeCharAtom / EscapedCharAtom / CharAtom)* '"')> */
		func() bool {
			position424, tokenIndex424 := position, tokenIndex
			{
				position425 := position
				if buffer[position] != rune('"') {
					goto l424
				}
				position++
			l426:
				{
					position427, tokenIndex427 := position, tokenIndex
					{
						position428, tokenIndex428 := position, tokenIndex
						if !_rules[ruleUnicodeCharAtom]() {
							goto l429
						}
						goto l428
					l429:
						position, tokenIndex = position428, tokenIndex428
						if !_rules[ruleEscapedCharAtom]() {
							goto l430
						}
						goto l428
					l430:
						position, tokenIndex = position428, tokenIndex428
						if !_rules[ruleCharAtom]() {
							goto l427
						}
					}
				l428:
					goto l426
				l427:
					position, tokenIndex = position427, tokenIndex427
				}
				if buffer[position] != rune('"') {
					goto l424
				}
				position++
				add(ruleStringAtom, position425)
			}
			return true
		l424:
			position, tokenIndex = position424, tokenIndex424
			return false
		},
		/* 56 UnicodeCharAtom <- <('\\' ('u' / 'U') HexDigit HexDigit HexDigit HexDigit)> */
		func() bool {
			position431, tokenIndex431 := position, tokenIndex
			{
				position432 := position
				if buffer[position] != rune('\\') {
					goto l431
				}
				position++
				{
					position433, tokenIndex433 := position, tokenIndex
					if buffer[position] != rune('u') {
						goto l434
					}
					position++
					goto l433
				l434:
					position, tokenIndex = position433, tokenIndex433
					if buffer[position] != rune('U') {
						goto l431
					}
					position++
				}
			l433:
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				add(ruleUnicodeCharAtom, position432)
			}
			return true
		l431:
			position, tokenIndex = position431, tokenIndex431
			return false
		},
		/* 57 HexDigit <- <(Char / Digit)> */
		func() bool {
			position435, tokenIndex435 := position, tokenIndex
			{
				position436 := position
				{
					position437, tokenIndex437 := position, tokenIndex
					if !_rules[ruleChar]() {
						goto l438
					}
					goto l437
				l438:
					position, tokenIndex = position437, tokenIndex437
					if !_rules[ruleDigit]() {
						goto l435
					}
				}
			l437:
				add(ruleHexDigit, position436)
			}
			return true
		l435:
			position, tokenIndex = position435, tokenIndex435
			return false
		},
		/* 58 EscapedCharAtom <- <('\\' .)> */
		func() bool {
			position439, tokenIndex439 := position, tokenIndex
			{
				position440 := position
				if buffer[position] != rune('\\') {
					goto l439
				}
				position++
				if !matchDot() {
					goto l439
				}
				add(ruleEscapedCharAtom, position440)
			}
			return true
		l439:
			position, tokenIndex = position439, tokenIndex439
			return false
		},
		/* 59 CharAtom <- <(!'"' .)> */
		func() bool {
			position441, tokenIndex441 := position, tokenIndex
			{
				position442 := position
				{
					position443, tokenIndex443 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l443
					}
					position++
					goto l441
				l443:
					position, tokenIndex = position443, tokenIndex443
				}
				if !matchDot() {
					goto l441
				}
				add(ruleCharAtom, position442)
			}
			return true
		l441:
			position, tokenIndex = position441, tokenIndex441
			return false
		},
		/* 60 Char <- <([a-z] / [A-Z])> */
		func() bool {
			position444, tokenIndex444 := position, tokenIndex
			{
				position445 := position
				{
					position446, tokenIndex446 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l447
					}
					position++
					goto l446
				l447:
					position, tokenIndex = position446, tokenIndex446
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l444
					}
					position++
				}
			l446:
				add(ruleChar, position445)
			}
			return true
		l444:
			position, tokenIndex = position444, tokenIndex444
			return false
		},
		/* 61 IntegerAtom <- <Digit+> */
		func() bool {
			position448, tokenIndex448 := position, tokenIndex
			{
				position449 := position
				if !_rules[ruleDigit]() {
					goto l448
				}
			l450:
				{
					position451, tokenIndex451 := position, tokenIndex
					if !_rules[ruleDigit]() {
						goto l451
					}
					goto l450
				l451:
					position, tokenIndex = position451, tokenIndex451
				}
				add(ruleIntegerAtom, position449)
			}
			return true
		l448:
			position, tokenIndex = position448, tokenIndex448
			return false
		},
		/* 62 Digit <- <[0-9]> */
		func() bool {
			position452, tokenIndex452 := position, tokenIndex
			{
				position453 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l452
				}
				position++
				add(ruleDigit, position453)
			}
			return true
		l452:
			position, tokenIndex = position452, tokenIndex452
			return false
		},
		/* 63 ListAtom <- <('[' _ ExprSeq? _ ']')> */
		func() bool {
			position454, tokenIndex454 := position, tokenIndex
			{
				position455 := position
				if buffer[position] != rune('[') {
					goto l454
				}
				position++
				if !_rules[rule_]() {
					goto l454
				}
				{
					position456, tokenIndex456 := position, tokenIndex
					if !_rules[ruleExprSeq]() {
						goto l456
					}
					goto l457
				l456:
					position, tokenIndex = position456, tokenIndex456
				}
			l457:
				if !_rules[rule_]() {
					goto l454
				}
				if buffer[position] != rune(']') {
					goto l454
				}
				position++
				add(ruleListAtom, position455)
			}
			return true
		l454:
			position, tokenIndex = position454, tokenIndex454
			return false
		},
		/* 64 ExprSeq <- <(Expr ((_ ',' _ ExprSeq) / Expr)?)> */
		func() bool {
			position458, tokenIndex458 := position, tokenIndex
			{
				position459 := position
				if !_rules[ruleExpr]() {
					goto l458
				}
				{
					position460, tokenIndex460 := position, tokenIndex
					{
						position462, tokenIndex462 := position, tokenIndex
						if !_rules[rule_]() {
							goto l463
						}
						if buffer[position] != rune(',') {
							goto l463
						}
						position++
						if !_rules[rule_]() {
							goto l463
						}
						if !_rules[ruleExprSeq]() {
							goto l463
						}
						goto l462
					l463:
						position, tokenIndex = position462, tokenIndex462
						if !_rules[ruleExpr]() {
							goto l460
						}
					}
				l462:
					goto l461
				l460:
					position, tokenIndex = position460, tokenIndex460
				}
			l461:
				add(ruleExprSeq, position459)
			}
			return true
		l458:
			position, tokenIndex = position458, tokenIndex458
			return false
		},
		/* 65 AtomExpr <- <(UnaryOp? _ (FoldMacro / GettableExpr / IfWithError / Match / ConstAtom))> */
		func() bool {
			position464, tokenIndex464 := position, tokenIndex
			{
				position465 := position
				{
					position466, tokenIndex466 := position, tokenIndex
					if !_rules[ruleUnaryOp]() {
						goto l466
					}
					goto l467
				l466:
					position, tokenIndex = position466, tokenIndex466
				}
			l467:
				if !_rules[rule_]() {
					goto l464
				}
				{
					position468, tokenIndex468 := position, tokenIndex
					if !_rules[ruleFoldMacro]() {
						goto l469
					}
					goto l468
				l469:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleGettableExpr]() {
						goto l470
					}
					goto l468
				l470:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleIfWithError]() {
						goto l471
					}
					goto l468
				l471:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleMatch]() {
						goto l472
					}
					goto l468
				l472:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleConstAtom]() {
						goto l464
					}
				}
			l468:
				add(ruleAtomExpr, position465)
			}
			return true
		l464:
			position, tokenIndex = position464, tokenIndex464
			return false
		},
		/* 66 MultGroupOpAtom <- <(AtomExpr (_ MultGroupOp _ AtomExpr)*)> */
		func() bool {
			position473, tokenIndex473 := position, tokenIndex
			{
				position474 := position
				if !_rules[ruleAtomExpr]() {
					goto l473
				}
			l475:
				{
					position476, tokenIndex476 := position, tokenIndex
					if !_rules[rule_]() {
						goto l476
					}
					if !_rules[ruleMultGroupOp]() {
						goto l476
					}
					if !_rules[rule_]() {
						goto l476
					}
					if !_rules[ruleAtomExpr]() {
						goto l476
					}
					goto l475
				l476:
					position, tokenIndex = position476, tokenIndex476
				}
				add(ruleMultGroupOpAtom, position474)
			}
			return true
		l473:
			position, tokenIndex = position473, tokenIndex473
			return false
		},
		/* 67 SumGroupOpAtom <- <(MultGroupOpAtom (_ SumGroupOp _ MultGroupOpAtom)*)> */
		func() bool {
			position477, tokenIndex477 := position, tokenIndex
			{
				position478 := position
				if !_rules[ruleMultGroupOpAtom]() {
					goto l477
				}
			l479:
				{
					position480, tokenIndex480 := position, tokenIndex
					if !_rules[rule_]() {
						goto l480
					}
					if !_rules[ruleSumGroupOp]() {
						goto l480
					}
					if !_rules[rule_]() {
						goto l480
					}
					if !_rules[ruleMultGroupOpAtom]() {
						goto l480
					}
					goto l479
				l480:
					position, tokenIndex = position480, tokenIndex480
				}
				add(ruleSumGroupOpAtom, position478)
			}
			return true
		l477:
			position, tokenIndex = position477, tokenIndex477
			return false
		},
		/* 68 ConsOpAtom <- <(SumGroupOpAtom (_ ConsOp _ SumGroupOpAtom)*)> */
		func() bool {
			position481, tokenIndex481 := position, tokenIndex
			{
				position482 := position
				if !_rules[ruleSumGroupOpAtom]() {
					goto l481
				}
			l483:
				{
					position484, tokenIndex484 := position, tokenIndex
					if !_rules[rule_]() {
						goto l484
					}
					if !_rules[ruleConsOp]() {
						goto l484
					}
					if !_rules[rule_]() {
						goto l484
					}
					if !_rules[ruleSumGroupOpAtom]() {
						goto l484
					}
					goto l483
				l484:
					position, tokenIndex = position484, tokenIndex484
				}
				add(ruleConsOpAtom, position482)
			}
			return true
		l481:
			position, tokenIndex = position481, tokenIndex481
			return false
		},
		/* 69 CompareGroupOpAtom <- <(ConsOpAtom (_ CompareGroupOp _ ConsOpAtom)*)> */
		func() bool {
			position485, tokenIndex485 := position, tokenIndex
			{
				position486 := position
				if !_rules[ruleConsOpAtom]() {
					goto l485
				}
			l487:
				{
					position488, tokenIndex488 := position, tokenIndex
					if !_rules[rule_]() {
						goto l488
					}
					if !_rules[ruleCompareGroupOp]() {
						goto l488
					}
					if !_rules[rule_]() {
						goto l488
					}
					if !_rules[ruleConsOpAtom]() {
						goto l488
					}
					goto l487
				l488:
					position, tokenIndex = position488, tokenIndex488
				}
				add(ruleCompareGroupOpAtom, position486)
			}
			return true
		l485:
			position, tokenIndex = position485, tokenIndex485
			return false
		},
		/* 70 EqualityGroupOpAtom <- <(CompareGroupOpAtom (_ EqGroupOp _ CompareGroupOpAtom)*)> */
		func() bool {
			position489, tokenIndex489 := position, tokenIndex
			{
				position490 := position
				if !_rules[ruleCompareGroupOpAtom]() {
					goto l489
				}
			l491:
				{
					position492, tokenIndex492 := position, tokenIndex
					if !_rules[rule_]() {
						goto l492
					}
					if !_rules[ruleEqGroupOp]() {
						goto l492
					}
					if !_rules[rule_]() {
						goto l492
					}
					if !_rules[ruleCompareGroupOpAtom]() {
						goto l492
					}
					goto l491
				l492:
					position, tokenIndex = position492, tokenIndex492
				}
				add(ruleEqualityGroupOpAtom, position490)
			}
			return true
		l489:
			position, tokenIndex = position489, tokenIndex489
			return false
		},
		/* 71 AndOpAtom <- <(EqualityGroupOpAtom (_ AndOp _ EqualityGroupOpAtom)*)> */
		func() bool {
			position493, tokenIndex493 := position, tokenIndex
			{
				position494 := position
				if !_rules[ruleEqualityGroupOpAtom]() {
					goto l493
				}
			l495:
				{
					position496, tokenIndex496 := position, tokenIndex
					if !_rules[rule_]() {
						goto l496
					}
					if !_rules[ruleAndOp]() {
						goto l496
					}
					if !_rules[rule_]() {
						goto l496
					}
					if !_rules[ruleEqualityGroupOpAtom]() {
						goto l496
					}
					goto l495
				l496:
					position, tokenIndex = position496, tokenIndex496
				}
				add(ruleAndOpAtom, position494)
			}
			return true
		l493:
			position, tokenIndex = position493, tokenIndex493
			return false
		},
		/* 72 OrOpAtom <- <(AndOpAtom (_ OrOp _ AndOpAtom)*)> */
		func() bool {
			position497, tokenIndex497 := position, tokenIndex
			{
				position498 := position
				if !_rules[ruleAndOpAtom]() {
					goto l497
				}
			l499:
				{
					position500, tokenIndex500 := position, tokenIndex
					if !_rules[rule_]() {
						goto l500
					}
					if !_rules[ruleOrOp]() {
						goto l500
					}
					if !_rules[rule_]() {
						goto l500
					}
					if !_rules[ruleAndOpAtom]() {
						goto l500
					}
					goto l499
				l500:
					position, tokenIndex = position500, tokenIndex500
				}
				add(ruleOrOpAtom, position498)
			}
			return true
		l497:
			position, tokenIndex = position497, tokenIndex497
			return false
		},
		/* 73 Expr <- <OrOpAtom> */
		func() bool {
			position501, tokenIndex501 := position, tokenIndex
			{
				position502 := position
				if !_rules[ruleOrOpAtom]() {
					goto l501
				}
				add(ruleExpr, position502)
			}
			return true
		l501:
			position, tokenIndex = position501, tokenIndex501
			return false
		},
		/* 74 ParExpr <- <('(' _ Expr _ ')')> */
		func() bool {
			position503, tokenIndex503 := position, tokenIndex
			{
				position504 := position
				if buffer[position] != rune('(') {
					goto l503
				}
				position++
				if !_rules[rule_]() {
					goto l503
				}
				if !_rules[ruleExpr]() {
					goto l503
				}
				if !_rules[rule_]() {
					goto l503
				}
				if buffer[position] != rune(')') {
					goto l503
				}
				position++
				add(ruleParExpr, position504)
			}
			return true
		l503:
			position, tokenIndex = position503, tokenIndex503
			return false
		},
		/* 75 GettableExpr <- <((ParExpr / Block / FunctionCall / ReferenceAtom) (_ (ListAccess / ('.' _ (FunctionCallAccess / IdentifierAtomAccess))))*)> */
		func() bool {
			position505, tokenIndex505 := position, tokenIndex
			{
				position506 := position
				{
					position507, tokenIndex507 := position, tokenIndex
					if !_rules[ruleParExpr]() {
						goto l508
					}
					goto l507
				l508:
					position, tokenIndex = position507, tokenIndex507
					if !_rules[ruleBlock]() {
						goto l509
					}
					goto l507
				l509:
					position, tokenIndex = position507, tokenIndex507
					if !_rules[ruleFunctionCall]() {
						goto l510
					}
					goto l507
				l510:
					position, tokenIndex = position507, tokenIndex507
					if !_rules[ruleReferenceAtom]() {
						goto l505
					}
				}
			l507:
			l511:
				{
					position512, tokenIndex512 := position, tokenIndex
					if !_rules[rule_]() {
						goto l512
					}
					{
						position513, tokenIndex513 := position, tokenIndex
						if !_rules[ruleListAccess]() {
							goto l514
						}
						goto l513
					l514:
						position, tokenIndex = position513, tokenIndex513
						if buffer[position] != rune('.') {
							goto l512
						}
						position++
						if !_rules[rule_]() {
							goto l512
						}
						{
							position515, tokenIndex515 := position, tokenIndex
							if !_rules[ruleFunctionCallAccess]() {
								goto l516
							}
							goto l515
						l516:
							position, tokenIndex = position515, tokenIndex515
							if !_rules[ruleIdentifierAtomAccess]() {
								goto l512
							}
						}
					l515:
					}
				l513:
					goto l511
				l512:
					position, tokenIndex = position512, tokenIndex512
				}
				add(ruleGettableExpr, position506)
			}
			return true
		l505:
			position, tokenIndex = position505, tokenIndex505
			return false
		},
		/* 76 FunctionCallAccess <- <FunctionCall> */
		func() bool {
			position517, tokenIndex517 := position, tokenIndex
			{
				position518 := position
				if !_rules[ruleFunctionCall]() {
					goto l517
				}
				add(ruleFunctionCallAccess, position518)
			}
			return true
		l517:
			position, tokenIndex = position517, tokenIndex517
			return false
		},
		/* 77 IdentifierAtomAccess <- <IdentifierAtom> */
		func() bool {
			position519, tokenIndex519 := position, tokenIndex
			{
				position520 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l519
				}
				add(ruleIdentifierAtomAccess, position520)
			}
			return true
		l519:
			position, tokenIndex = position519, tokenIndex519
			return false
		},
		/* 78 ListAccess <- <('[' _ (Expr / ReferenceAtom) _ ']')> */
		func() bool {
			position521, tokenIndex521 := position, tokenIndex
			{
				position522 := position
				if buffer[position] != rune('[') {
					goto l521
				}
				position++
				if !_rules[rule_]() {
					goto l521
				}
				{
					position523, tokenIndex523 := position, tokenIndex
					if !_rules[ruleExpr]() {
						goto l524
					}
					goto l523
				l524:
					position, tokenIndex = position523, tokenIndex523
					if !_rules[ruleReferenceAtom]() {
						goto l521
					}
				}
			l523:
				if !_rules[rule_]() {
					goto l521
				}
				if buffer[position] != rune(']') {
					goto l521
				}
				position++
				add(ruleListAccess, position522)
			}
			return true
		l521:
			position, tokenIndex = position521, tokenIndex521
			return false
		},
		/* 79 Block <- <('{' (_ Declaration)* _ BlockDecExprSep? _ Expr _ '}')> */
		func() bool {
			position525, tokenIndex525 := position, tokenIndex
			{
				position526 := position
				if buffer[position] != rune('{') {
					goto l525
				}
				position++
			l527:
				{
					position528, tokenIndex528 := position, tokenIndex
					if !_rules[rule_]() {
						goto l528
					}
					if !_rules[ruleDeclaration]() {
						goto l528
					}
					goto l527
				l528:
					position, tokenIndex = position528, tokenIndex528
				}
				if !_rules[rule_]() {
					goto l525
				}
				{
					position529, tokenIndex529 := position, tokenIndex
					if !_rules[ruleBlockDecExprSep]() {
						goto l529
					}
					goto l530
				l529:
					position, tokenIndex = position529, tokenIndex529
				}
			l530:
				if !_rules[rule_]() {
					goto l525
				}
				if !_rules[ruleExpr]() {
					goto l525
				}
				if !_rules[rule_]() {
					goto l525
				}
				if buffer[position] != rune('}') {
					goto l525
				}
				position++
				add(ruleBlock, position526)
			}
			return true
		l525:
			position, tokenIndex = position525, tokenIndex525
			return false
		},
		/* 80 BlockWithoutPar <- <((_ Declaration)* _ BlockDecExprSep? _ Expr)> */
		func() bool {
			position531, tokenIndex531 := position, tokenIndex
			{
				position532 := position
			l533:
				{
					position534, tokenIndex534 := position, tokenIndex
					if !_rules[rule_]() {
						goto l534
					}
					if !_rules[ruleDeclaration]() {
						goto l534
					}
					goto l533
				l534:
					position, tokenIndex = position534, tokenIndex534
				}
				if !_rules[rule_]() {
					goto l531
				}
				{
					position535, tokenIndex535 := position, tokenIndex
					if !_rules[ruleBlockDecExprSep]() {
						goto l535
					}
					goto l536
				l535:
					position, tokenIndex = position535, tokenIndex535
				}
			l536:
				if !_rules[rule_]() {
					goto l531
				}
				if !_rules[ruleExpr]() {
					goto l531
				}
				add(ruleBlockWithoutPar, position532)
			}
			return true
		l531:
			position, tokenIndex = position531, tokenIndex531
			return false
		},
		/* 81 BlockDecExprSep <- <':'> */
		func() bool {
			position537, tokenIndex537 := position, tokenIndex
			{
				position538 := position
				if buffer[position] != rune(':') {
					goto l537
				}
				position++
				add(ruleBlockDecExprSep, position538)
			}
			return true
		l537:
			position, tokenIndex = position537, tokenIndex537
			return false
		},
		/* 82 FunctionCall <- <(IdentifierAtom _ '(' _ ExprSeq? _ ')')> */
		func() bool {
			position539, tokenIndex539 := position, tokenIndex
			{
				position540 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l539
				}
				if !_rules[rule_]() {
					goto l539
				}
				if buffer[position] != rune('(') {
					goto l539
				}
				position++
				if !_rules[rule_]() {
					goto l539
				}
				{
					position541, tokenIndex541 := position, tokenIndex
					if !_rules[ruleExprSeq]() {
						goto l541
					}
					goto l542
				l541:
					position, tokenIndex = position541, tokenIndex541
				}
			l542:
				if !_rules[rule_]() {
					goto l539
				}
				if buffer[position] != rune(')') {
					goto l539
				}
				position++
				add(ruleFunctionCall, position540)
			}
			return true
		l539:
			position, tokenIndex = position539, tokenIndex539
			return false
		},
		/* 83 FoldMacro <- <(('f' / 'F') ('o' / 'O') ('l' / 'L') ('d' / 'D') _ '<' _ IntegerAtom _ '>' _ '(' _ Expr _ ',' _ Expr _ ',' _ ReferenceAtom _ ')')> */
		func() bool {
			position543, tokenIndex543 := position, tokenIndex
			{
				position544 := position
				{
					position545, tokenIndex545 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l546
					}
					position++
					goto l545
				l546:
					position, tokenIndex = position545, tokenIndex545
					if buffer[position] != rune('F') {
						goto l543
					}
					position++
				}
			l545:
				{
					position547, tokenIndex547 := position, tokenIndex
					if buffer[position] != rune('o') {
						goto l548
					}
					position++
					goto l547
				l548:
					position, tokenIndex = position547, tokenIndex547
					if buffer[position] != rune('O') {
						goto l543
					}
					position++
				}
			l547:
				{
					position549, tokenIndex549 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l550
					}
					position++
					goto l549
				l550:
					position, tokenIndex = position549, tokenIndex549
					if buffer[position] != rune('L') {
						goto l543
					}
					position++
				}
			l549:
				{
					position551, tokenIndex551 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l552
					}
					position++
					goto l551
				l552:
					position, tokenIndex = position551, tokenIndex551
					if buffer[position] != rune('D') {
						goto l543
					}
					position++
				}
			l551:
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune('<') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleIntegerAtom]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune('>') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune('(') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleExpr]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune(',') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleExpr]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune(',') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleReferenceAtom]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune(')') {
					goto l543
				}
				position++
				add(ruleFoldMacro, position544)
			}
			return true
		l543:
			position, tokenIndex = position543, tokenIndex543
			return false
		},
		/* 84 IfWithError <- <(If / FailedIfWithoutElse)> */
		func() bool {
			position553, tokenIndex553 := position, tokenIndex
			{
				position554 := position
				{
					position555, tokenIndex555 := position, tokenIndex
					if !_rules[ruleIf]() {
						goto l556
					}
					goto l555
				l556:
					position, tokenIndex = position555, tokenIndex555
					if !_rules[ruleFailedIfWithoutElse]() {
						goto l553
					}
				}
			l555:
				add(ruleIfWithError, position554)
			}
			return true
		l553:
			position, tokenIndex = position553, tokenIndex553
			return false
		},
		/* 85 If <- <(('i' / 'I') ('f' / 'F') _ Expr _ (('t' / 'T') ('h' / 'H') ('e' / 'E') ('n' / 'N')) _ Expr _ (('e' / 'E') ('l' / 'L') ('s' / 'S') ('e' / 'E')) _ Expr)> */
		func() bool {
			position557, tokenIndex557 := position, tokenIndex
			{
				position558 := position
				{
					position559, tokenIndex559 := position, tokenIndex
					if buffer[position] != rune('i') {
						goto l560
					}
					position++
					goto l559
				l560:
					position, tokenIndex = position559, tokenIndex559
					if buffer[position] != rune('I') {
						goto l557
					}
					position++
				}
			l559:
				{
					position561, tokenIndex561 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l562
					}
					position++
					goto l561
				l562:
					position, tokenIndex = position561, tokenIndex561
					if buffer[position] != rune('F') {
						goto l557
					}
					position++
				}
			l561:
				if !_rules[rule_]() {
					goto l557
				}
				if !_rules[ruleExpr]() {
					goto l557
				}
				if !_rules[rule_]() {
					goto l557
				}
				{
					position563, tokenIndex563 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l564
					}
					position++
					goto l563
				l564:
					position, tokenIndex = position563, tokenIndex563
					if buffer[position] != rune('T') {
						goto l557
					}
					position++
				}
			l563:
				{
					position565, tokenIndex565 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l566
					}
					position++
					goto l565
				l566:
					position, tokenIndex = position565, tokenIndex565
					if buffer[position] != rune('H') {
						goto l557
					}
					position++
				}
			l565:
				{
					position567, tokenIndex567 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l568
					}
					position++
					goto l567
				l568:
					position, tokenIndex = position567, tokenIndex567
					if buffer[position] != rune('E') {
						goto l557
					}
					position++
				}
			l567:
				{
					position569, tokenIndex569 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l570
					}
					position++
					goto l569
				l570:
					position, tokenIndex = position569, tokenIndex569
					if buffer[position] != rune('N') {
						goto l557
					}
					position++
				}
			l569:
				if !_rules[rule_]() {
					goto l557
				}
				if !_rules[ruleExpr]() {
					goto l557
				}
				if !_rules[rule_]() {
					goto l557
				}
				{
					position571, tokenIndex571 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l572
					}
					position++
					goto l571
				l572:
					position, tokenIndex = position571, tokenIndex571
					if buffer[position] != rune('E') {
						goto l557
					}
					position++
				}
			l571:
				{
					position573, tokenIndex573 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l574
					}
					position++
					goto l573
				l574:
					position, tokenIndex = position573, tokenIndex573
					if buffer[position] != rune('L') {
						goto l557
					}
					position++
				}
			l573:
				{
					position575, tokenIndex575 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l576
					}
					position++
					goto l575
				l576:
					position, tokenIndex = position575, tokenIndex575
					if buffer[position] != rune('S') {
						goto l557
					}
					position++
				}
			l575:
				{
					position577, tokenIndex577 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l578
					}
					position++
					goto l577
				l578:
					position, tokenIndex = position577, tokenIndex577
					if buffer[position] != rune('E') {
						goto l557
					}
					position++
				}
			l577:
				if !_rules[rule_]() {
					goto l557
				}
				if !_rules[ruleExpr]() {
					goto l557
				}
				add(ruleIf, position558)
			}
			return true
		l557:
			position, tokenIndex = position557, tokenIndex557
			return false
		},
		/* 86 FailedIfWithoutElse <- <(('i' / 'I') ('f' / 'F') _ Expr _ (('t' / 'T') ('h' / 'H') ('e' / 'E') ('n' / 'N')) _ Expr)> */
		func() bool {
			position579, tokenIndex579 := position, tokenIndex
			{
				position580 := position
				{
					position581, tokenIndex581 := position, tokenIndex
					if buffer[position] != rune('i') {
						goto l582
					}
					position++
					goto l581
				l582:
					position, tokenIndex = position581, tokenIndex581
					if buffer[position] != rune('I') {
						goto l579
					}
					position++
				}
			l581:
				{
					position583, tokenIndex583 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l584
					}
					position++
					goto l583
				l584:
					position, tokenIndex = position583, tokenIndex583
					if buffer[position] != rune('F') {
						goto l579
					}
					position++
				}
			l583:
				if !_rules[rule_]() {
					goto l579
				}
				if !_rules[ruleExpr]() {
					goto l579
				}
				if !_rules[rule_]() {
					goto l579
				}
				{
					position585, tokenIndex585 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l586
					}
					position++
					goto l585
				l586:
					position, tokenIndex = position585, tokenIndex585
					if buffer[position] != rune('T') {
						goto l579
					}
					position++
				}
			l585:
				{
					position587, tokenIndex587 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l588
					}
					position++
					goto l587
				l588:
					position, tokenIndex = position587, tokenIndex587
					if buffer[position] != rune('H') {
						goto l579
					}
					position++
				}
			l587:
				{
					position589, tokenIndex589 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l590
					}
					position++
					goto l589
				l590:
					position, tokenIndex = position589, tokenIndex589
					if buffer[position] != rune('E') {
						goto l579
					}
					position++
				}
			l589:
				{
					position591, tokenIndex591 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l592
					}
					position++
					goto l591
				l592:
					position, tokenIndex = position591, tokenIndex591
					if buffer[position] != rune('N') {
						goto l579
					}
					position++
				}
			l591:
				if !_rules[rule_]() {
					goto l579
				}
				if !_rules[ruleExpr]() {
					goto l579
				}
				add(ruleFailedIfWithoutElse, position580)
			}
			return true
		l579:
			position, tokenIndex = position579, tokenIndex579
			return false
		},
		/* 87 Match <- <(('m' / 'M') ('a' / 'A') ('t' / 'T') ('c' / 'C') ('h' / 'H') _ Expr _ '{' (_ MatchCase)+ _ '}')> */
		func() bool {
			position593, tokenIndex593 := position, tokenIndex
			{
				position594 := position
				{
					position595, tokenIndex595 := position, tokenIndex
					if buffer[position] != rune('m') {
						goto l596
					}
					position++
					goto l595
				l596:
					position, tokenIndex = position595, tokenIndex595
					if buffer[position] != rune('M') {
						goto l593
					}
					position++
				}
			l595:
				{
					position597, tokenIndex597 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l598
					}
					position++
					goto l597
				l598:
					position, tokenIndex = position597, tokenIndex597
					if buffer[position] != rune('A') {
						goto l593
					}
					position++
				}
			l597:
				{
					position599, tokenIndex599 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l600
					}
					position++
					goto l599
				l600:
					position, tokenIndex = position599, tokenIndex599
					if buffer[position] != rune('T') {
						goto l593
					}
					position++
				}
			l599:
				{
					position601, tokenIndex601 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l602
					}
					position++
					goto l601
				l602:
					position, tokenIndex = position601, tokenIndex601
					if buffer[position] != rune('C') {
						goto l593
					}
					position++
				}
			l601:
				{
					position603, tokenIndex603 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l604
					}
					position++
					goto l603
				l604:
					position, tokenIndex = position603, tokenIndex603
					if buffer[position] != rune('H') {
						goto l593
					}
					position++
				}
			l603:
				if !_rules[rule_]() {
					goto l593
				}
				if !_rules[ruleExpr]() {
					goto l593
				}
				if !_rules[rule_]() {
					goto l593
				}
				if buffer[position] != rune('{') {
					goto l593
				}
				position++
				if !_rules[rule_]() {
					goto l593
				}
				if !_rules[ruleMatchCase]() {
					goto l593
				}
			l605:
				{
					position606, tokenIndex606 := position, tokenIndex
					if !_rules[rule_]() {
						goto l606
					}
					if !_rules[ruleMatchCase]() {
						goto l606
					}
					goto l605
				l606:
					position, tokenIndex = position606, tokenIndex606
				}
				if !_rules[rule_]() {
					goto l593
				}
				if buffer[position] != rune('}') {
					goto l593
				}
				position++
				add(ruleMatch, position594)
			}
			return true
		l593:
			position, tokenIndex = position593, tokenIndex593
			return false
		},
		/* 88 MatchCase <- <(('c' / 'C') ('a' / 'A') ('s' / 'S') ('e' / 'E') _ ((IdentifierAtom _ (':' _ TypesAtom)?) / DefaultMatchCasePart) _ ('=' '>') _ BlockWithoutPar)> */
		func() bool {
			position607, tokenIndex607 := position, tokenIndex
			{
				position608 := position
				{
					position609, tokenIndex609 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l610
					}
					position++
					goto l609
				l610:
					position, tokenIndex = position609, tokenIndex609
					if buffer[position] != rune('C') {
						goto l607
					}
					position++
				}
			l609:
				{
					position611, tokenIndex611 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l612
					}
					position++
					goto l611
				l612:
					position, tokenIndex = position611, tokenIndex611
					if buffer[position] != rune('A') {
						goto l607
					}
					position++
				}
			l611:
				{
					position613, tokenIndex613 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l614
					}
					position++
					goto l613
				l614:
					position, tokenIndex = position613, tokenIndex613
					if buffer[position] != rune('S') {
						goto l607
					}
					position++
				}
			l613:
				{
					position615, tokenIndex615 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l616
					}
					position++
					goto l615
				l616:
					position, tokenIndex = position615, tokenIndex615
					if buffer[position] != rune('E') {
						goto l607
					}
					position++
				}
			l615:
				if !_rules[rule_]() {
					goto l607
				}
				{
					position617, tokenIndex617 := position, tokenIndex
					if !_rules[ruleIdentifierAtom]() {
						goto l618
					}
					if !_rules[rule_]() {
						goto l618
					}
					{
						position619, tokenIndex619 := position, tokenIndex
						if buffer[position] != rune(':') {
							goto l619
						}
						position++
						if !_rules[rule_]() {
							goto l619
						}
						if !_rules[ruleTypesAtom]() {
							goto l619
						}
						goto l620
					l619:
						position, tokenIndex = position619, tokenIndex619
					}
				l620:
					goto l617
				l618:
					position, tokenIndex = position617, tokenIndex617
					if !_rules[ruleDefaultMatchCasePart]() {
						goto l607
					}
				}
			l617:
				if !_rules[rule_]() {
					goto l607
				}
				if buffer[position] != rune('=') {
					goto l607
				}
				position++
				if buffer[position] != rune('>') {
					goto l607
				}
				position++
				if !_rules[rule_]() {
					goto l607
				}
				if !_rules[ruleBlockWithoutPar]() {
					goto l607
				}
				add(ruleMatchCase, position608)
			}
			return true
		l607:
			position, tokenIndex = position607, tokenIndex607
			return false
		},
		/* 89 DefaultMatchCasePart <- <('{' _ (':' _ TypesAtom)?)> */
		func() bool {
			position621, tokenIndex621 := position, tokenIndex
			{
				position622 := position
				if buffer[position] != rune('{') {
					goto l621
				}
				position++
				if !_rules[rule_]() {
					goto l621
				}
				{
					position623, tokenIndex623 := position, tokenIndex
					if buffer[position] != rune(':') {
						goto l623
					}
					position++
					if !_rules[rule_]() {
						goto l623
					}
					if !_rules[ruleTypesAtom]() {
						goto l623
					}
					goto l624
				l623:
					position, tokenIndex = position623, tokenIndex623
				}
			l624:
				add(ruleDefaultMatchCasePart, position622)
			}
			return true
		l621:
			position, tokenIndex = position621, tokenIndex621
			return false
		},
	}
	p.rules = _rules
	return nil
}
