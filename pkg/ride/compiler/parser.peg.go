package compiler

// Code generated by peg -output=parser.peg.go ride.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleCode
	ruleDAppRoot
	ruleScriptRoot
	ruleWS
	ruleNewLine
	ruleComment
	ruleWhiteSpace
	rule_
	ruleEOF
	ruleDirectiveName
	ruleUpperCaseString
	ruleIntString
	rulePathString
	ruleDirective
	ruleDeclaration
	ruleVariable
	ruleFunc
	ruleFuncArg
	ruleFuncArgSeq
	ruleAnnotatedFunc
	ruleAnnotation
	ruleIdentifierAtomSeq
	ruleAnnotationSeq
	ruleOrOp
	ruleAndOp
	ruleEqGroupOp
	ruleEqOp
	ruleNeOp
	ruleCompareGroupOp
	ruleGtOp
	ruleGeOp
	ruleLtOp
	ruleLeOp
	ruleConsOp
	ruleSumGroupOp
	ruleSumOp
	ruleSubOp
	ruleMultGroupOp
	ruleMulOp
	ruleDivOp
	ruleModOp
	ruleUnaryOp
	rulePositiveOp
	ruleNegativeOp
	ruleNotOp
	ruleReservedWords
	ruleConstAtom
	ruleIdentifierAtom
	ruleReferenceAtom
	ruleGenericTypesAtom
	ruleOneGenericTypeAtom
	ruleTypesAtom
	ruleOneTypeAtom
	ruleByteVectorAtom
	ruleByteVectorBase
	ruleByteVectorValue
	ruleBooleanAtom
	ruleStringAtom
	ruleUnicodeCharAtom
	ruleHexDigit
	ruleEscapedCharAtom
	ruleCharAtom
	ruleChar
	ruleIntegerAtom
	ruleDigit
	ruleListAtom
	ruleExprSeq
	ruleAtomExpr
	ruleMultGroupOpAtom
	ruleSumGroupOpAtom
	ruleConsOpAtom
	ruleCompareGroupOpAtom
	ruleEqualityGroupOpAtom
	ruleAndOpAtom
	ruleOrOpAtom
	ruleExpr
	ruleParExpr
	ruleGettableExpr
	ruleFunctionCallAccess
	ruleIdentifierAtomAccess
	ruleListAccess
	ruleBlock
	ruleBlockWithoutPar
	ruleBlockDecExprSep
	ruleFunctionCall
	ruleFoldMacro
	ruleIfWithError
	ruleIf
	ruleFailedIfWithoutElse
	ruleMatch
	ruleMatchCase
	ruleDefaultMatchCasePart
)

var rul3s = [...]string{
	"Unknown",
	"Code",
	"DAppRoot",
	"ScriptRoot",
	"WS",
	"NewLine",
	"Comment",
	"WhiteSpace",
	"_",
	"EOF",
	"DirectiveName",
	"UpperCaseString",
	"IntString",
	"PathString",
	"Directive",
	"Declaration",
	"Variable",
	"Func",
	"FuncArg",
	"FuncArgSeq",
	"AnnotatedFunc",
	"Annotation",
	"IdentifierAtomSeq",
	"AnnotationSeq",
	"OrOp",
	"AndOp",
	"EqGroupOp",
	"EqOp",
	"NeOp",
	"CompareGroupOp",
	"GtOp",
	"GeOp",
	"LtOp",
	"LeOp",
	"ConsOp",
	"SumGroupOp",
	"SumOp",
	"SubOp",
	"MultGroupOp",
	"MulOp",
	"DivOp",
	"ModOp",
	"UnaryOp",
	"PositiveOp",
	"NegativeOp",
	"NotOp",
	"ReservedWords",
	"ConstAtom",
	"IdentifierAtom",
	"ReferenceAtom",
	"GenericTypesAtom",
	"OneGenericTypeAtom",
	"TypesAtom",
	"OneTypeAtom",
	"ByteVectorAtom",
	"ByteVectorBase",
	"ByteVectorValue",
	"BooleanAtom",
	"StringAtom",
	"UnicodeCharAtom",
	"HexDigit",
	"EscapedCharAtom",
	"CharAtom",
	"Char",
	"IntegerAtom",
	"Digit",
	"ListAtom",
	"ExprSeq",
	"AtomExpr",
	"MultGroupOpAtom",
	"SumGroupOpAtom",
	"ConsOpAtom",
	"CompareGroupOpAtom",
	"EqualityGroupOpAtom",
	"AndOpAtom",
	"OrOpAtom",
	"Expr",
	"ParExpr",
	"GettableExpr",
	"FunctionCallAccess",
	"IdentifierAtomAccess",
	"ListAccess",
	"Block",
	"BlockWithoutPar",
	"BlockDecExprSep",
	"FunctionCall",
	"FoldMacro",
	"IfWithError",
	"If",
	"FailedIfWithoutElse",
	"Match",
	"MatchCase",
	"DefaultMatchCasePart",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Parser struct {
	Buffer string
	buffer []rune
	rules  [93]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*Parser) error {
	return func(p *Parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Parser) error {
	return func(p *Parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Parser) Init(options ...func(*Parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Code <- <(DAppRoot / ScriptRoot)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[ruleDAppRoot]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[ruleScriptRoot]() {
						goto l0
					}
				}
			l2:
				add(ruleCode, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 DAppRoot <- <(_ (Directive _)* (_ Declaration)* (_ AnnotatedFunc)* _ EOF)> */
		func() bool {
			position4, tokenIndex4 := position, tokenIndex
			{
				position5 := position
				if !_rules[rule_]() {
					goto l4
				}
			l6:
				{
					position7, tokenIndex7 := position, tokenIndex
					if !_rules[ruleDirective]() {
						goto l7
					}
					if !_rules[rule_]() {
						goto l7
					}
					goto l6
				l7:
					position, tokenIndex = position7, tokenIndex7
				}
			l8:
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[rule_]() {
						goto l9
					}
					if !_rules[ruleDeclaration]() {
						goto l9
					}
					goto l8
				l9:
					position, tokenIndex = position9, tokenIndex9
				}
			l10:
				{
					position11, tokenIndex11 := position, tokenIndex
					if !_rules[rule_]() {
						goto l11
					}
					if !_rules[ruleAnnotatedFunc]() {
						goto l11
					}
					goto l10
				l11:
					position, tokenIndex = position11, tokenIndex11
				}
				if !_rules[rule_]() {
					goto l4
				}
				if !_rules[ruleEOF]() {
					goto l4
				}
				add(ruleDAppRoot, position5)
			}
			return true
		l4:
			position, tokenIndex = position4, tokenIndex4
			return false
		},
		/* 2 ScriptRoot <- <(_ (Directive _)* (_ Declaration)* _ BlockDecExprSep? _ Expr _ EOF)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[rule_]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleDirective]() {
						goto l15
					}
					if !_rules[rule_]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
			l16:
				{
					position17, tokenIndex17 := position, tokenIndex
					if !_rules[rule_]() {
						goto l17
					}
					if !_rules[ruleDeclaration]() {
						goto l17
					}
					goto l16
				l17:
					position, tokenIndex = position17, tokenIndex17
				}
				if !_rules[rule_]() {
					goto l12
				}
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleBlockDecExprSep]() {
						goto l18
					}
					goto l19
				l18:
					position, tokenIndex = position18, tokenIndex18
				}
			l19:
				if !_rules[rule_]() {
					goto l12
				}
				if !_rules[ruleExpr]() {
					goto l12
				}
				if !_rules[rule_]() {
					goto l12
				}
				if !_rules[ruleEOF]() {
					goto l12
				}
				add(ruleScriptRoot, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 WS <- <(' ' / '\t')+> */
		func() bool {
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				{
					position24, tokenIndex24 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l25
					}
					position++
					goto l24
				l25:
					position, tokenIndex = position24, tokenIndex24
					if buffer[position] != rune('\t') {
						goto l20
					}
					position++
				}
			l24:
			l22:
				{
					position23, tokenIndex23 := position, tokenIndex
					{
						position26, tokenIndex26 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l27
						}
						position++
						goto l26
					l27:
						position, tokenIndex = position26, tokenIndex26
						if buffer[position] != rune('\t') {
							goto l23
						}
						position++
					}
				l26:
					goto l22
				l23:
					position, tokenIndex = position23, tokenIndex23
				}
				add(ruleWS, position21)
			}
			return true
		l20:
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 4 NewLine <- <(' ' / '\t' / '\n' / '\r' / '\f')+> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position32, tokenIndex32 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l33
					}
					position++
					goto l32
				l33:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\t') {
						goto l34
					}
					position++
					goto l32
				l34:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
					goto l32
				l35:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\r') {
						goto l36
					}
					position++
					goto l32
				l36:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('\f') {
						goto l28
					}
					position++
				}
			l32:
			l30:
				{
					position31, tokenIndex31 := position, tokenIndex
					{
						position37, tokenIndex37 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l38
						}
						position++
						goto l37
					l38:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\t') {
							goto l39
						}
						position++
						goto l37
					l39:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\n') {
							goto l40
						}
						position++
						goto l37
					l40:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\r') {
							goto l41
						}
						position++
						goto l37
					l41:
						position, tokenIndex = position37, tokenIndex37
						if buffer[position] != rune('\f') {
							goto l31
						}
						position++
					}
				l37:
					goto l30
				l31:
					position, tokenIndex = position31, tokenIndex31
				}
				add(ruleNewLine, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 5 Comment <- <('#' (!('\r' / '^' / '\n') .)*)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				if buffer[position] != rune('#') {
					goto l42
				}
				position++
			l44:
				{
					position45, tokenIndex45 := position, tokenIndex
					{
						position46, tokenIndex46 := position, tokenIndex
						{
							position47, tokenIndex47 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l48
							}
							position++
							goto l47
						l48:
							position, tokenIndex = position47, tokenIndex47
							if buffer[position] != rune('^') {
								goto l49
							}
							position++
							goto l47
						l49:
							position, tokenIndex = position47, tokenIndex47
							if buffer[position] != rune('\n') {
								goto l46
							}
							position++
						}
					l47:
						goto l45
					l46:
						position, tokenIndex = position46, tokenIndex46
					}
					if !matchDot() {
						goto l45
					}
					goto l44
				l45:
					position, tokenIndex = position45, tokenIndex45
				}
				add(ruleComment, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 6 WhiteSpace <- <(Comment / NewLine)*> */
		func() bool {
			{
				position51 := position
			l52:
				{
					position53, tokenIndex53 := position, tokenIndex
					{
						position54, tokenIndex54 := position, tokenIndex
						if !_rules[ruleComment]() {
							goto l55
						}
						goto l54
					l55:
						position, tokenIndex = position54, tokenIndex54
						if !_rules[ruleNewLine]() {
							goto l53
						}
					}
				l54:
					goto l52
				l53:
					position, tokenIndex = position53, tokenIndex53
				}
				add(ruleWhiteSpace, position51)
			}
			return true
		},
		/* 7 _ <- <WhiteSpace> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleWhiteSpace]() {
					goto l56
				}
				add(rule_, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 8 EOF <- <!.> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				{
					position60, tokenIndex60 := position, tokenIndex
					if !matchDot() {
						goto l60
					}
					goto l58
				l60:
					position, tokenIndex = position60, tokenIndex60
				}
				add(ruleEOF, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 9 DirectiveName <- <([A-Z]+ ('_' / [A-Z])*)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l61
				}
				position++
			l63:
				{
					position64, tokenIndex64 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l64
					}
					position++
					goto l63
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
			l65:
				{
					position66, tokenIndex66 := position, tokenIndex
					{
						position67, tokenIndex67 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l68
						}
						position++
						goto l67
					l68:
						position, tokenIndex = position67, tokenIndex67
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l66
						}
						position++
					}
				l67:
					goto l65
				l66:
					position, tokenIndex = position66, tokenIndex66
				}
				add(ruleDirectiveName, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 10 UpperCaseString <- <[A-Z]+> */
		func() bool {
			position69, tokenIndex69 := position, tokenIndex
			{
				position70 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l69
				}
				position++
			l71:
				{
					position72, tokenIndex72 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l72
					}
					position++
					goto l71
				l72:
					position, tokenIndex = position72, tokenIndex72
				}
				add(ruleUpperCaseString, position70)
			}
			return true
		l69:
			position, tokenIndex = position69, tokenIndex69
			return false
		},
		/* 11 IntString <- <[0-9]+> */
		func() bool {
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l73
				}
				position++
			l75:
				{
					position76, tokenIndex76 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l76
					}
					position++
					goto l75
				l76:
					position, tokenIndex = position76, tokenIndex76
				}
				add(ruleIntString, position74)
			}
			return true
		l73:
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 12 PathString <- <('_' / [a-z] / [A-Z] / [0-9] / '-' / '/' / ',' / '.')+> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					if buffer[position] != rune('_') {
						goto l82
					}
					position++
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l83
					}
					position++
					goto l81
				l83:
					position, tokenIndex = position81, tokenIndex81
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l84
					}
					position++
					goto l81
				l84:
					position, tokenIndex = position81, tokenIndex81
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l85
					}
					position++
					goto l81
				l85:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('-') {
						goto l86
					}
					position++
					goto l81
				l86:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('/') {
						goto l87
					}
					position++
					goto l81
				l87:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune(',') {
						goto l88
					}
					position++
					goto l81
				l88:
					position, tokenIndex = position81, tokenIndex81
					if buffer[position] != rune('.') {
						goto l77
					}
					position++
				}
			l81:
			l79:
				{
					position80, tokenIndex80 := position, tokenIndex
					{
						position89, tokenIndex89 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l90
						}
						position++
						goto l89
					l90:
						position, tokenIndex = position89, tokenIndex89
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l91
						}
						position++
						goto l89
					l91:
						position, tokenIndex = position89, tokenIndex89
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l92
						}
						position++
						goto l89
					l92:
						position, tokenIndex = position89, tokenIndex89
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l93
						}
						position++
						goto l89
					l93:
						position, tokenIndex = position89, tokenIndex89
						if buffer[position] != rune('-') {
							goto l94
						}
						position++
						goto l89
					l94:
						position, tokenIndex = position89, tokenIndex89
						if buffer[position] != rune('/') {
							goto l95
						}
						position++
						goto l89
					l95:
						position, tokenIndex = position89, tokenIndex89
						if buffer[position] != rune(',') {
							goto l96
						}
						position++
						goto l89
					l96:
						position, tokenIndex = position89, tokenIndex89
						if buffer[position] != rune('.') {
							goto l80
						}
						position++
					}
				l89:
					goto l79
				l80:
					position, tokenIndex = position80, tokenIndex80
				}
				add(rulePathString, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 13 Directive <- <('{' '-' '#' WS DirectiveName WS (IntString / UpperCaseString / PathString) WS ('#' '-' '}'))> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				if buffer[position] != rune('{') {
					goto l97
				}
				position++
				if buffer[position] != rune('-') {
					goto l97
				}
				position++
				if buffer[position] != rune('#') {
					goto l97
				}
				position++
				if !_rules[ruleWS]() {
					goto l97
				}
				if !_rules[ruleDirectiveName]() {
					goto l97
				}
				if !_rules[ruleWS]() {
					goto l97
				}
				{
					position99, tokenIndex99 := position, tokenIndex
					if !_rules[ruleIntString]() {
						goto l100
					}
					goto l99
				l100:
					position, tokenIndex = position99, tokenIndex99
					if !_rules[ruleUpperCaseString]() {
						goto l101
					}
					goto l99
				l101:
					position, tokenIndex = position99, tokenIndex99
					if !_rules[rulePathString]() {
						goto l97
					}
				}
			l99:
				if !_rules[ruleWS]() {
					goto l97
				}
				if buffer[position] != rune('#') {
					goto l97
				}
				position++
				if buffer[position] != rune('-') {
					goto l97
				}
				position++
				if buffer[position] != rune('}') {
					goto l97
				}
				position++
				add(ruleDirective, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 14 Declaration <- <(Variable / Func)> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[ruleVariable]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleFunc]() {
						goto l102
					}
				}
			l104:
				add(ruleDeclaration, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 15 Variable <- <(('l' / 'L') ('e' / 'E') ('t' / 'T') _ IdentifierAtom _ '=' _ Expr)> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				{
					position108, tokenIndex108 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l109
					}
					position++
					goto l108
				l109:
					position, tokenIndex = position108, tokenIndex108
					if buffer[position] != rune('L') {
						goto l106
					}
					position++
				}
			l108:
				{
					position110, tokenIndex110 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l111
					}
					position++
					goto l110
				l111:
					position, tokenIndex = position110, tokenIndex110
					if buffer[position] != rune('E') {
						goto l106
					}
					position++
				}
			l110:
				{
					position112, tokenIndex112 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l113
					}
					position++
					goto l112
				l113:
					position, tokenIndex = position112, tokenIndex112
					if buffer[position] != rune('T') {
						goto l106
					}
					position++
				}
			l112:
				if !_rules[rule_]() {
					goto l106
				}
				if !_rules[ruleIdentifierAtom]() {
					goto l106
				}
				if !_rules[rule_]() {
					goto l106
				}
				if buffer[position] != rune('=') {
					goto l106
				}
				position++
				if !_rules[rule_]() {
					goto l106
				}
				if !_rules[ruleExpr]() {
					goto l106
				}
				add(ruleVariable, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 16 Func <- <(('f' / 'F') ('u' / 'U') ('n' / 'N') ('c' / 'C') _ IdentifierAtom _ '(' _ FuncArgSeq? _ ')' _ '=' _ Expr)> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				{
					position116, tokenIndex116 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l117
					}
					position++
					goto l116
				l117:
					position, tokenIndex = position116, tokenIndex116
					if buffer[position] != rune('F') {
						goto l114
					}
					position++
				}
			l116:
				{
					position118, tokenIndex118 := position, tokenIndex
					if buffer[position] != rune('u') {
						goto l119
					}
					position++
					goto l118
				l119:
					position, tokenIndex = position118, tokenIndex118
					if buffer[position] != rune('U') {
						goto l114
					}
					position++
				}
			l118:
				{
					position120, tokenIndex120 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l121
					}
					position++
					goto l120
				l121:
					position, tokenIndex = position120, tokenIndex120
					if buffer[position] != rune('N') {
						goto l114
					}
					position++
				}
			l120:
				{
					position122, tokenIndex122 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l123
					}
					position++
					goto l122
				l123:
					position, tokenIndex = position122, tokenIndex122
					if buffer[position] != rune('C') {
						goto l114
					}
					position++
				}
			l122:
				if !_rules[rule_]() {
					goto l114
				}
				if !_rules[ruleIdentifierAtom]() {
					goto l114
				}
				if !_rules[rule_]() {
					goto l114
				}
				if buffer[position] != rune('(') {
					goto l114
				}
				position++
				if !_rules[rule_]() {
					goto l114
				}
				{
					position124, tokenIndex124 := position, tokenIndex
					if !_rules[ruleFuncArgSeq]() {
						goto l124
					}
					goto l125
				l124:
					position, tokenIndex = position124, tokenIndex124
				}
			l125:
				if !_rules[rule_]() {
					goto l114
				}
				if buffer[position] != rune(')') {
					goto l114
				}
				position++
				if !_rules[rule_]() {
					goto l114
				}
				if buffer[position] != rune('=') {
					goto l114
				}
				position++
				if !_rules[rule_]() {
					goto l114
				}
				if !_rules[ruleExpr]() {
					goto l114
				}
				add(ruleFunc, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 17 FuncArg <- <(IdentifierAtom _ ':' _ GenericTypesAtom)> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l126
				}
				if !_rules[rule_]() {
					goto l126
				}
				if buffer[position] != rune(':') {
					goto l126
				}
				position++
				if !_rules[rule_]() {
					goto l126
				}
				if !_rules[ruleGenericTypesAtom]() {
					goto l126
				}
				add(ruleFuncArg, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 18 FuncArgSeq <- <(FuncArg ((_ ',' _ FuncArgSeq) / FuncArg)?)> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if !_rules[ruleFuncArg]() {
					goto l128
				}
				{
					position130, tokenIndex130 := position, tokenIndex
					{
						position132, tokenIndex132 := position, tokenIndex
						if !_rules[rule_]() {
							goto l133
						}
						if buffer[position] != rune(',') {
							goto l133
						}
						position++
						if !_rules[rule_]() {
							goto l133
						}
						if !_rules[ruleFuncArgSeq]() {
							goto l133
						}
						goto l132
					l133:
						position, tokenIndex = position132, tokenIndex132
						if !_rules[ruleFuncArg]() {
							goto l130
						}
					}
				l132:
					goto l131
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
			l131:
				add(ruleFuncArgSeq, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 19 AnnotatedFunc <- <(AnnotationSeq _ Func)> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if !_rules[ruleAnnotationSeq]() {
					goto l134
				}
				if !_rules[rule_]() {
					goto l134
				}
				if !_rules[ruleFunc]() {
					goto l134
				}
				add(ruleAnnotatedFunc, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 20 Annotation <- <('@' IdentifierAtom _ '(' _ IdentifierAtomSeq _ ')')> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if buffer[position] != rune('@') {
					goto l136
				}
				position++
				if !_rules[ruleIdentifierAtom]() {
					goto l136
				}
				if !_rules[rule_]() {
					goto l136
				}
				if buffer[position] != rune('(') {
					goto l136
				}
				position++
				if !_rules[rule_]() {
					goto l136
				}
				if !_rules[ruleIdentifierAtomSeq]() {
					goto l136
				}
				if !_rules[rule_]() {
					goto l136
				}
				if buffer[position] != rune(')') {
					goto l136
				}
				position++
				add(ruleAnnotation, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 21 IdentifierAtomSeq <- <(IdentifierAtom ((_ ',' _ IdentifierAtomSeq) / IdentifierAtom)?)> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l138
				}
				{
					position140, tokenIndex140 := position, tokenIndex
					{
						position142, tokenIndex142 := position, tokenIndex
						if !_rules[rule_]() {
							goto l143
						}
						if buffer[position] != rune(',') {
							goto l143
						}
						position++
						if !_rules[rule_]() {
							goto l143
						}
						if !_rules[ruleIdentifierAtomSeq]() {
							goto l143
						}
						goto l142
					l143:
						position, tokenIndex = position142, tokenIndex142
						if !_rules[ruleIdentifierAtom]() {
							goto l140
						}
					}
				l142:
					goto l141
				l140:
					position, tokenIndex = position140, tokenIndex140
				}
			l141:
				add(ruleIdentifierAtomSeq, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 22 AnnotationSeq <- <(Annotation ((_ AnnotationSeq) / Annotation)?)> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if !_rules[ruleAnnotation]() {
					goto l144
				}
				{
					position146, tokenIndex146 := position, tokenIndex
					{
						position148, tokenIndex148 := position, tokenIndex
						if !_rules[rule_]() {
							goto l149
						}
						if !_rules[ruleAnnotationSeq]() {
							goto l149
						}
						goto l148
					l149:
						position, tokenIndex = position148, tokenIndex148
						if !_rules[ruleAnnotation]() {
							goto l146
						}
					}
				l148:
					goto l147
				l146:
					position, tokenIndex = position146, tokenIndex146
				}
			l147:
				add(ruleAnnotationSeq, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 23 OrOp <- <('|' '|')> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				if buffer[position] != rune('|') {
					goto l150
				}
				position++
				if buffer[position] != rune('|') {
					goto l150
				}
				position++
				add(ruleOrOp, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 24 AndOp <- <('&' '&')> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				if buffer[position] != rune('&') {
					goto l152
				}
				position++
				if buffer[position] != rune('&') {
					goto l152
				}
				position++
				add(ruleAndOp, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 25 EqGroupOp <- <(EqOp / NeOp)> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				{
					position156, tokenIndex156 := position, tokenIndex
					if !_rules[ruleEqOp]() {
						goto l157
					}
					goto l156
				l157:
					position, tokenIndex = position156, tokenIndex156
					if !_rules[ruleNeOp]() {
						goto l154
					}
				}
			l156:
				add(ruleEqGroupOp, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
		/* 26 EqOp <- <('=' '=')> */
		func() bool {
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				if buffer[position] != rune('=') {
					goto l158
				}
				position++
				if buffer[position] != rune('=') {
					goto l158
				}
				position++
				add(ruleEqOp, position159)
			}
			return true
		l158:
			position, tokenIndex = position158, tokenIndex158
			return false
		},
		/* 27 NeOp <- <('!' '=')> */
		func() bool {
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				if buffer[position] != rune('!') {
					goto l160
				}
				position++
				if buffer[position] != rune('=') {
					goto l160
				}
				position++
				add(ruleNeOp, position161)
			}
			return true
		l160:
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 28 CompareGroupOp <- <(GtOp / GeOp / LtOp / LeOp)> */
		func() bool {
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					position164, tokenIndex164 := position, tokenIndex
					if !_rules[ruleGtOp]() {
						goto l165
					}
					goto l164
				l165:
					position, tokenIndex = position164, tokenIndex164
					if !_rules[ruleGeOp]() {
						goto l166
					}
					goto l164
				l166:
					position, tokenIndex = position164, tokenIndex164
					if !_rules[ruleLtOp]() {
						goto l167
					}
					goto l164
				l167:
					position, tokenIndex = position164, tokenIndex164
					if !_rules[ruleLeOp]() {
						goto l162
					}
				}
			l164:
				add(ruleCompareGroupOp, position163)
			}
			return true
		l162:
			position, tokenIndex = position162, tokenIndex162
			return false
		},
		/* 29 GtOp <- <('>' !'=')> */
		func() bool {
			position168, tokenIndex168 := position, tokenIndex
			{
				position169 := position
				if buffer[position] != rune('>') {
					goto l168
				}
				position++
				{
					position170, tokenIndex170 := position, tokenIndex
					if buffer[position] != rune('=') {
						goto l170
					}
					position++
					goto l168
				l170:
					position, tokenIndex = position170, tokenIndex170
				}
				add(ruleGtOp, position169)
			}
			return true
		l168:
			position, tokenIndex = position168, tokenIndex168
			return false
		},
		/* 30 GeOp <- <('>' '=')> */
		func() bool {
			position171, tokenIndex171 := position, tokenIndex
			{
				position172 := position
				if buffer[position] != rune('>') {
					goto l171
				}
				position++
				if buffer[position] != rune('=') {
					goto l171
				}
				position++
				add(ruleGeOp, position172)
			}
			return true
		l171:
			position, tokenIndex = position171, tokenIndex171
			return false
		},
		/* 31 LtOp <- <('<' !'=')> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('<') {
					goto l173
				}
				position++
				{
					position175, tokenIndex175 := position, tokenIndex
					if buffer[position] != rune('=') {
						goto l175
					}
					position++
					goto l173
				l175:
					position, tokenIndex = position175, tokenIndex175
				}
				add(ruleLtOp, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 32 LeOp <- <('<' '=')> */
		func() bool {
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				if buffer[position] != rune('<') {
					goto l176
				}
				position++
				if buffer[position] != rune('=') {
					goto l176
				}
				position++
				add(ruleLeOp, position177)
			}
			return true
		l176:
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 33 ConsOp <- <(':' ':')> */
		func() bool {
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				if buffer[position] != rune(':') {
					goto l178
				}
				position++
				if buffer[position] != rune(':') {
					goto l178
				}
				position++
				add(ruleConsOp, position179)
			}
			return true
		l178:
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 34 SumGroupOp <- <(SumOp / SubOp)> */
		func() bool {
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				{
					position182, tokenIndex182 := position, tokenIndex
					if !_rules[ruleSumOp]() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					if !_rules[ruleSubOp]() {
						goto l180
					}
				}
			l182:
				add(ruleSumGroupOp, position181)
			}
			return true
		l180:
			position, tokenIndex = position180, tokenIndex180
			return false
		},
		/* 35 SumOp <- <'+'> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				if buffer[position] != rune('+') {
					goto l184
				}
				position++
				add(ruleSumOp, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 36 SubOp <- <'-'> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				if buffer[position] != rune('-') {
					goto l186
				}
				position++
				add(ruleSubOp, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 37 MultGroupOp <- <(MulOp / DivOp / ModOp)> */
		func() bool {
			position188, tokenIndex188 := position, tokenIndex
			{
				position189 := position
				{
					position190, tokenIndex190 := position, tokenIndex
					if !_rules[ruleMulOp]() {
						goto l191
					}
					goto l190
				l191:
					position, tokenIndex = position190, tokenIndex190
					if !_rules[ruleDivOp]() {
						goto l192
					}
					goto l190
				l192:
					position, tokenIndex = position190, tokenIndex190
					if !_rules[ruleModOp]() {
						goto l188
					}
				}
			l190:
				add(ruleMultGroupOp, position189)
			}
			return true
		l188:
			position, tokenIndex = position188, tokenIndex188
			return false
		},
		/* 38 MulOp <- <'*'> */
		func() bool {
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				if buffer[position] != rune('*') {
					goto l193
				}
				position++
				add(ruleMulOp, position194)
			}
			return true
		l193:
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 39 DivOp <- <'/'> */
		func() bool {
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				if buffer[position] != rune('/') {
					goto l195
				}
				position++
				add(ruleDivOp, position196)
			}
			return true
		l195:
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 40 ModOp <- <'%'> */
		func() bool {
			position197, tokenIndex197 := position, tokenIndex
			{
				position198 := position
				if buffer[position] != rune('%') {
					goto l197
				}
				position++
				add(ruleModOp, position198)
			}
			return true
		l197:
			position, tokenIndex = position197, tokenIndex197
			return false
		},
		/* 41 UnaryOp <- <(PositiveOp / NegativeOp / NotOp)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[rulePositiveOp]() {
						goto l202
					}
					goto l201
				l202:
					position, tokenIndex = position201, tokenIndex201
					if !_rules[ruleNegativeOp]() {
						goto l203
					}
					goto l201
				l203:
					position, tokenIndex = position201, tokenIndex201
					if !_rules[ruleNotOp]() {
						goto l199
					}
				}
			l201:
				add(ruleUnaryOp, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 42 PositiveOp <- <'+'> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				if buffer[position] != rune('+') {
					goto l204
				}
				position++
				add(rulePositiveOp, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 43 NegativeOp <- <('-' !'#')> */
		func() bool {
			position206, tokenIndex206 := position, tokenIndex
			{
				position207 := position
				if buffer[position] != rune('-') {
					goto l206
				}
				position++
				{
					position208, tokenIndex208 := position, tokenIndex
					if buffer[position] != rune('#') {
						goto l208
					}
					position++
					goto l206
				l208:
					position, tokenIndex = position208, tokenIndex208
				}
				add(ruleNegativeOp, position207)
			}
			return true
		l206:
			position, tokenIndex = position206, tokenIndex206
			return false
		},
		/* 44 NotOp <- <'!'> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if buffer[position] != rune('!') {
					goto l209
				}
				position++
				add(ruleNotOp, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 45 ReservedWords <- <((('l' / 'L') ('e' / 'E') ('t' / 'T')) / (('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') '1' '6') / (('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') '5' '8') / (('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') '6' '4') / (('t' / 'T') ('r' / 'R') ('u' / 'U') ('e' / 'E')) / (('f' / 'F') ('a' / 'A') ('l' / 'L') ('s' / 'S') ('e' / 'E')) / (('i' / 'I') ('f' / 'F')) / (('t' / 'T') ('h' / 'H') ('e' / 'E') ('n' / 'N')) / (('e' / 'E') ('l' / 'L') ('s' / 'S') ('e' / 'E')) / (('m' / 'M') ('a' / 'A') ('t' / 'T') ('c' / 'C') ('h' / 'H')) / (('c' / 'C') ('a' / 'A') ('s' / 'S') ('e' / 'E')) / (('f' / 'F') ('u' / 'U') ('n' / 'N') ('c' / 'C')))> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				{
					position213, tokenIndex213 := position, tokenIndex
					{
						position215, tokenIndex215 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l216
						}
						position++
						goto l215
					l216:
						position, tokenIndex = position215, tokenIndex215
						if buffer[position] != rune('L') {
							goto l214
						}
						position++
					}
				l215:
					{
						position217, tokenIndex217 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l218
						}
						position++
						goto l217
					l218:
						position, tokenIndex = position217, tokenIndex217
						if buffer[position] != rune('E') {
							goto l214
						}
						position++
					}
				l217:
					{
						position219, tokenIndex219 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l220
						}
						position++
						goto l219
					l220:
						position, tokenIndex = position219, tokenIndex219
						if buffer[position] != rune('T') {
							goto l214
						}
						position++
					}
				l219:
					goto l213
				l214:
					position, tokenIndex = position213, tokenIndex213
					{
						position222, tokenIndex222 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l223
						}
						position++
						goto l222
					l223:
						position, tokenIndex = position222, tokenIndex222
						if buffer[position] != rune('B') {
							goto l221
						}
						position++
					}
				l222:
					{
						position224, tokenIndex224 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l225
						}
						position++
						goto l224
					l225:
						position, tokenIndex = position224, tokenIndex224
						if buffer[position] != rune('A') {
							goto l221
						}
						position++
					}
				l224:
					{
						position226, tokenIndex226 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l227
						}
						position++
						goto l226
					l227:
						position, tokenIndex = position226, tokenIndex226
						if buffer[position] != rune('S') {
							goto l221
						}
						position++
					}
				l226:
					{
						position228, tokenIndex228 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l229
						}
						position++
						goto l228
					l229:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('E') {
							goto l221
						}
						position++
					}
				l228:
					if buffer[position] != rune('1') {
						goto l221
					}
					position++
					if buffer[position] != rune('6') {
						goto l221
					}
					position++
					goto l213
				l221:
					position, tokenIndex = position213, tokenIndex213
					{
						position231, tokenIndex231 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l232
						}
						position++
						goto l231
					l232:
						position, tokenIndex = position231, tokenIndex231
						if buffer[position] != rune('B') {
							goto l230
						}
						position++
					}
				l231:
					{
						position233, tokenIndex233 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l234
						}
						position++
						goto l233
					l234:
						position, tokenIndex = position233, tokenIndex233
						if buffer[position] != rune('A') {
							goto l230
						}
						position++
					}
				l233:
					{
						position235, tokenIndex235 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l236
						}
						position++
						goto l235
					l236:
						position, tokenIndex = position235, tokenIndex235
						if buffer[position] != rune('S') {
							goto l230
						}
						position++
					}
				l235:
					{
						position237, tokenIndex237 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l238
						}
						position++
						goto l237
					l238:
						position, tokenIndex = position237, tokenIndex237
						if buffer[position] != rune('E') {
							goto l230
						}
						position++
					}
				l237:
					if buffer[position] != rune('5') {
						goto l230
					}
					position++
					if buffer[position] != rune('8') {
						goto l230
					}
					position++
					goto l213
				l230:
					position, tokenIndex = position213, tokenIndex213
					{
						position240, tokenIndex240 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l241
						}
						position++
						goto l240
					l241:
						position, tokenIndex = position240, tokenIndex240
						if buffer[position] != rune('B') {
							goto l239
						}
						position++
					}
				l240:
					{
						position242, tokenIndex242 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l243
						}
						position++
						goto l242
					l243:
						position, tokenIndex = position242, tokenIndex242
						if buffer[position] != rune('A') {
							goto l239
						}
						position++
					}
				l242:
					{
						position244, tokenIndex244 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l245
						}
						position++
						goto l244
					l245:
						position, tokenIndex = position244, tokenIndex244
						if buffer[position] != rune('S') {
							goto l239
						}
						position++
					}
				l244:
					{
						position246, tokenIndex246 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l247
						}
						position++
						goto l246
					l247:
						position, tokenIndex = position246, tokenIndex246
						if buffer[position] != rune('E') {
							goto l239
						}
						position++
					}
				l246:
					if buffer[position] != rune('6') {
						goto l239
					}
					position++
					if buffer[position] != rune('4') {
						goto l239
					}
					position++
					goto l213
				l239:
					position, tokenIndex = position213, tokenIndex213
					{
						position249, tokenIndex249 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l250
						}
						position++
						goto l249
					l250:
						position, tokenIndex = position249, tokenIndex249
						if buffer[position] != rune('T') {
							goto l248
						}
						position++
					}
				l249:
					{
						position251, tokenIndex251 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l252
						}
						position++
						goto l251
					l252:
						position, tokenIndex = position251, tokenIndex251
						if buffer[position] != rune('R') {
							goto l248
						}
						position++
					}
				l251:
					{
						position253, tokenIndex253 := position, tokenIndex
						if buffer[position] != rune('u') {
							goto l254
						}
						position++
						goto l253
					l254:
						position, tokenIndex = position253, tokenIndex253
						if buffer[position] != rune('U') {
							goto l248
						}
						position++
					}
				l253:
					{
						position255, tokenIndex255 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l256
						}
						position++
						goto l255
					l256:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('E') {
							goto l248
						}
						position++
					}
				l255:
					goto l213
				l248:
					position, tokenIndex = position213, tokenIndex213
					{
						position258, tokenIndex258 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l259
						}
						position++
						goto l258
					l259:
						position, tokenIndex = position258, tokenIndex258
						if buffer[position] != rune('F') {
							goto l257
						}
						position++
					}
				l258:
					{
						position260, tokenIndex260 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l261
						}
						position++
						goto l260
					l261:
						position, tokenIndex = position260, tokenIndex260
						if buffer[position] != rune('A') {
							goto l257
						}
						position++
					}
				l260:
					{
						position262, tokenIndex262 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l263
						}
						position++
						goto l262
					l263:
						position, tokenIndex = position262, tokenIndex262
						if buffer[position] != rune('L') {
							goto l257
						}
						position++
					}
				l262:
					{
						position264, tokenIndex264 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l265
						}
						position++
						goto l264
					l265:
						position, tokenIndex = position264, tokenIndex264
						if buffer[position] != rune('S') {
							goto l257
						}
						position++
					}
				l264:
					{
						position266, tokenIndex266 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l267
						}
						position++
						goto l266
					l267:
						position, tokenIndex = position266, tokenIndex266
						if buffer[position] != rune('E') {
							goto l257
						}
						position++
					}
				l266:
					goto l213
				l257:
					position, tokenIndex = position213, tokenIndex213
					{
						position269, tokenIndex269 := position, tokenIndex
						if buffer[position] != rune('i') {
							goto l270
						}
						position++
						goto l269
					l270:
						position, tokenIndex = position269, tokenIndex269
						if buffer[position] != rune('I') {
							goto l268
						}
						position++
					}
				l269:
					{
						position271, tokenIndex271 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l272
						}
						position++
						goto l271
					l272:
						position, tokenIndex = position271, tokenIndex271
						if buffer[position] != rune('F') {
							goto l268
						}
						position++
					}
				l271:
					goto l213
				l268:
					position, tokenIndex = position213, tokenIndex213
					{
						position274, tokenIndex274 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l275
						}
						position++
						goto l274
					l275:
						position, tokenIndex = position274, tokenIndex274
						if buffer[position] != rune('T') {
							goto l273
						}
						position++
					}
				l274:
					{
						position276, tokenIndex276 := position, tokenIndex
						if buffer[position] != rune('h') {
							goto l277
						}
						position++
						goto l276
					l277:
						position, tokenIndex = position276, tokenIndex276
						if buffer[position] != rune('H') {
							goto l273
						}
						position++
					}
				l276:
					{
						position278, tokenIndex278 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l279
						}
						position++
						goto l278
					l279:
						position, tokenIndex = position278, tokenIndex278
						if buffer[position] != rune('E') {
							goto l273
						}
						position++
					}
				l278:
					{
						position280, tokenIndex280 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l281
						}
						position++
						goto l280
					l281:
						position, tokenIndex = position280, tokenIndex280
						if buffer[position] != rune('N') {
							goto l273
						}
						position++
					}
				l280:
					goto l213
				l273:
					position, tokenIndex = position213, tokenIndex213
					{
						position283, tokenIndex283 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l284
						}
						position++
						goto l283
					l284:
						position, tokenIndex = position283, tokenIndex283
						if buffer[position] != rune('E') {
							goto l282
						}
						position++
					}
				l283:
					{
						position285, tokenIndex285 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l286
						}
						position++
						goto l285
					l286:
						position, tokenIndex = position285, tokenIndex285
						if buffer[position] != rune('L') {
							goto l282
						}
						position++
					}
				l285:
					{
						position287, tokenIndex287 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l288
						}
						position++
						goto l287
					l288:
						position, tokenIndex = position287, tokenIndex287
						if buffer[position] != rune('S') {
							goto l282
						}
						position++
					}
				l287:
					{
						position289, tokenIndex289 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l290
						}
						position++
						goto l289
					l290:
						position, tokenIndex = position289, tokenIndex289
						if buffer[position] != rune('E') {
							goto l282
						}
						position++
					}
				l289:
					goto l213
				l282:
					position, tokenIndex = position213, tokenIndex213
					{
						position292, tokenIndex292 := position, tokenIndex
						if buffer[position] != rune('m') {
							goto l293
						}
						position++
						goto l292
					l293:
						position, tokenIndex = position292, tokenIndex292
						if buffer[position] != rune('M') {
							goto l291
						}
						position++
					}
				l292:
					{
						position294, tokenIndex294 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l295
						}
						position++
						goto l294
					l295:
						position, tokenIndex = position294, tokenIndex294
						if buffer[position] != rune('A') {
							goto l291
						}
						position++
					}
				l294:
					{
						position296, tokenIndex296 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l297
						}
						position++
						goto l296
					l297:
						position, tokenIndex = position296, tokenIndex296
						if buffer[position] != rune('T') {
							goto l291
						}
						position++
					}
				l296:
					{
						position298, tokenIndex298 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l299
						}
						position++
						goto l298
					l299:
						position, tokenIndex = position298, tokenIndex298
						if buffer[position] != rune('C') {
							goto l291
						}
						position++
					}
				l298:
					{
						position300, tokenIndex300 := position, tokenIndex
						if buffer[position] != rune('h') {
							goto l301
						}
						position++
						goto l300
					l301:
						position, tokenIndex = position300, tokenIndex300
						if buffer[position] != rune('H') {
							goto l291
						}
						position++
					}
				l300:
					goto l213
				l291:
					position, tokenIndex = position213, tokenIndex213
					{
						position303, tokenIndex303 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l304
						}
						position++
						goto l303
					l304:
						position, tokenIndex = position303, tokenIndex303
						if buffer[position] != rune('C') {
							goto l302
						}
						position++
					}
				l303:
					{
						position305, tokenIndex305 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l306
						}
						position++
						goto l305
					l306:
						position, tokenIndex = position305, tokenIndex305
						if buffer[position] != rune('A') {
							goto l302
						}
						position++
					}
				l305:
					{
						position307, tokenIndex307 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l308
						}
						position++
						goto l307
					l308:
						position, tokenIndex = position307, tokenIndex307
						if buffer[position] != rune('S') {
							goto l302
						}
						position++
					}
				l307:
					{
						position309, tokenIndex309 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l310
						}
						position++
						goto l309
					l310:
						position, tokenIndex = position309, tokenIndex309
						if buffer[position] != rune('E') {
							goto l302
						}
						position++
					}
				l309:
					goto l213
				l302:
					position, tokenIndex = position213, tokenIndex213
					{
						position311, tokenIndex311 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l312
						}
						position++
						goto l311
					l312:
						position, tokenIndex = position311, tokenIndex311
						if buffer[position] != rune('F') {
							goto l211
						}
						position++
					}
				l311:
					{
						position313, tokenIndex313 := position, tokenIndex
						if buffer[position] != rune('u') {
							goto l314
						}
						position++
						goto l313
					l314:
						position, tokenIndex = position313, tokenIndex313
						if buffer[position] != rune('U') {
							goto l211
						}
						position++
					}
				l313:
					{
						position315, tokenIndex315 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l316
						}
						position++
						goto l315
					l316:
						position, tokenIndex = position315, tokenIndex315
						if buffer[position] != rune('N') {
							goto l211
						}
						position++
					}
				l315:
					{
						position317, tokenIndex317 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l318
						}
						position++
						goto l317
					l318:
						position, tokenIndex = position317, tokenIndex317
						if buffer[position] != rune('C') {
							goto l211
						}
						position++
					}
				l317:
				}
			l213:
				add(ruleReservedWords, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 46 ConstAtom <- <(IntegerAtom / StringAtom / ByteVectorAtom / BooleanAtom / ListAtom)> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				{
					position321, tokenIndex321 := position, tokenIndex
					if !_rules[ruleIntegerAtom]() {
						goto l322
					}
					goto l321
				l322:
					position, tokenIndex = position321, tokenIndex321
					if !_rules[ruleStringAtom]() {
						goto l323
					}
					goto l321
				l323:
					position, tokenIndex = position321, tokenIndex321
					if !_rules[ruleByteVectorAtom]() {
						goto l324
					}
					goto l321
				l324:
					position, tokenIndex = position321, tokenIndex321
					if !_rules[ruleBooleanAtom]() {
						goto l325
					}
					goto l321
				l325:
					position, tokenIndex = position321, tokenIndex321
					if !_rules[ruleListAtom]() {
						goto l319
					}
				}
			l321:
				add(ruleConstAtom, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 47 IdentifierAtom <- <((!ReservedWords Char (Char / Digit)*) / (ReservedWords (Char / Digit) (Char / Digit)*))> */
		func() bool {
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				{
					position328, tokenIndex328 := position, tokenIndex
					{
						position330, tokenIndex330 := position, tokenIndex
						if !_rules[ruleReservedWords]() {
							goto l330
						}
						goto l329
					l330:
						position, tokenIndex = position330, tokenIndex330
					}
					if !_rules[ruleChar]() {
						goto l329
					}
				l331:
					{
						position332, tokenIndex332 := position, tokenIndex
						{
							position333, tokenIndex333 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l334
							}
							goto l333
						l334:
							position, tokenIndex = position333, tokenIndex333
							if !_rules[ruleDigit]() {
								goto l332
							}
						}
					l333:
						goto l331
					l332:
						position, tokenIndex = position332, tokenIndex332
					}
					goto l328
				l329:
					position, tokenIndex = position328, tokenIndex328
					if !_rules[ruleReservedWords]() {
						goto l326
					}
					{
						position335, tokenIndex335 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l336
						}
						goto l335
					l336:
						position, tokenIndex = position335, tokenIndex335
						if !_rules[ruleDigit]() {
							goto l326
						}
					}
				l335:
				l337:
					{
						position338, tokenIndex338 := position, tokenIndex
						{
							position339, tokenIndex339 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l340
							}
							goto l339
						l340:
							position, tokenIndex = position339, tokenIndex339
							if !_rules[ruleDigit]() {
								goto l338
							}
						}
					l339:
						goto l337
					l338:
						position, tokenIndex = position338, tokenIndex338
					}
				}
			l328:
				add(ruleIdentifierAtom, position327)
			}
			return true
		l326:
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 48 ReferenceAtom <- <((!ReservedWords Char (Char / Digit)*) / (ReservedWords (Char / Digit) (Char / Digit)*))> */
		func() bool {
			position341, tokenIndex341 := position, tokenIndex
			{
				position342 := position
				{
					position343, tokenIndex343 := position, tokenIndex
					{
						position345, tokenIndex345 := position, tokenIndex
						if !_rules[ruleReservedWords]() {
							goto l345
						}
						goto l344
					l345:
						position, tokenIndex = position345, tokenIndex345
					}
					if !_rules[ruleChar]() {
						goto l344
					}
				l346:
					{
						position347, tokenIndex347 := position, tokenIndex
						{
							position348, tokenIndex348 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l349
							}
							goto l348
						l349:
							position, tokenIndex = position348, tokenIndex348
							if !_rules[ruleDigit]() {
								goto l347
							}
						}
					l348:
						goto l346
					l347:
						position, tokenIndex = position347, tokenIndex347
					}
					goto l343
				l344:
					position, tokenIndex = position343, tokenIndex343
					if !_rules[ruleReservedWords]() {
						goto l341
					}
					{
						position350, tokenIndex350 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l351
						}
						goto l350
					l351:
						position, tokenIndex = position350, tokenIndex350
						if !_rules[ruleDigit]() {
							goto l341
						}
					}
				l350:
				l352:
					{
						position353, tokenIndex353 := position, tokenIndex
						{
							position354, tokenIndex354 := position, tokenIndex
							if !_rules[ruleChar]() {
								goto l355
							}
							goto l354
						l355:
							position, tokenIndex = position354, tokenIndex354
							if !_rules[ruleDigit]() {
								goto l353
							}
						}
					l354:
						goto l352
					l353:
						position, tokenIndex = position353, tokenIndex353
					}
				}
			l343:
				add(ruleReferenceAtom, position342)
			}
			return true
		l341:
			position, tokenIndex = position341, tokenIndex341
			return false
		},
		/* 49 GenericTypesAtom <- <(OneGenericTypeAtom ((_ '|' _ GenericTypesAtom) / OneGenericTypeAtom)?)> */
		func() bool {
			position356, tokenIndex356 := position, tokenIndex
			{
				position357 := position
				if !_rules[ruleOneGenericTypeAtom]() {
					goto l356
				}
				{
					position358, tokenIndex358 := position, tokenIndex
					{
						position360, tokenIndex360 := position, tokenIndex
						if !_rules[rule_]() {
							goto l361
						}
						if buffer[position] != rune('|') {
							goto l361
						}
						position++
						if !_rules[rule_]() {
							goto l361
						}
						if !_rules[ruleGenericTypesAtom]() {
							goto l361
						}
						goto l360
					l361:
						position, tokenIndex = position360, tokenIndex360
						if !_rules[ruleOneGenericTypeAtom]() {
							goto l358
						}
					}
				l360:
					goto l359
				l358:
					position, tokenIndex = position358, tokenIndex358
				}
			l359:
				add(ruleGenericTypesAtom, position357)
			}
			return true
		l356:
			position, tokenIndex = position356, tokenIndex356
			return false
		},
		/* 50 OneGenericTypeAtom <- <(Char (Char / Digit)* (_ '[' _ OneTypeAtom _ ']' _)?)> */
		func() bool {
			position362, tokenIndex362 := position, tokenIndex
			{
				position363 := position
				if !_rules[ruleChar]() {
					goto l362
				}
			l364:
				{
					position365, tokenIndex365 := position, tokenIndex
					{
						position366, tokenIndex366 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l367
						}
						goto l366
					l367:
						position, tokenIndex = position366, tokenIndex366
						if !_rules[ruleDigit]() {
							goto l365
						}
					}
				l366:
					goto l364
				l365:
					position, tokenIndex = position365, tokenIndex365
				}
				{
					position368, tokenIndex368 := position, tokenIndex
					if !_rules[rule_]() {
						goto l368
					}
					if buffer[position] != rune('[') {
						goto l368
					}
					position++
					if !_rules[rule_]() {
						goto l368
					}
					if !_rules[ruleOneTypeAtom]() {
						goto l368
					}
					if !_rules[rule_]() {
						goto l368
					}
					if buffer[position] != rune(']') {
						goto l368
					}
					position++
					if !_rules[rule_]() {
						goto l368
					}
					goto l369
				l368:
					position, tokenIndex = position368, tokenIndex368
				}
			l369:
				add(ruleOneGenericTypeAtom, position363)
			}
			return true
		l362:
			position, tokenIndex = position362, tokenIndex362
			return false
		},
		/* 51 TypesAtom <- <(OneTypeAtom ((_ '|' _ TypesAtom) / OneTypeAtom)?)> */
		func() bool {
			position370, tokenIndex370 := position, tokenIndex
			{
				position371 := position
				if !_rules[ruleOneTypeAtom]() {
					goto l370
				}
				{
					position372, tokenIndex372 := position, tokenIndex
					{
						position374, tokenIndex374 := position, tokenIndex
						if !_rules[rule_]() {
							goto l375
						}
						if buffer[position] != rune('|') {
							goto l375
						}
						position++
						if !_rules[rule_]() {
							goto l375
						}
						if !_rules[ruleTypesAtom]() {
							goto l375
						}
						goto l374
					l375:
						position, tokenIndex = position374, tokenIndex374
						if !_rules[ruleOneTypeAtom]() {
							goto l372
						}
					}
				l374:
					goto l373
				l372:
					position, tokenIndex = position372, tokenIndex372
				}
			l373:
				add(ruleTypesAtom, position371)
			}
			return true
		l370:
			position, tokenIndex = position370, tokenIndex370
			return false
		},
		/* 52 OneTypeAtom <- <(Char (Char / Digit)*)> */
		func() bool {
			position376, tokenIndex376 := position, tokenIndex
			{
				position377 := position
				if !_rules[ruleChar]() {
					goto l376
				}
			l378:
				{
					position379, tokenIndex379 := position, tokenIndex
					{
						position380, tokenIndex380 := position, tokenIndex
						if !_rules[ruleChar]() {
							goto l381
						}
						goto l380
					l381:
						position, tokenIndex = position380, tokenIndex380
						if !_rules[ruleDigit]() {
							goto l379
						}
					}
				l380:
					goto l378
				l379:
					position, tokenIndex = position379, tokenIndex379
				}
				add(ruleOneTypeAtom, position377)
			}
			return true
		l376:
			position, tokenIndex = position376, tokenIndex376
			return false
		},
		/* 53 ByteVectorAtom <- <(('b' / 'B') ('a' / 'A') ('s' / 'S') ('e' / 'E') ByteVectorBase '\'' ByteVectorValue '\'')> */
		func() bool {
			position382, tokenIndex382 := position, tokenIndex
			{
				position383 := position
				{
					position384, tokenIndex384 := position, tokenIndex
					if buffer[position] != rune('b') {
						goto l385
					}
					position++
					goto l384
				l385:
					position, tokenIndex = position384, tokenIndex384
					if buffer[position] != rune('B') {
						goto l382
					}
					position++
				}
			l384:
				{
					position386, tokenIndex386 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l387
					}
					position++
					goto l386
				l387:
					position, tokenIndex = position386, tokenIndex386
					if buffer[position] != rune('A') {
						goto l382
					}
					position++
				}
			l386:
				{
					position388, tokenIndex388 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l389
					}
					position++
					goto l388
				l389:
					position, tokenIndex = position388, tokenIndex388
					if buffer[position] != rune('S') {
						goto l382
					}
					position++
				}
			l388:
				{
					position390, tokenIndex390 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l391
					}
					position++
					goto l390
				l391:
					position, tokenIndex = position390, tokenIndex390
					if buffer[position] != rune('E') {
						goto l382
					}
					position++
				}
			l390:
				if !_rules[ruleByteVectorBase]() {
					goto l382
				}
				if buffer[position] != rune('\'') {
					goto l382
				}
				position++
				if !_rules[ruleByteVectorValue]() {
					goto l382
				}
				if buffer[position] != rune('\'') {
					goto l382
				}
				position++
				add(ruleByteVectorAtom, position383)
			}
			return true
		l382:
			position, tokenIndex = position382, tokenIndex382
			return false
		},
		/* 54 ByteVectorBase <- <(('5' '8') / ('6' '4') / ('1' '6'))> */
		func() bool {
			position392, tokenIndex392 := position, tokenIndex
			{
				position393 := position
				{
					position394, tokenIndex394 := position, tokenIndex
					if buffer[position] != rune('5') {
						goto l395
					}
					position++
					if buffer[position] != rune('8') {
						goto l395
					}
					position++
					goto l394
				l395:
					position, tokenIndex = position394, tokenIndex394
					if buffer[position] != rune('6') {
						goto l396
					}
					position++
					if buffer[position] != rune('4') {
						goto l396
					}
					position++
					goto l394
				l396:
					position, tokenIndex = position394, tokenIndex394
					if buffer[position] != rune('1') {
						goto l392
					}
					position++
					if buffer[position] != rune('6') {
						goto l392
					}
					position++
				}
			l394:
				add(ruleByteVectorBase, position393)
			}
			return true
		l392:
			position, tokenIndex = position392, tokenIndex392
			return false
		},
		/* 55 ByteVectorValue <- <(!'\'' .)*> */
		func() bool {
			{
				position398 := position
			l399:
				{
					position400, tokenIndex400 := position, tokenIndex
					{
						position401, tokenIndex401 := position, tokenIndex
						if buffer[position] != rune('\'') {
							goto l401
						}
						position++
						goto l400
					l401:
						position, tokenIndex = position401, tokenIndex401
					}
					if !matchDot() {
						goto l400
					}
					goto l399
				l400:
					position, tokenIndex = position400, tokenIndex400
				}
				add(ruleByteVectorValue, position398)
			}
			return true
		},
		/* 56 BooleanAtom <- <((('t' / 'T') ('r' / 'R') ('u' / 'U') ('e' / 'E')) / (('f' / 'F') ('a' / 'A') ('l' / 'L') ('s' / 'S') ('e' / 'E')))> */
		func() bool {
			position402, tokenIndex402 := position, tokenIndex
			{
				position403 := position
				{
					position404, tokenIndex404 := position, tokenIndex
					{
						position406, tokenIndex406 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l407
						}
						position++
						goto l406
					l407:
						position, tokenIndex = position406, tokenIndex406
						if buffer[position] != rune('T') {
							goto l405
						}
						position++
					}
				l406:
					{
						position408, tokenIndex408 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l409
						}
						position++
						goto l408
					l409:
						position, tokenIndex = position408, tokenIndex408
						if buffer[position] != rune('R') {
							goto l405
						}
						position++
					}
				l408:
					{
						position410, tokenIndex410 := position, tokenIndex
						if buffer[position] != rune('u') {
							goto l411
						}
						position++
						goto l410
					l411:
						position, tokenIndex = position410, tokenIndex410
						if buffer[position] != rune('U') {
							goto l405
						}
						position++
					}
				l410:
					{
						position412, tokenIndex412 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l413
						}
						position++
						goto l412
					l413:
						position, tokenIndex = position412, tokenIndex412
						if buffer[position] != rune('E') {
							goto l405
						}
						position++
					}
				l412:
					goto l404
				l405:
					position, tokenIndex = position404, tokenIndex404
					{
						position414, tokenIndex414 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l415
						}
						position++
						goto l414
					l415:
						position, tokenIndex = position414, tokenIndex414
						if buffer[position] != rune('F') {
							goto l402
						}
						position++
					}
				l414:
					{
						position416, tokenIndex416 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l417
						}
						position++
						goto l416
					l417:
						position, tokenIndex = position416, tokenIndex416
						if buffer[position] != rune('A') {
							goto l402
						}
						position++
					}
				l416:
					{
						position418, tokenIndex418 := position, tokenIndex
						if buffer[position] != rune('l') {
							goto l419
						}
						position++
						goto l418
					l419:
						position, tokenIndex = position418, tokenIndex418
						if buffer[position] != rune('L') {
							goto l402
						}
						position++
					}
				l418:
					{
						position420, tokenIndex420 := position, tokenIndex
						if buffer[position] != rune('s') {
							goto l421
						}
						position++
						goto l420
					l421:
						position, tokenIndex = position420, tokenIndex420
						if buffer[position] != rune('S') {
							goto l402
						}
						position++
					}
				l420:
					{
						position422, tokenIndex422 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l423
						}
						position++
						goto l422
					l423:
						position, tokenIndex = position422, tokenIndex422
						if buffer[position] != rune('E') {
							goto l402
						}
						position++
					}
				l422:
				}
			l404:
				add(ruleBooleanAtom, position403)
			}
			return true
		l402:
			position, tokenIndex = position402, tokenIndex402
			return false
		},
		/* 57 StringAtom <- <('"' (UnicodeCharAtom / EscapedCharAtom / CharAtom)* '"')> */
		func() bool {
			position424, tokenIndex424 := position, tokenIndex
			{
				position425 := position
				if buffer[position] != rune('"') {
					goto l424
				}
				position++
			l426:
				{
					position427, tokenIndex427 := position, tokenIndex
					{
						position428, tokenIndex428 := position, tokenIndex
						if !_rules[ruleUnicodeCharAtom]() {
							goto l429
						}
						goto l428
					l429:
						position, tokenIndex = position428, tokenIndex428
						if !_rules[ruleEscapedCharAtom]() {
							goto l430
						}
						goto l428
					l430:
						position, tokenIndex = position428, tokenIndex428
						if !_rules[ruleCharAtom]() {
							goto l427
						}
					}
				l428:
					goto l426
				l427:
					position, tokenIndex = position427, tokenIndex427
				}
				if buffer[position] != rune('"') {
					goto l424
				}
				position++
				add(ruleStringAtom, position425)
			}
			return true
		l424:
			position, tokenIndex = position424, tokenIndex424
			return false
		},
		/* 58 UnicodeCharAtom <- <('\\' ('u' / 'U') HexDigit HexDigit HexDigit HexDigit)> */
		func() bool {
			position431, tokenIndex431 := position, tokenIndex
			{
				position432 := position
				if buffer[position] != rune('\\') {
					goto l431
				}
				position++
				{
					position433, tokenIndex433 := position, tokenIndex
					if buffer[position] != rune('u') {
						goto l434
					}
					position++
					goto l433
				l434:
					position, tokenIndex = position433, tokenIndex433
					if buffer[position] != rune('U') {
						goto l431
					}
					position++
				}
			l433:
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				if !_rules[ruleHexDigit]() {
					goto l431
				}
				add(ruleUnicodeCharAtom, position432)
			}
			return true
		l431:
			position, tokenIndex = position431, tokenIndex431
			return false
		},
		/* 59 HexDigit <- <(Char / Digit)> */
		func() bool {
			position435, tokenIndex435 := position, tokenIndex
			{
				position436 := position
				{
					position437, tokenIndex437 := position, tokenIndex
					if !_rules[ruleChar]() {
						goto l438
					}
					goto l437
				l438:
					position, tokenIndex = position437, tokenIndex437
					if !_rules[ruleDigit]() {
						goto l435
					}
				}
			l437:
				add(ruleHexDigit, position436)
			}
			return true
		l435:
			position, tokenIndex = position435, tokenIndex435
			return false
		},
		/* 60 EscapedCharAtom <- <('\\' .)> */
		func() bool {
			position439, tokenIndex439 := position, tokenIndex
			{
				position440 := position
				if buffer[position] != rune('\\') {
					goto l439
				}
				position++
				if !matchDot() {
					goto l439
				}
				add(ruleEscapedCharAtom, position440)
			}
			return true
		l439:
			position, tokenIndex = position439, tokenIndex439
			return false
		},
		/* 61 CharAtom <- <(!'"' .)> */
		func() bool {
			position441, tokenIndex441 := position, tokenIndex
			{
				position442 := position
				{
					position443, tokenIndex443 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l443
					}
					position++
					goto l441
				l443:
					position, tokenIndex = position443, tokenIndex443
				}
				if !matchDot() {
					goto l441
				}
				add(ruleCharAtom, position442)
			}
			return true
		l441:
			position, tokenIndex = position441, tokenIndex441
			return false
		},
		/* 62 Char <- <([a-z] / [A-Z])> */
		func() bool {
			position444, tokenIndex444 := position, tokenIndex
			{
				position445 := position
				{
					position446, tokenIndex446 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l447
					}
					position++
					goto l446
				l447:
					position, tokenIndex = position446, tokenIndex446
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l444
					}
					position++
				}
			l446:
				add(ruleChar, position445)
			}
			return true
		l444:
			position, tokenIndex = position444, tokenIndex444
			return false
		},
		/* 63 IntegerAtom <- <Digit+> */
		func() bool {
			position448, tokenIndex448 := position, tokenIndex
			{
				position449 := position
				if !_rules[ruleDigit]() {
					goto l448
				}
			l450:
				{
					position451, tokenIndex451 := position, tokenIndex
					if !_rules[ruleDigit]() {
						goto l451
					}
					goto l450
				l451:
					position, tokenIndex = position451, tokenIndex451
				}
				add(ruleIntegerAtom, position449)
			}
			return true
		l448:
			position, tokenIndex = position448, tokenIndex448
			return false
		},
		/* 64 Digit <- <[0-9]> */
		func() bool {
			position452, tokenIndex452 := position, tokenIndex
			{
				position453 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l452
				}
				position++
				add(ruleDigit, position453)
			}
			return true
		l452:
			position, tokenIndex = position452, tokenIndex452
			return false
		},
		/* 65 ListAtom <- <('[' _ ExprSeq? _ ']')> */
		func() bool {
			position454, tokenIndex454 := position, tokenIndex
			{
				position455 := position
				if buffer[position] != rune('[') {
					goto l454
				}
				position++
				if !_rules[rule_]() {
					goto l454
				}
				{
					position456, tokenIndex456 := position, tokenIndex
					if !_rules[ruleExprSeq]() {
						goto l456
					}
					goto l457
				l456:
					position, tokenIndex = position456, tokenIndex456
				}
			l457:
				if !_rules[rule_]() {
					goto l454
				}
				if buffer[position] != rune(']') {
					goto l454
				}
				position++
				add(ruleListAtom, position455)
			}
			return true
		l454:
			position, tokenIndex = position454, tokenIndex454
			return false
		},
		/* 66 ExprSeq <- <(Expr ((_ ',' _ ExprSeq) / Expr)?)> */
		func() bool {
			position458, tokenIndex458 := position, tokenIndex
			{
				position459 := position
				if !_rules[ruleExpr]() {
					goto l458
				}
				{
					position460, tokenIndex460 := position, tokenIndex
					{
						position462, tokenIndex462 := position, tokenIndex
						if !_rules[rule_]() {
							goto l463
						}
						if buffer[position] != rune(',') {
							goto l463
						}
						position++
						if !_rules[rule_]() {
							goto l463
						}
						if !_rules[ruleExprSeq]() {
							goto l463
						}
						goto l462
					l463:
						position, tokenIndex = position462, tokenIndex462
						if !_rules[ruleExpr]() {
							goto l460
						}
					}
				l462:
					goto l461
				l460:
					position, tokenIndex = position460, tokenIndex460
				}
			l461:
				add(ruleExprSeq, position459)
			}
			return true
		l458:
			position, tokenIndex = position458, tokenIndex458
			return false
		},
		/* 67 AtomExpr <- <(UnaryOp? _ (FoldMacro / GettableExpr / IfWithError / Match / ConstAtom))> */
		func() bool {
			position464, tokenIndex464 := position, tokenIndex
			{
				position465 := position
				{
					position466, tokenIndex466 := position, tokenIndex
					if !_rules[ruleUnaryOp]() {
						goto l466
					}
					goto l467
				l466:
					position, tokenIndex = position466, tokenIndex466
				}
			l467:
				if !_rules[rule_]() {
					goto l464
				}
				{
					position468, tokenIndex468 := position, tokenIndex
					if !_rules[ruleFoldMacro]() {
						goto l469
					}
					goto l468
				l469:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleGettableExpr]() {
						goto l470
					}
					goto l468
				l470:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleIfWithError]() {
						goto l471
					}
					goto l468
				l471:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleMatch]() {
						goto l472
					}
					goto l468
				l472:
					position, tokenIndex = position468, tokenIndex468
					if !_rules[ruleConstAtom]() {
						goto l464
					}
				}
			l468:
				add(ruleAtomExpr, position465)
			}
			return true
		l464:
			position, tokenIndex = position464, tokenIndex464
			return false
		},
		/* 68 MultGroupOpAtom <- <(AtomExpr (_ MultGroupOp _ AtomExpr)*)> */
		func() bool {
			position473, tokenIndex473 := position, tokenIndex
			{
				position474 := position
				if !_rules[ruleAtomExpr]() {
					goto l473
				}
			l475:
				{
					position476, tokenIndex476 := position, tokenIndex
					if !_rules[rule_]() {
						goto l476
					}
					if !_rules[ruleMultGroupOp]() {
						goto l476
					}
					if !_rules[rule_]() {
						goto l476
					}
					if !_rules[ruleAtomExpr]() {
						goto l476
					}
					goto l475
				l476:
					position, tokenIndex = position476, tokenIndex476
				}
				add(ruleMultGroupOpAtom, position474)
			}
			return true
		l473:
			position, tokenIndex = position473, tokenIndex473
			return false
		},
		/* 69 SumGroupOpAtom <- <(MultGroupOpAtom (_ SumGroupOp _ MultGroupOpAtom)*)> */
		func() bool {
			position477, tokenIndex477 := position, tokenIndex
			{
				position478 := position
				if !_rules[ruleMultGroupOpAtom]() {
					goto l477
				}
			l479:
				{
					position480, tokenIndex480 := position, tokenIndex
					if !_rules[rule_]() {
						goto l480
					}
					if !_rules[ruleSumGroupOp]() {
						goto l480
					}
					if !_rules[rule_]() {
						goto l480
					}
					if !_rules[ruleMultGroupOpAtom]() {
						goto l480
					}
					goto l479
				l480:
					position, tokenIndex = position480, tokenIndex480
				}
				add(ruleSumGroupOpAtom, position478)
			}
			return true
		l477:
			position, tokenIndex = position477, tokenIndex477
			return false
		},
		/* 70 ConsOpAtom <- <(SumGroupOpAtom (_ ConsOp _ SumGroupOpAtom)*)> */
		func() bool {
			position481, tokenIndex481 := position, tokenIndex
			{
				position482 := position
				if !_rules[ruleSumGroupOpAtom]() {
					goto l481
				}
			l483:
				{
					position484, tokenIndex484 := position, tokenIndex
					if !_rules[rule_]() {
						goto l484
					}
					if !_rules[ruleConsOp]() {
						goto l484
					}
					if !_rules[rule_]() {
						goto l484
					}
					if !_rules[ruleSumGroupOpAtom]() {
						goto l484
					}
					goto l483
				l484:
					position, tokenIndex = position484, tokenIndex484
				}
				add(ruleConsOpAtom, position482)
			}
			return true
		l481:
			position, tokenIndex = position481, tokenIndex481
			return false
		},
		/* 71 CompareGroupOpAtom <- <(ConsOpAtom (_ CompareGroupOp _ ConsOpAtom)*)> */
		func() bool {
			position485, tokenIndex485 := position, tokenIndex
			{
				position486 := position
				if !_rules[ruleConsOpAtom]() {
					goto l485
				}
			l487:
				{
					position488, tokenIndex488 := position, tokenIndex
					if !_rules[rule_]() {
						goto l488
					}
					if !_rules[ruleCompareGroupOp]() {
						goto l488
					}
					if !_rules[rule_]() {
						goto l488
					}
					if !_rules[ruleConsOpAtom]() {
						goto l488
					}
					goto l487
				l488:
					position, tokenIndex = position488, tokenIndex488
				}
				add(ruleCompareGroupOpAtom, position486)
			}
			return true
		l485:
			position, tokenIndex = position485, tokenIndex485
			return false
		},
		/* 72 EqualityGroupOpAtom <- <(CompareGroupOpAtom (_ EqGroupOp _ CompareGroupOpAtom)*)> */
		func() bool {
			position489, tokenIndex489 := position, tokenIndex
			{
				position490 := position
				if !_rules[ruleCompareGroupOpAtom]() {
					goto l489
				}
			l491:
				{
					position492, tokenIndex492 := position, tokenIndex
					if !_rules[rule_]() {
						goto l492
					}
					if !_rules[ruleEqGroupOp]() {
						goto l492
					}
					if !_rules[rule_]() {
						goto l492
					}
					if !_rules[ruleCompareGroupOpAtom]() {
						goto l492
					}
					goto l491
				l492:
					position, tokenIndex = position492, tokenIndex492
				}
				add(ruleEqualityGroupOpAtom, position490)
			}
			return true
		l489:
			position, tokenIndex = position489, tokenIndex489
			return false
		},
		/* 73 AndOpAtom <- <(EqualityGroupOpAtom (_ AndOp _ EqualityGroupOpAtom)*)> */
		func() bool {
			position493, tokenIndex493 := position, tokenIndex
			{
				position494 := position
				if !_rules[ruleEqualityGroupOpAtom]() {
					goto l493
				}
			l495:
				{
					position496, tokenIndex496 := position, tokenIndex
					if !_rules[rule_]() {
						goto l496
					}
					if !_rules[ruleAndOp]() {
						goto l496
					}
					if !_rules[rule_]() {
						goto l496
					}
					if !_rules[ruleEqualityGroupOpAtom]() {
						goto l496
					}
					goto l495
				l496:
					position, tokenIndex = position496, tokenIndex496
				}
				add(ruleAndOpAtom, position494)
			}
			return true
		l493:
			position, tokenIndex = position493, tokenIndex493
			return false
		},
		/* 74 OrOpAtom <- <(AndOpAtom (_ OrOp _ AndOpAtom)*)> */
		func() bool {
			position497, tokenIndex497 := position, tokenIndex
			{
				position498 := position
				if !_rules[ruleAndOpAtom]() {
					goto l497
				}
			l499:
				{
					position500, tokenIndex500 := position, tokenIndex
					if !_rules[rule_]() {
						goto l500
					}
					if !_rules[ruleOrOp]() {
						goto l500
					}
					if !_rules[rule_]() {
						goto l500
					}
					if !_rules[ruleAndOpAtom]() {
						goto l500
					}
					goto l499
				l500:
					position, tokenIndex = position500, tokenIndex500
				}
				add(ruleOrOpAtom, position498)
			}
			return true
		l497:
			position, tokenIndex = position497, tokenIndex497
			return false
		},
		/* 75 Expr <- <OrOpAtom> */
		func() bool {
			position501, tokenIndex501 := position, tokenIndex
			{
				position502 := position
				if !_rules[ruleOrOpAtom]() {
					goto l501
				}
				add(ruleExpr, position502)
			}
			return true
		l501:
			position, tokenIndex = position501, tokenIndex501
			return false
		},
		/* 76 ParExpr <- <('(' _ Expr _ ')')> */
		func() bool {
			position503, tokenIndex503 := position, tokenIndex
			{
				position504 := position
				if buffer[position] != rune('(') {
					goto l503
				}
				position++
				if !_rules[rule_]() {
					goto l503
				}
				if !_rules[ruleExpr]() {
					goto l503
				}
				if !_rules[rule_]() {
					goto l503
				}
				if buffer[position] != rune(')') {
					goto l503
				}
				position++
				add(ruleParExpr, position504)
			}
			return true
		l503:
			position, tokenIndex = position503, tokenIndex503
			return false
		},
		/* 77 GettableExpr <- <((ParExpr / Block / FunctionCall / ReferenceAtom) (_ (ListAccess / ('.' _ (FunctionCallAccess / IdentifierAtomAccess))))*)> */
		func() bool {
			position505, tokenIndex505 := position, tokenIndex
			{
				position506 := position
				{
					position507, tokenIndex507 := position, tokenIndex
					if !_rules[ruleParExpr]() {
						goto l508
					}
					goto l507
				l508:
					position, tokenIndex = position507, tokenIndex507
					if !_rules[ruleBlock]() {
						goto l509
					}
					goto l507
				l509:
					position, tokenIndex = position507, tokenIndex507
					if !_rules[ruleFunctionCall]() {
						goto l510
					}
					goto l507
				l510:
					position, tokenIndex = position507, tokenIndex507
					if !_rules[ruleReferenceAtom]() {
						goto l505
					}
				}
			l507:
			l511:
				{
					position512, tokenIndex512 := position, tokenIndex
					if !_rules[rule_]() {
						goto l512
					}
					{
						position513, tokenIndex513 := position, tokenIndex
						if !_rules[ruleListAccess]() {
							goto l514
						}
						goto l513
					l514:
						position, tokenIndex = position513, tokenIndex513
						if buffer[position] != rune('.') {
							goto l512
						}
						position++
						if !_rules[rule_]() {
							goto l512
						}
						{
							position515, tokenIndex515 := position, tokenIndex
							if !_rules[ruleFunctionCallAccess]() {
								goto l516
							}
							goto l515
						l516:
							position, tokenIndex = position515, tokenIndex515
							if !_rules[ruleIdentifierAtomAccess]() {
								goto l512
							}
						}
					l515:
					}
				l513:
					goto l511
				l512:
					position, tokenIndex = position512, tokenIndex512
				}
				add(ruleGettableExpr, position506)
			}
			return true
		l505:
			position, tokenIndex = position505, tokenIndex505
			return false
		},
		/* 78 FunctionCallAccess <- <FunctionCall> */
		func() bool {
			position517, tokenIndex517 := position, tokenIndex
			{
				position518 := position
				if !_rules[ruleFunctionCall]() {
					goto l517
				}
				add(ruleFunctionCallAccess, position518)
			}
			return true
		l517:
			position, tokenIndex = position517, tokenIndex517
			return false
		},
		/* 79 IdentifierAtomAccess <- <IdentifierAtom> */
		func() bool {
			position519, tokenIndex519 := position, tokenIndex
			{
				position520 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l519
				}
				add(ruleIdentifierAtomAccess, position520)
			}
			return true
		l519:
			position, tokenIndex = position519, tokenIndex519
			return false
		},
		/* 80 ListAccess <- <('[' _ (Expr / ReferenceAtom) _ ']')> */
		func() bool {
			position521, tokenIndex521 := position, tokenIndex
			{
				position522 := position
				if buffer[position] != rune('[') {
					goto l521
				}
				position++
				if !_rules[rule_]() {
					goto l521
				}
				{
					position523, tokenIndex523 := position, tokenIndex
					if !_rules[ruleExpr]() {
						goto l524
					}
					goto l523
				l524:
					position, tokenIndex = position523, tokenIndex523
					if !_rules[ruleReferenceAtom]() {
						goto l521
					}
				}
			l523:
				if !_rules[rule_]() {
					goto l521
				}
				if buffer[position] != rune(']') {
					goto l521
				}
				position++
				add(ruleListAccess, position522)
			}
			return true
		l521:
			position, tokenIndex = position521, tokenIndex521
			return false
		},
		/* 81 Block <- <('{' (_ Declaration)* _ BlockDecExprSep? _ Expr _ '}')> */
		func() bool {
			position525, tokenIndex525 := position, tokenIndex
			{
				position526 := position
				if buffer[position] != rune('{') {
					goto l525
				}
				position++
			l527:
				{
					position528, tokenIndex528 := position, tokenIndex
					if !_rules[rule_]() {
						goto l528
					}
					if !_rules[ruleDeclaration]() {
						goto l528
					}
					goto l527
				l528:
					position, tokenIndex = position528, tokenIndex528
				}
				if !_rules[rule_]() {
					goto l525
				}
				{
					position529, tokenIndex529 := position, tokenIndex
					if !_rules[ruleBlockDecExprSep]() {
						goto l529
					}
					goto l530
				l529:
					position, tokenIndex = position529, tokenIndex529
				}
			l530:
				if !_rules[rule_]() {
					goto l525
				}
				if !_rules[ruleExpr]() {
					goto l525
				}
				if !_rules[rule_]() {
					goto l525
				}
				if buffer[position] != rune('}') {
					goto l525
				}
				position++
				add(ruleBlock, position526)
			}
			return true
		l525:
			position, tokenIndex = position525, tokenIndex525
			return false
		},
		/* 82 BlockWithoutPar <- <((_ Declaration)* _ BlockDecExprSep? _ Expr)> */
		func() bool {
			position531, tokenIndex531 := position, tokenIndex
			{
				position532 := position
			l533:
				{
					position534, tokenIndex534 := position, tokenIndex
					if !_rules[rule_]() {
						goto l534
					}
					if !_rules[ruleDeclaration]() {
						goto l534
					}
					goto l533
				l534:
					position, tokenIndex = position534, tokenIndex534
				}
				if !_rules[rule_]() {
					goto l531
				}
				{
					position535, tokenIndex535 := position, tokenIndex
					if !_rules[ruleBlockDecExprSep]() {
						goto l535
					}
					goto l536
				l535:
					position, tokenIndex = position535, tokenIndex535
				}
			l536:
				if !_rules[rule_]() {
					goto l531
				}
				if !_rules[ruleExpr]() {
					goto l531
				}
				add(ruleBlockWithoutPar, position532)
			}
			return true
		l531:
			position, tokenIndex = position531, tokenIndex531
			return false
		},
		/* 83 BlockDecExprSep <- <':'> */
		func() bool {
			position537, tokenIndex537 := position, tokenIndex
			{
				position538 := position
				if buffer[position] != rune(':') {
					goto l537
				}
				position++
				add(ruleBlockDecExprSep, position538)
			}
			return true
		l537:
			position, tokenIndex = position537, tokenIndex537
			return false
		},
		/* 84 FunctionCall <- <(IdentifierAtom _ '(' _ ExprSeq? _ ')')> */
		func() bool {
			position539, tokenIndex539 := position, tokenIndex
			{
				position540 := position
				if !_rules[ruleIdentifierAtom]() {
					goto l539
				}
				if !_rules[rule_]() {
					goto l539
				}
				if buffer[position] != rune('(') {
					goto l539
				}
				position++
				if !_rules[rule_]() {
					goto l539
				}
				{
					position541, tokenIndex541 := position, tokenIndex
					if !_rules[ruleExprSeq]() {
						goto l541
					}
					goto l542
				l541:
					position, tokenIndex = position541, tokenIndex541
				}
			l542:
				if !_rules[rule_]() {
					goto l539
				}
				if buffer[position] != rune(')') {
					goto l539
				}
				position++
				add(ruleFunctionCall, position540)
			}
			return true
		l539:
			position, tokenIndex = position539, tokenIndex539
			return false
		},
		/* 85 FoldMacro <- <(('f' / 'F') ('o' / 'O') ('l' / 'L') ('d' / 'D') _ '<' _ IntegerAtom _ '>' _ '(' _ Expr _ ',' _ Expr _ ',' _ ReferenceAtom _ ')')> */
		func() bool {
			position543, tokenIndex543 := position, tokenIndex
			{
				position544 := position
				{
					position545, tokenIndex545 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l546
					}
					position++
					goto l545
				l546:
					position, tokenIndex = position545, tokenIndex545
					if buffer[position] != rune('F') {
						goto l543
					}
					position++
				}
			l545:
				{
					position547, tokenIndex547 := position, tokenIndex
					if buffer[position] != rune('o') {
						goto l548
					}
					position++
					goto l547
				l548:
					position, tokenIndex = position547, tokenIndex547
					if buffer[position] != rune('O') {
						goto l543
					}
					position++
				}
			l547:
				{
					position549, tokenIndex549 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l550
					}
					position++
					goto l549
				l550:
					position, tokenIndex = position549, tokenIndex549
					if buffer[position] != rune('L') {
						goto l543
					}
					position++
				}
			l549:
				{
					position551, tokenIndex551 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l552
					}
					position++
					goto l551
				l552:
					position, tokenIndex = position551, tokenIndex551
					if buffer[position] != rune('D') {
						goto l543
					}
					position++
				}
			l551:
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune('<') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleIntegerAtom]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune('>') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune('(') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleExpr]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune(',') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleExpr]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune(',') {
					goto l543
				}
				position++
				if !_rules[rule_]() {
					goto l543
				}
				if !_rules[ruleReferenceAtom]() {
					goto l543
				}
				if !_rules[rule_]() {
					goto l543
				}
				if buffer[position] != rune(')') {
					goto l543
				}
				position++
				add(ruleFoldMacro, position544)
			}
			return true
		l543:
			position, tokenIndex = position543, tokenIndex543
			return false
		},
		/* 86 IfWithError <- <(If / FailedIfWithoutElse)> */
		func() bool {
			position553, tokenIndex553 := position, tokenIndex
			{
				position554 := position
				{
					position555, tokenIndex555 := position, tokenIndex
					if !_rules[ruleIf]() {
						goto l556
					}
					goto l555
				l556:
					position, tokenIndex = position555, tokenIndex555
					if !_rules[ruleFailedIfWithoutElse]() {
						goto l553
					}
				}
			l555:
				add(ruleIfWithError, position554)
			}
			return true
		l553:
			position, tokenIndex = position553, tokenIndex553
			return false
		},
		/* 87 If <- <(('i' / 'I') ('f' / 'F') _ Expr _ (('t' / 'T') ('h' / 'H') ('e' / 'E') ('n' / 'N')) _ Expr _ (('e' / 'E') ('l' / 'L') ('s' / 'S') ('e' / 'E')) _ Expr)> */
		func() bool {
			position557, tokenIndex557 := position, tokenIndex
			{
				position558 := position
				{
					position559, tokenIndex559 := position, tokenIndex
					if buffer[position] != rune('i') {
						goto l560
					}
					position++
					goto l559
				l560:
					position, tokenIndex = position559, tokenIndex559
					if buffer[position] != rune('I') {
						goto l557
					}
					position++
				}
			l559:
				{
					position561, tokenIndex561 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l562
					}
					position++
					goto l561
				l562:
					position, tokenIndex = position561, tokenIndex561
					if buffer[position] != rune('F') {
						goto l557
					}
					position++
				}
			l561:
				if !_rules[rule_]() {
					goto l557
				}
				if !_rules[ruleExpr]() {
					goto l557
				}
				if !_rules[rule_]() {
					goto l557
				}
				{
					position563, tokenIndex563 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l564
					}
					position++
					goto l563
				l564:
					position, tokenIndex = position563, tokenIndex563
					if buffer[position] != rune('T') {
						goto l557
					}
					position++
				}
			l563:
				{
					position565, tokenIndex565 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l566
					}
					position++
					goto l565
				l566:
					position, tokenIndex = position565, tokenIndex565
					if buffer[position] != rune('H') {
						goto l557
					}
					position++
				}
			l565:
				{
					position567, tokenIndex567 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l568
					}
					position++
					goto l567
				l568:
					position, tokenIndex = position567, tokenIndex567
					if buffer[position] != rune('E') {
						goto l557
					}
					position++
				}
			l567:
				{
					position569, tokenIndex569 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l570
					}
					position++
					goto l569
				l570:
					position, tokenIndex = position569, tokenIndex569
					if buffer[position] != rune('N') {
						goto l557
					}
					position++
				}
			l569:
				if !_rules[rule_]() {
					goto l557
				}
				if !_rules[ruleExpr]() {
					goto l557
				}
				if !_rules[rule_]() {
					goto l557
				}
				{
					position571, tokenIndex571 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l572
					}
					position++
					goto l571
				l572:
					position, tokenIndex = position571, tokenIndex571
					if buffer[position] != rune('E') {
						goto l557
					}
					position++
				}
			l571:
				{
					position573, tokenIndex573 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l574
					}
					position++
					goto l573
				l574:
					position, tokenIndex = position573, tokenIndex573
					if buffer[position] != rune('L') {
						goto l557
					}
					position++
				}
			l573:
				{
					position575, tokenIndex575 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l576
					}
					position++
					goto l575
				l576:
					position, tokenIndex = position575, tokenIndex575
					if buffer[position] != rune('S') {
						goto l557
					}
					position++
				}
			l575:
				{
					position577, tokenIndex577 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l578
					}
					position++
					goto l577
				l578:
					position, tokenIndex = position577, tokenIndex577
					if buffer[position] != rune('E') {
						goto l557
					}
					position++
				}
			l577:
				if !_rules[rule_]() {
					goto l557
				}
				if !_rules[ruleExpr]() {
					goto l557
				}
				add(ruleIf, position558)
			}
			return true
		l557:
			position, tokenIndex = position557, tokenIndex557
			return false
		},
		/* 88 FailedIfWithoutElse <- <(('i' / 'I') ('f' / 'F') _ Expr _ (('t' / 'T') ('h' / 'H') ('e' / 'E') ('n' / 'N')) _ Expr)> */
		func() bool {
			position579, tokenIndex579 := position, tokenIndex
			{
				position580 := position
				{
					position581, tokenIndex581 := position, tokenIndex
					if buffer[position] != rune('i') {
						goto l582
					}
					position++
					goto l581
				l582:
					position, tokenIndex = position581, tokenIndex581
					if buffer[position] != rune('I') {
						goto l579
					}
					position++
				}
			l581:
				{
					position583, tokenIndex583 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l584
					}
					position++
					goto l583
				l584:
					position, tokenIndex = position583, tokenIndex583
					if buffer[position] != rune('F') {
						goto l579
					}
					position++
				}
			l583:
				if !_rules[rule_]() {
					goto l579
				}
				if !_rules[ruleExpr]() {
					goto l579
				}
				if !_rules[rule_]() {
					goto l579
				}
				{
					position585, tokenIndex585 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l586
					}
					position++
					goto l585
				l586:
					position, tokenIndex = position585, tokenIndex585
					if buffer[position] != rune('T') {
						goto l579
					}
					position++
				}
			l585:
				{
					position587, tokenIndex587 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l588
					}
					position++
					goto l587
				l588:
					position, tokenIndex = position587, tokenIndex587
					if buffer[position] != rune('H') {
						goto l579
					}
					position++
				}
			l587:
				{
					position589, tokenIndex589 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l590
					}
					position++
					goto l589
				l590:
					position, tokenIndex = position589, tokenIndex589
					if buffer[position] != rune('E') {
						goto l579
					}
					position++
				}
			l589:
				{
					position591, tokenIndex591 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l592
					}
					position++
					goto l591
				l592:
					position, tokenIndex = position591, tokenIndex591
					if buffer[position] != rune('N') {
						goto l579
					}
					position++
				}
			l591:
				if !_rules[rule_]() {
					goto l579
				}
				if !_rules[ruleExpr]() {
					goto l579
				}
				add(ruleFailedIfWithoutElse, position580)
			}
			return true
		l579:
			position, tokenIndex = position579, tokenIndex579
			return false
		},
		/* 89 Match <- <(('m' / 'M') ('a' / 'A') ('t' / 'T') ('c' / 'C') ('h' / 'H') _ Expr _ '{' (_ MatchCase)+ _ '}')> */
		func() bool {
			position593, tokenIndex593 := position, tokenIndex
			{
				position594 := position
				{
					position595, tokenIndex595 := position, tokenIndex
					if buffer[position] != rune('m') {
						goto l596
					}
					position++
					goto l595
				l596:
					position, tokenIndex = position595, tokenIndex595
					if buffer[position] != rune('M') {
						goto l593
					}
					position++
				}
			l595:
				{
					position597, tokenIndex597 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l598
					}
					position++
					goto l597
				l598:
					position, tokenIndex = position597, tokenIndex597
					if buffer[position] != rune('A') {
						goto l593
					}
					position++
				}
			l597:
				{
					position599, tokenIndex599 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l600
					}
					position++
					goto l599
				l600:
					position, tokenIndex = position599, tokenIndex599
					if buffer[position] != rune('T') {
						goto l593
					}
					position++
				}
			l599:
				{
					position601, tokenIndex601 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l602
					}
					position++
					goto l601
				l602:
					position, tokenIndex = position601, tokenIndex601
					if buffer[position] != rune('C') {
						goto l593
					}
					position++
				}
			l601:
				{
					position603, tokenIndex603 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l604
					}
					position++
					goto l603
				l604:
					position, tokenIndex = position603, tokenIndex603
					if buffer[position] != rune('H') {
						goto l593
					}
					position++
				}
			l603:
				if !_rules[rule_]() {
					goto l593
				}
				if !_rules[ruleExpr]() {
					goto l593
				}
				if !_rules[rule_]() {
					goto l593
				}
				if buffer[position] != rune('{') {
					goto l593
				}
				position++
				if !_rules[rule_]() {
					goto l593
				}
				if !_rules[ruleMatchCase]() {
					goto l593
				}
			l605:
				{
					position606, tokenIndex606 := position, tokenIndex
					if !_rules[rule_]() {
						goto l606
					}
					if !_rules[ruleMatchCase]() {
						goto l606
					}
					goto l605
				l606:
					position, tokenIndex = position606, tokenIndex606
				}
				if !_rules[rule_]() {
					goto l593
				}
				if buffer[position] != rune('}') {
					goto l593
				}
				position++
				add(ruleMatch, position594)
			}
			return true
		l593:
			position, tokenIndex = position593, tokenIndex593
			return false
		},
		/* 90 MatchCase <- <(('c' / 'C') ('a' / 'A') ('s' / 'S') ('e' / 'E') _ ((IdentifierAtom _ (':' _ TypesAtom)?) / DefaultMatchCasePart) _ ('=' '>') _ BlockWithoutPar)> */
		func() bool {
			position607, tokenIndex607 := position, tokenIndex
			{
				position608 := position
				{
					position609, tokenIndex609 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l610
					}
					position++
					goto l609
				l610:
					position, tokenIndex = position609, tokenIndex609
					if buffer[position] != rune('C') {
						goto l607
					}
					position++
				}
			l609:
				{
					position611, tokenIndex611 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l612
					}
					position++
					goto l611
				l612:
					position, tokenIndex = position611, tokenIndex611
					if buffer[position] != rune('A') {
						goto l607
					}
					position++
				}
			l611:
				{
					position613, tokenIndex613 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l614
					}
					position++
					goto l613
				l614:
					position, tokenIndex = position613, tokenIndex613
					if buffer[position] != rune('S') {
						goto l607
					}
					position++
				}
			l613:
				{
					position615, tokenIndex615 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l616
					}
					position++
					goto l615
				l616:
					position, tokenIndex = position615, tokenIndex615
					if buffer[position] != rune('E') {
						goto l607
					}
					position++
				}
			l615:
				if !_rules[rule_]() {
					goto l607
				}
				{
					position617, tokenIndex617 := position, tokenIndex
					if !_rules[ruleIdentifierAtom]() {
						goto l618
					}
					if !_rules[rule_]() {
						goto l618
					}
					{
						position619, tokenIndex619 := position, tokenIndex
						if buffer[position] != rune(':') {
							goto l619
						}
						position++
						if !_rules[rule_]() {
							goto l619
						}
						if !_rules[ruleTypesAtom]() {
							goto l619
						}
						goto l620
					l619:
						position, tokenIndex = position619, tokenIndex619
					}
				l620:
					goto l617
				l618:
					position, tokenIndex = position617, tokenIndex617
					if !_rules[ruleDefaultMatchCasePart]() {
						goto l607
					}
				}
			l617:
				if !_rules[rule_]() {
					goto l607
				}
				if buffer[position] != rune('=') {
					goto l607
				}
				position++
				if buffer[position] != rune('>') {
					goto l607
				}
				position++
				if !_rules[rule_]() {
					goto l607
				}
				if !_rules[ruleBlockWithoutPar]() {
					goto l607
				}
				add(ruleMatchCase, position608)
			}
			return true
		l607:
			position, tokenIndex = position607, tokenIndex607
			return false
		},
		/* 91 DefaultMatchCasePart <- <('{' _ (':' _ TypesAtom)?)> */
		func() bool {
			position621, tokenIndex621 := position, tokenIndex
			{
				position622 := position
				if buffer[position] != rune('{') {
					goto l621
				}
				position++
				if !_rules[rule_]() {
					goto l621
				}
				{
					position623, tokenIndex623 := position, tokenIndex
					if buffer[position] != rune(':') {
						goto l623
					}
					position++
					if !_rules[rule_]() {
						goto l623
					}
					if !_rules[ruleTypesAtom]() {
						goto l623
					}
					goto l624
				l623:
					position, tokenIndex = position623, tokenIndex623
				}
			l624:
				add(ruleDefaultMatchCasePart, position622)
			}
			return true
		l621:
			position, tokenIndex = position621, tokenIndex621
			return false
		},
	}
	p.rules = _rules
	return nil
}
