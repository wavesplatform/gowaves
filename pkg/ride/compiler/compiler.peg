{
package main

import (
    "github.com/pkg/errors"
)

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Input ← StartRule EOL? d:Directives s:Statements  r:ReturnOp  EOF {
    if d == nil {
        return nil, errors.Errorf("header isn't correct")
    }
    return newProgramNode(s.(StatementsNode),r.(ReturnNode), d.(Directives))
}
Statements  ← s:Line+                       { return newStatementsNode(s)}
Line        ← INDENTATION s:Statement       { return s,nil }
ReturnOp    ← "return" _ arg:Identifier EOL { return newReturnNode(arg.(IdentifierNode))}

Statement   ← s:Assignment EOL              { return s.(AssignmentNode),nil }
    / "if" _ arg:LogicalExpression _? ":" EOL INDENT s:Statements DEDENT
                                            { return newIfNode(arg.(LogicalExpressionNode),s.(StatementsNode)) }


Assignment ← lvalue:Identifier _? "=" _? rvalue:AdditiveExpression
                                            { return newAssignmentNode(lvalue.(IdentifierNode),rvalue.(AdditiveExpressionNode)) }

LogicalExpression   ← arg:PrimaryExpression { return newLogicalExpressionNode(arg.(PrimaryExpressionNode)) }
AdditiveExpression  ← arg:PrimaryExpression rest:( _ AddOp _ PrimaryExpression )*
                                            { return newAdditiveExpressionNode(arg.(PrimaryExpressionNode),rest)}
PrimaryExpression   ← arg:(Integer / Identifier)
                                            { return newPrimaryExpressionNode(arg) }

Integer ← [0-9]+                            { return newIntegerNode(string(c.text)) }
Identifier ← [a-zA-Z] [a-zA-Z0-9]*          { return newIdentifierNode(string(c.text)) }

AddOp ← ( '+' / '-' )                       { return string(c.text),nil }

_ ← [ \t]+

EOL ← (Comment / NewLine)+

NewLine <- _? ("\r\n" / "\n\r" / "\r" / "\n")

Comment ← _? "#" [^\r\n]*

EOF ← !.

INDENTATION ← spaces:" "* &{ return len(toIfaceSlice(spaces)) == c.state["Indentation"].(int), nil }

INDENT ← #{ c.state["Indentation"] = c.state["Indentation"].(int) + 4; return nil }

DEDENT ← #{ c.state["Indentation"] = c.state["Indentation"].(int) - 4; return nil }

StartRule <- #{
    c.state["Indentation"] = 0
    c.globalStore["libVersionCnt"] = 0
    c.globalStore["scriptTypeCnt"] = 0
    c.globalStore["contentTypeCnt"] = 0
    return nil
}

// Types

Types <- (Int / Boolean / ByteVector / String)

Int <- [0-9]+ {
    return strconv.ParseInt(string(c.text), 0, 64)
}
Boolean <- "true" { return true, nil } / "false" { return false, nil }
ByteVector <- base:("base16" / "base58" / "base64") '\''vec:[^\'\r\n]*'\'' {
    return  NewByteVector(string(base.([]byte)), base.([]byte))
}
String <- '\"' s:[] '\"'  {

}


// Directives rules

Directives <- ((StdLibVersionDirective / ScriptTypeDirective / ContentTypeDirective) EOL)+ {
    if _, ok := c.globalStore["libVersion"]; !ok {
        return nil, errors.Errorf("missing STDLIB_VERSION directive")
    }
    if _, ok := c.globalStore["scriptType"]; !ok {
        return nil, errors.Errorf("missing SCRIPT_TYPE directive")
    }
    if _, ok := c.globalStore["contentType"]; !ok {
        return nil, errors.Errorf("missing CONTENT_TYPE directive")
    }
    return newDirectives(c.globalStore["libVersion"].(int64), c.globalStore["scriptType"].(int64), c.globalStore["contentType"].(int64))
}

StartDirective <- "{-#"
EndDirective <- "#-}"

StdLibVersion <- ver:Int {
    return newStdLibVersion(ver.(int64))
}

StdLibVersionDirective <- StartDirective _ "STDLIB_VERSION" _ ver:StdLibVersion _ EndDirective &{
    c.globalStore["libVersionCnt"] = c.globalStore["libVersionCnt"].(int) + 1
    if c.globalStore["libVersionCnt"].(int) > 1 {
        return true, errors.Errorf("more than one STDLIB_VERSION directive")
    }
    c.globalStore["libVersion"] = ver.(int64)
    return true, nil
}

Word <- [a-zA-Z_-] [a-zA-Z_0-9-]*         { return string(c.text), nil }

ScriptType <- arg:Word {
    return newScriptType(arg.(string))
}

ScriptTypeDirective <- StartDirective _ "SCRIPT_TYPE" _ arg:ScriptType _ EndDirective &{
    c.globalStore["scriptTypeCnt"] = c.globalStore["scriptTypeCnt"].(int) + 1
    if c.globalStore["scriptTypeCnt"].(int) > 1 {
        return true, errors.New("more than one SCRIPT_TYPE directive")
    }
    c.globalStore["scriptType"] = arg.(int64)
    return true, nil
}

ContentType <- arg:Word {
    return newContentType(arg.(string))
}

ContentTypeDirective <- StartDirective _ "CONTENT_TYPE" _ arg:ContentType _ EndDirective &{
    c.globalStore["contentTypeCnt"] = c.globalStore["contentTypeCnt"].(int) + 1
    if c.globalStore["contentTypeCnt"].(int) > 1 {
        return true, errors.Errorf("more than one CONTENT_TYPE directive")
    }
    c.globalStore["contentType"] = arg.(int64)
    return true, nil
}

// Variables

Variables <- "let" _ name:word _ "=" _ value:Types EOL {
    return NewVariable(name.(string), value)
}