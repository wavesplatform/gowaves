# Go part
package compiler

type Parser Peg {
}

# Start PEG

# Main rules
Code <- DAppRoot / ScriptRoot
DAppRoot <- _ (Directive _)* (_ Declaration)* (_ AnnotatedFunc)* _ EOF
ScriptRoot <- _ (Directive _)* (_ Declaration)* _ BlockDecExprSep? _ Expr _ EOF

# Whitespaces and new line symbols
WS <- [ \t]
EOL <- [\n\r\f]
Comment <- '#' [^\r^\n]*
_ <- (Comment / (WS / EOL)+)*

EOF <- !.

# Directives

DirectiveName <- [A-Z]+[_A-Z]*
UpperCaseString <- [A-Z]+
IntString <- [0-9]+
PathString <- [_a-zA-Z0-9-/,.]+
Directive <- "{-#" WS+ DirectiveName WS+ (IntString / UpperCaseString / PathString) WS+ "#-}"

# Declarations

Declaration <- Variable / StrictVariable / Func

Variable <- "let" _ IdentifierAtom _ "=" _ Expr
StrictVariable <- "strict" _ IdentifierAtom _ "=" _ Expr

Func <- "func" _ IdentifierAtom _ "(" _ FuncArgSeq? _ ")" _ "=" _ Expr
FuncArg <- IdentifierAtom _ ":" _ GenericTypesAtom
FuncArgSeq <- FuncArg (_ "," _ FuncArgSeq)?

AnnotatedFunc <- AnnotationSeq _ Func
Annotation <- "@" IdentifierAtom _ "(" _ IdentifierAtomSeq _ ")"
IdentifierAtomSeq <- IdentifierAtom ( _ "," _ IdentifierAtomSeq)?
AnnotationSeq <- Annotation ( _ AnnotationSeq)?

# Operators
OrOp <- "||"
AndOp <- "&&"

EqGroupOp <- EqOp / NeOp
EqOp <- "=="
NeOp <- "!="

CompareGroupOp <- GtOp / GeOp / LtOp / LeOp
GtOp <- ">" !"="
GeOp <- ">="
LtOp <- "<" !"="
LeOp <- "<="

ConsOp <- "::"

SumGroupOp <- SumOp / SubOp
SumOp <- '+'
SubOp <- '-'

MultGroupOp <- MulOp / DivOp / ModOp
MulOp <- '*'
DivOp <- '/'
ModOp <- '%'

UnaryOp <- PositiveOp / NegativeOp  / NotOp
PositiveOp <- '+'
NegativeOp <- '-'!'#'
NotOp <- '!'

# Types
ReservedWords <- "let" / "strict" / "base16" / "base58" / "base64" / "true" / "false" / "if" / "then" / "else" / "match" / "case" / "func"

ConstAtom <- IntegerAtom / StringAtom / ByteVectorAtom / BooleanAtom / ListAtom
IdentifierAtom <- (!ReservedWords [A-Za-z][A-Za-z0-9]*) / (ReservedWords [A-Za-z0-9]+)
GenericTypesAtom <- OneGenericTypeAtom ((_ "|" _ GenericTypesAtom) / OneGenericTypeAtom)?
OneGenericTypeAtom <- [A-Za-z][A-Za-z0-9]* (_ "[" _ OneTypeAtom _ "]" _)?
TypesAtom <- OneTypeAtom ((_ "|" _ TypesAtom) / OneTypeAtom)?
OneTypeAtom <- [A-Za-z][A-Za-z0-9]*

# ByteVector encodings
Base16 <- "base16'" [0-9ABCDEFabcdef]* "'"
Base58 <- "base58'" [123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]* "'"
Base64 <- "base64'" [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=]* "'"
ByteVectorAtom <- Base16 / Base58 / Base64

BooleanAtom <- "true" / "false"

StringAtom <- "\"" (UnicodeCharAtom / EscapedCharAtom / CharAtom)* "\""
UnicodeCharAtom <- "\\u" [0-9ABCDEFabcdef] [0-9ABCDEFabcdef]? [0-9ABCDEFabcdef]? [0-9ABCDEFabcdef]?
EscapedCharAtom <- "\\" .
CharAtom <- [^\"]

IntegerAtom <- [0-9]+

ListAtom <- "[" _ ExprSeq? _ "]"
ExprSeq <- Expr (_ "," _ ExprSeq)?

# Expressions
AtomExpr <- UnaryOp? _ (FoldMacro / GettableExpr / IfWithError / Match / ConstAtom)
MultGroupOpAtom <- AtomExpr (_ MultGroupOp _ AtomExpr)*
SumGroupOpAtom <- MultGroupOpAtom (_ SumGroupOp _ MultGroupOpAtom)*
ConsOpAtom <- SumGroupOpAtom (_ ConsOp _ SumGroupOpAtom)*
CompareGroupOpAtom <- ConsOpAtom (_ CompareGroupOp _ ConsOpAtom)*
EqualityGroupOpAtom <- CompareGroupOpAtom (_ EqGroupOp _ CompareGroupOpAtom)*
AndOpAtom <- EqualityGroupOpAtom (_ AndOp _ EqualityGroupOpAtom)*
OrOpAtom <- AndOpAtom (_ OrOp _ AndOpAtom)*

Expr <- OrOpAtom
ParExpr <- "(" _ Expr _ ")"

GettableExpr <- (ParExpr / Block / FunctionCall / IdentifierAtom) (_ (ListAccess / ("." _ (FunctionCallAccess / IdentifierAtomAccess))))*
FunctionCallAccess <- FunctionCall
IdentifierAtomAccess <- IdentifierAtom
ListAccess <- "[" _ (Expr / IdentifierAtom) _ "]"

Block <- "{" (_ Declaration)* _ BlockDecExprSep? _ Expr _ "}"
BlockWithoutPar <- (_ Declaration)* _ BlockDecExprSep? _ Expr
BlockDecExprSep <- ":"

FunctionCall <- IdentifierAtom _ "(" _ ExprSeq? _ ")"

FoldMacro <- "FOLD" _ "<" _ IntegerAtom _ ">" _ "(" _ Expr _ "," _ Expr _ "," _ IdentifierAtom _ ")"

IfWithError <- If / FailedIfWithoutElse
If <- "if" _ Expr _ "then" _ Expr _ "else" _ Expr
FailedIfWithoutElse <- "if" _ Expr _ "then" _ Expr

Match <- "match" _ Expr _ "{" (_ MatchCase)+ _ "}"
MatchCase <- "case" _ ((IdentifierAtom _ (":" _ TypesAtom)?) / DefaultMatchCasePart) _ "=>" _ BlockWithoutPar
DefaultMatchCasePart <- "{" _ (":" _ TypesAtom)?