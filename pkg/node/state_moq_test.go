// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package node

import (
	"github.com/wavesplatform/gowaves/pkg/crypto"
	"github.com/wavesplatform/gowaves/pkg/proto"
	"github.com/wavesplatform/gowaves/pkg/ride/ast"
	"github.com/wavesplatform/gowaves/pkg/settings"
	"github.com/wavesplatform/gowaves/pkg/state"
	"math/big"
	"sync"
)

// Ensure, that MockState does implement state.State.
// If this is not the case, regenerate this file with moq.
var _ state.State = &MockState{}

// MockState is a mock implementation of state.State.
//
//	func TestSomethingThatUsesState(t *testing.T) {
//
//		// make and configure a mocked state.State
//		mockedState := &MockState{
//			ActivationHeightFunc: func(featureID int16) (uint64, error) {
//				panic("mock out the ActivationHeight method")
//			},
//			AddBlockFunc: func(block []byte) (*proto.Block, error) {
//				panic("mock out the AddBlock method")
//			},
//			AddBlocksFunc: func(blocks [][]byte) error {
//				panic("mock out the AddBlocks method")
//			},
//			AddDeserializedBlockFunc: func(block *proto.Block) (*proto.Block, error) {
//				panic("mock out the AddDeserializedBlock method")
//			},
//			AddDeserializedBlocksFunc: func(blocks []*proto.Block) (*proto.Block, error) {
//				panic("mock out the AddDeserializedBlocks method")
//			},
//			AddrByAliasFunc: func(alias proto.Alias) (proto.WavesAddress, error) {
//				panic("mock out the AddrByAlias method")
//			},
//			AliasesByAddrFunc: func(addr proto.WavesAddress) ([]string, error) {
//				panic("mock out the AliasesByAddr method")
//			},
//			AllFeaturesFunc: func() ([]int16, error) {
//				panic("mock out the AllFeatures method")
//			},
//			ApprovalHeightFunc: func(featureID int16) (uint64, error) {
//				panic("mock out the ApprovalHeight method")
//			},
//			AssetBalanceFunc: func(account proto.Recipient, assetID proto.AssetID) (uint64, error) {
//				panic("mock out the AssetBalance method")
//			},
//			AssetInfoFunc: func(assetID proto.AssetID) (*proto.AssetInfo, error) {
//				panic("mock out the AssetInfo method")
//			},
//			AssetIsSponsoredFunc: func(assetID proto.AssetID) (bool, error) {
//				panic("mock out the AssetIsSponsored method")
//			},
//			BlockFunc: func(blockID proto.BlockID) (*proto.Block, error) {
//				panic("mock out the Block method")
//			},
//			BlockByHeightFunc: func(height uint64) (*proto.Block, error) {
//				panic("mock out the BlockByHeight method")
//			},
//			BlockIDToHeightFunc: func(blockID proto.BlockID) (uint64, error) {
//				panic("mock out the BlockIDToHeight method")
//			},
//			BlockchainSettingsFunc: func() (*settings.BlockchainSettings, error) {
//				panic("mock out the BlockchainSettings method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CurrentScoreFunc: func() (*big.Int, error) {
//				panic("mock out the CurrentScore method")
//			},
//			EffectiveBalanceFunc: func(account proto.Recipient, startHeight uint64, endHeight uint64) (uint64, error) {
//				panic("mock out the EffectiveBalance method")
//			},
//			EnrichedFullAssetInfoFunc: func(assetID proto.AssetID) (*proto.EnrichedFullAssetInfo, error) {
//				panic("mock out the EnrichedFullAssetInfo method")
//			},
//			EstimatorVersionFunc: func() (int, error) {
//				panic("mock out the EstimatorVersion method")
//			},
//			FullAssetInfoFunc: func(assetID proto.AssetID) (*proto.FullAssetInfo, error) {
//				panic("mock out the FullAssetInfo method")
//			},
//			FullWavesBalanceFunc: func(account proto.Recipient) (*proto.FullWavesBalance, error) {
//				panic("mock out the FullWavesBalance method")
//			},
//			HeaderFunc: func(blockID proto.BlockID) (*proto.BlockHeader, error) {
//				panic("mock out the Header method")
//			},
//			HeaderByHeightFunc: func(height uint64) (*proto.BlockHeader, error) {
//				panic("mock out the HeaderByHeight method")
//			},
//			HeightFunc: func() (uint64, error) {
//				panic("mock out the Height method")
//			},
//			HeightToBlockIDFunc: func(height uint64) (proto.BlockID, error) {
//				panic("mock out the HeightToBlockID method")
//			},
//			HitSourceAtHeightFunc: func(height uint64) ([]byte, error) {
//				panic("mock out the HitSourceAtHeight method")
//			},
//			InvokeResultByIDFunc: func(invokeID crypto.Digest) (*proto.ScriptResult, error) {
//				panic("mock out the InvokeResultByID method")
//			},
//			IsActivatedFunc: func(featureID int16) (bool, error) {
//				panic("mock out the IsActivated method")
//			},
//			IsActiveAtHeightFunc: func(featureID int16, height uint64) (bool, error) {
//				panic("mock out the IsActiveAtHeight method")
//			},
//			IsActiveLeasingFunc: func(leaseID crypto.Digest) (bool, error) {
//				panic("mock out the IsActiveLeasing method")
//			},
//			IsApprovedFunc: func(featureID int16) (bool, error) {
//				panic("mock out the IsApproved method")
//			},
//			IsApprovedAtHeightFunc: func(featureID int16, height uint64) (bool, error) {
//				panic("mock out the IsApprovedAtHeight method")
//			},
//			IsAssetExistFunc: func(assetID proto.AssetID) (bool, error) {
//				panic("mock out the IsAssetExist method")
//			},
//			LegacyStateHashAtHeightFunc: func(height uint64) (*proto.StateHash, error) {
//				panic("mock out the LegacyStateHashAtHeight method")
//			},
//			MapFunc: func(fn func(state state.State) error) error {
//				panic("mock out the Map method")
//			},
//			MapRFunc: func(fn func(state.StateInfo) (interface{}, error)) (interface{}, error) {
//				panic("mock out the MapR method")
//			},
//			NFTListFunc: func(account proto.Recipient, limit uint64, afterAssetID *proto.AssetID) ([]*proto.FullAssetInfo, error) {
//				panic("mock out the NFTList method")
//			},
//			NewAddrTransactionsIteratorFunc: func(addr proto.Address) (state.TransactionIterator, error) {
//				panic("mock out the NewAddrTransactionsIterator method")
//			},
//			NewestScriptByAccountFunc: func(account proto.Recipient) (*ast.Tree, error) {
//				panic("mock out the NewestScriptByAccount method")
//			},
//			NewestScriptBytesByAccountFunc: func(account proto.Recipient) (proto.Script, error) {
//				panic("mock out the NewestScriptBytesByAccount method")
//			},
//			PersistAddressTransactionsFunc: func() error {
//				panic("mock out the PersistAddressTransactions method")
//			},
//			ProvidesExtendedApiFunc: func() (bool, error) {
//				panic("mock out the ProvidesExtendedApi method")
//			},
//			ProvidesStateHashesFunc: func() (bool, error) {
//				panic("mock out the ProvidesStateHashes method")
//			},
//			ResetValidationListFunc: func()  {
//				panic("mock out the ResetValidationList method")
//			},
//			RetrieveBinaryEntryFunc: func(account proto.Recipient, key string) (*proto.BinaryDataEntry, error) {
//				panic("mock out the RetrieveBinaryEntry method")
//			},
//			RetrieveBooleanEntryFunc: func(account proto.Recipient, key string) (*proto.BooleanDataEntry, error) {
//				panic("mock out the RetrieveBooleanEntry method")
//			},
//			RetrieveEntriesFunc: func(account proto.Recipient) ([]proto.DataEntry, error) {
//				panic("mock out the RetrieveEntries method")
//			},
//			RetrieveEntryFunc: func(account proto.Recipient, key string) (proto.DataEntry, error) {
//				panic("mock out the RetrieveEntry method")
//			},
//			RetrieveIntegerEntryFunc: func(account proto.Recipient, key string) (*proto.IntegerDataEntry, error) {
//				panic("mock out the RetrieveIntegerEntry method")
//			},
//			RetrieveStringEntryFunc: func(account proto.Recipient, key string) (*proto.StringDataEntry, error) {
//				panic("mock out the RetrieveStringEntry method")
//			},
//			RewardAtHeightFunc: func(height uint64) (uint64, error) {
//				panic("mock out the RewardAtHeight method")
//			},
//			RewardVotesFunc: func(height uint64) (proto.RewardVotes, error) {
//				panic("mock out the RewardVotes method")
//			},
//			RollbackToFunc: func(removalEdge proto.BlockID) error {
//				panic("mock out the RollbackTo method")
//			},
//			RollbackToHeightFunc: func(height uint64) error {
//				panic("mock out the RollbackToHeight method")
//			},
//			ScoreAtHeightFunc: func(height uint64) (*big.Int, error) {
//				panic("mock out the ScoreAtHeight method")
//			},
//			ScriptBasicInfoByAccountFunc: func(account proto.Recipient) (*proto.ScriptBasicInfo, error) {
//				panic("mock out the ScriptBasicInfoByAccount method")
//			},
//			ScriptInfoByAccountFunc: func(account proto.Recipient) (*proto.ScriptInfo, error) {
//				panic("mock out the ScriptInfoByAccount method")
//			},
//			ScriptInfoByAssetFunc: func(assetID proto.AssetID) (*proto.ScriptInfo, error) {
//				panic("mock out the ScriptInfoByAsset method")
//			},
//			ShouldPersistAddressTransactionsFunc: func() (bool, error) {
//				panic("mock out the ShouldPersistAddressTransactions method")
//			},
//			SnapshotStateHashAtHeightFunc: func(height uint64) (crypto.Digest, error) {
//				panic("mock out the SnapshotStateHashAtHeight method")
//			},
//			SnapshotsAtHeightFunc: func(height uint64) (proto.BlockSnapshot, error) {
//				panic("mock out the SnapshotsAtHeight method")
//			},
//			StartProvidingExtendedAPIFunc: func() error {
//				panic("mock out the StartProvidingExtendedAPI method")
//			},
//			TopBlockFunc: func() *proto.Block {
//				panic("mock out the TopBlock method")
//			},
//			TotalWavesAmountFunc: func(height uint64) (uint64, error) {
//				panic("mock out the TotalWavesAmount method")
//			},
//			TransactionByIDFunc: func(id []byte) (proto.Transaction, error) {
//				panic("mock out the TransactionByID method")
//			},
//			TransactionByIDWithStatusFunc: func(id []byte) (proto.Transaction, proto.TransactionStatus, error) {
//				panic("mock out the TransactionByIDWithStatus method")
//			},
//			TransactionHeightByIDFunc: func(id []byte) (uint64, error) {
//				panic("mock out the TransactionHeightByID method")
//			},
//			TxValidationFunc: func(fn func(validation state.TxValidation) error) error {
//				panic("mock out the TxValidation method")
//			},
//			ValidateNextTxFunc: func(tx proto.Transaction, currentTimestamp uint64, parentTimestamp uint64, blockVersion proto.BlockVersion, acceptFailed bool) error {
//				panic("mock out the ValidateNextTx method")
//			},
//			VotesNumFunc: func(featureID int16) (uint64, error) {
//				panic("mock out the VotesNum method")
//			},
//			VotesNumAtHeightFunc: func(featureID int16, height uint64) (uint64, error) {
//				panic("mock out the VotesNumAtHeight method")
//			},
//			WavesAddressesNumberFunc: func() (uint64, error) {
//				panic("mock out the WavesAddressesNumber method")
//			},
//			WavesBalanceFunc: func(account proto.Recipient) (uint64, error) {
//				panic("mock out the WavesBalance method")
//			},
//		}
//
//		// use mockedState in code that requires state.State
//		// and then make assertions.
//
//	}
type MockState struct {
	// ActivationHeightFunc mocks the ActivationHeight method.
	ActivationHeightFunc func(featureID int16) (uint64, error)

	// AddBlockFunc mocks the AddBlock method.
	AddBlockFunc func(block []byte) (*proto.Block, error)

	// AddBlocksFunc mocks the AddBlocks method.
	AddBlocksFunc func(blocks [][]byte) error

	// AddDeserializedBlockFunc mocks the AddDeserializedBlock method.
	AddDeserializedBlockFunc func(block *proto.Block) (*proto.Block, error)

	// AddDeserializedBlocksFunc mocks the AddDeserializedBlocks method.
	AddDeserializedBlocksFunc func(blocks []*proto.Block) (*proto.Block, error)

	// AddrByAliasFunc mocks the AddrByAlias method.
	AddrByAliasFunc func(alias proto.Alias) (proto.WavesAddress, error)

	// AliasesByAddrFunc mocks the AliasesByAddr method.
	AliasesByAddrFunc func(addr proto.WavesAddress) ([]string, error)

	// AllFeaturesFunc mocks the AllFeatures method.
	AllFeaturesFunc func() ([]int16, error)

	// ApprovalHeightFunc mocks the ApprovalHeight method.
	ApprovalHeightFunc func(featureID int16) (uint64, error)

	// AssetBalanceFunc mocks the AssetBalance method.
	AssetBalanceFunc func(account proto.Recipient, assetID proto.AssetID) (uint64, error)

	// AssetInfoFunc mocks the AssetInfo method.
	AssetInfoFunc func(assetID proto.AssetID) (*proto.AssetInfo, error)

	// AssetIsSponsoredFunc mocks the AssetIsSponsored method.
	AssetIsSponsoredFunc func(assetID proto.AssetID) (bool, error)

	// BlockFunc mocks the Block method.
	BlockFunc func(blockID proto.BlockID) (*proto.Block, error)

	// BlockByHeightFunc mocks the BlockByHeight method.
	BlockByHeightFunc func(height uint64) (*proto.Block, error)

	// BlockIDToHeightFunc mocks the BlockIDToHeight method.
	BlockIDToHeightFunc func(blockID proto.BlockID) (uint64, error)

	// BlockchainSettingsFunc mocks the BlockchainSettings method.
	BlockchainSettingsFunc func() (*settings.BlockchainSettings, error)

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CurrentScoreFunc mocks the CurrentScore method.
	CurrentScoreFunc func() (*big.Int, error)

	// EffectiveBalanceFunc mocks the EffectiveBalance method.
	EffectiveBalanceFunc func(account proto.Recipient, startHeight uint64, endHeight uint64) (uint64, error)

	// EnrichedFullAssetInfoFunc mocks the EnrichedFullAssetInfo method.
	EnrichedFullAssetInfoFunc func(assetID proto.AssetID) (*proto.EnrichedFullAssetInfo, error)

	// EstimatorVersionFunc mocks the EstimatorVersion method.
	EstimatorVersionFunc func() (int, error)

	// FullAssetInfoFunc mocks the FullAssetInfo method.
	FullAssetInfoFunc func(assetID proto.AssetID) (*proto.FullAssetInfo, error)

	// FullWavesBalanceFunc mocks the FullWavesBalance method.
	FullWavesBalanceFunc func(account proto.Recipient) (*proto.FullWavesBalance, error)

	// HeaderFunc mocks the Header method.
	HeaderFunc func(blockID proto.BlockID) (*proto.BlockHeader, error)

	// HeaderByHeightFunc mocks the HeaderByHeight method.
	HeaderByHeightFunc func(height uint64) (*proto.BlockHeader, error)

	// HeightFunc mocks the Height method.
	HeightFunc func() (uint64, error)

	// HeightToBlockIDFunc mocks the HeightToBlockID method.
	HeightToBlockIDFunc func(height uint64) (proto.BlockID, error)

	// HitSourceAtHeightFunc mocks the HitSourceAtHeight method.
	HitSourceAtHeightFunc func(height uint64) ([]byte, error)

	// InvokeResultByIDFunc mocks the InvokeResultByID method.
	InvokeResultByIDFunc func(invokeID crypto.Digest) (*proto.ScriptResult, error)

	// IsActivatedFunc mocks the IsActivated method.
	IsActivatedFunc func(featureID int16) (bool, error)

	// IsActiveAtHeightFunc mocks the IsActiveAtHeight method.
	IsActiveAtHeightFunc func(featureID int16, height uint64) (bool, error)

	// IsActiveLeasingFunc mocks the IsActiveLeasing method.
	IsActiveLeasingFunc func(leaseID crypto.Digest) (bool, error)

	// IsApprovedFunc mocks the IsApproved method.
	IsApprovedFunc func(featureID int16) (bool, error)

	// IsApprovedAtHeightFunc mocks the IsApprovedAtHeight method.
	IsApprovedAtHeightFunc func(featureID int16, height uint64) (bool, error)

	// IsAssetExistFunc mocks the IsAssetExist method.
	IsAssetExistFunc func(assetID proto.AssetID) (bool, error)

	// LegacyStateHashAtHeightFunc mocks the LegacyStateHashAtHeight method.
	LegacyStateHashAtHeightFunc func(height uint64) (*proto.StateHash, error)

	// MapFunc mocks the Map method.
	MapFunc func(fn func(state state.State) error) error

	// MapRFunc mocks the MapR method.
	MapRFunc func(fn func(state.StateInfo) (interface{}, error)) (interface{}, error)

	// NFTListFunc mocks the NFTList method.
	NFTListFunc func(account proto.Recipient, limit uint64, afterAssetID *proto.AssetID) ([]*proto.FullAssetInfo, error)

	// NewAddrTransactionsIteratorFunc mocks the NewAddrTransactionsIterator method.
	NewAddrTransactionsIteratorFunc func(addr proto.Address) (state.TransactionIterator, error)

	// NewestScriptByAccountFunc mocks the NewestScriptByAccount method.
	NewestScriptByAccountFunc func(account proto.Recipient) (*ast.Tree, error)

	// NewestScriptBytesByAccountFunc mocks the NewestScriptBytesByAccount method.
	NewestScriptBytesByAccountFunc func(account proto.Recipient) (proto.Script, error)

	// PersistAddressTransactionsFunc mocks the PersistAddressTransactions method.
	PersistAddressTransactionsFunc func() error

	// ProvidesExtendedApiFunc mocks the ProvidesExtendedApi method.
	ProvidesExtendedApiFunc func() (bool, error)

	// ProvidesStateHashesFunc mocks the ProvidesStateHashes method.
	ProvidesStateHashesFunc func() (bool, error)

	// ResetValidationListFunc mocks the ResetValidationList method.
	ResetValidationListFunc func()

	// RetrieveBinaryEntryFunc mocks the RetrieveBinaryEntry method.
	RetrieveBinaryEntryFunc func(account proto.Recipient, key string) (*proto.BinaryDataEntry, error)

	// RetrieveBooleanEntryFunc mocks the RetrieveBooleanEntry method.
	RetrieveBooleanEntryFunc func(account proto.Recipient, key string) (*proto.BooleanDataEntry, error)

	// RetrieveEntriesFunc mocks the RetrieveEntries method.
	RetrieveEntriesFunc func(account proto.Recipient) ([]proto.DataEntry, error)

	// RetrieveEntryFunc mocks the RetrieveEntry method.
	RetrieveEntryFunc func(account proto.Recipient, key string) (proto.DataEntry, error)

	// RetrieveIntegerEntryFunc mocks the RetrieveIntegerEntry method.
	RetrieveIntegerEntryFunc func(account proto.Recipient, key string) (*proto.IntegerDataEntry, error)

	// RetrieveStringEntryFunc mocks the RetrieveStringEntry method.
	RetrieveStringEntryFunc func(account proto.Recipient, key string) (*proto.StringDataEntry, error)

	// RewardAtHeightFunc mocks the RewardAtHeight method.
	RewardAtHeightFunc func(height uint64) (uint64, error)

	// RewardVotesFunc mocks the RewardVotes method.
	RewardVotesFunc func(height uint64) (proto.RewardVotes, error)

	// RollbackToFunc mocks the RollbackTo method.
	RollbackToFunc func(removalEdge proto.BlockID) error

	// RollbackToHeightFunc mocks the RollbackToHeight method.
	RollbackToHeightFunc func(height uint64) error

	// ScoreAtHeightFunc mocks the ScoreAtHeight method.
	ScoreAtHeightFunc func(height uint64) (*big.Int, error)

	// ScriptBasicInfoByAccountFunc mocks the ScriptBasicInfoByAccount method.
	ScriptBasicInfoByAccountFunc func(account proto.Recipient) (*proto.ScriptBasicInfo, error)

	// ScriptInfoByAccountFunc mocks the ScriptInfoByAccount method.
	ScriptInfoByAccountFunc func(account proto.Recipient) (*proto.ScriptInfo, error)

	// ScriptInfoByAssetFunc mocks the ScriptInfoByAsset method.
	ScriptInfoByAssetFunc func(assetID proto.AssetID) (*proto.ScriptInfo, error)

	// ShouldPersistAddressTransactionsFunc mocks the ShouldPersistAddressTransactions method.
	ShouldPersistAddressTransactionsFunc func() (bool, error)

	// SnapshotStateHashAtHeightFunc mocks the SnapshotStateHashAtHeight method.
	SnapshotStateHashAtHeightFunc func(height uint64) (crypto.Digest, error)

	// SnapshotsAtHeightFunc mocks the SnapshotsAtHeight method.
	SnapshotsAtHeightFunc func(height uint64) (proto.BlockSnapshot, error)

	// StartProvidingExtendedAPIFunc mocks the StartProvidingExtendedAPI method.
	StartProvidingExtendedAPIFunc func() error

	// TopBlockFunc mocks the TopBlock method.
	TopBlockFunc func() *proto.Block

	// TotalWavesAmountFunc mocks the TotalWavesAmount method.
	TotalWavesAmountFunc func(height uint64) (uint64, error)

	// TransactionByIDFunc mocks the TransactionByID method.
	TransactionByIDFunc func(id []byte) (proto.Transaction, error)

	// TransactionByIDWithStatusFunc mocks the TransactionByIDWithStatus method.
	TransactionByIDWithStatusFunc func(id []byte) (proto.Transaction, proto.TransactionStatus, error)

	// TransactionHeightByIDFunc mocks the TransactionHeightByID method.
	TransactionHeightByIDFunc func(id []byte) (uint64, error)

	// TxValidationFunc mocks the TxValidation method.
	TxValidationFunc func(fn func(validation state.TxValidation) error) error

	// ValidateNextTxFunc mocks the ValidateNextTx method.
	ValidateNextTxFunc func(tx proto.Transaction, currentTimestamp uint64, parentTimestamp uint64, blockVersion proto.BlockVersion, acceptFailed bool) error

	// VotesNumFunc mocks the VotesNum method.
	VotesNumFunc func(featureID int16) (uint64, error)

	// VotesNumAtHeightFunc mocks the VotesNumAtHeight method.
	VotesNumAtHeightFunc func(featureID int16, height uint64) (uint64, error)

	// WavesAddressesNumberFunc mocks the WavesAddressesNumber method.
	WavesAddressesNumberFunc func() (uint64, error)

	// WavesBalanceFunc mocks the WavesBalance method.
	WavesBalanceFunc func(account proto.Recipient) (uint64, error)

	// calls tracks calls to the methods.
	calls struct {
		// ActivationHeight holds details about calls to the ActivationHeight method.
		ActivationHeight []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
		}
		// AddBlock holds details about calls to the AddBlock method.
		AddBlock []struct {
			// Block is the block argument value.
			Block []byte
		}
		// AddBlocks holds details about calls to the AddBlocks method.
		AddBlocks []struct {
			// Blocks is the blocks argument value.
			Blocks [][]byte
		}
		// AddDeserializedBlock holds details about calls to the AddDeserializedBlock method.
		AddDeserializedBlock []struct {
			// Block is the block argument value.
			Block *proto.Block
		}
		// AddDeserializedBlocks holds details about calls to the AddDeserializedBlocks method.
		AddDeserializedBlocks []struct {
			// Blocks is the blocks argument value.
			Blocks []*proto.Block
		}
		// AddrByAlias holds details about calls to the AddrByAlias method.
		AddrByAlias []struct {
			// Alias is the alias argument value.
			Alias proto.Alias
		}
		// AliasesByAddr holds details about calls to the AliasesByAddr method.
		AliasesByAddr []struct {
			// Addr is the addr argument value.
			Addr proto.WavesAddress
		}
		// AllFeatures holds details about calls to the AllFeatures method.
		AllFeatures []struct {
		}
		// ApprovalHeight holds details about calls to the ApprovalHeight method.
		ApprovalHeight []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
		}
		// AssetBalance holds details about calls to the AssetBalance method.
		AssetBalance []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// AssetInfo holds details about calls to the AssetInfo method.
		AssetInfo []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// AssetIsSponsored holds details about calls to the AssetIsSponsored method.
		AssetIsSponsored []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// Block holds details about calls to the Block method.
		Block []struct {
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// BlockByHeight holds details about calls to the BlockByHeight method.
		BlockByHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// BlockIDToHeight holds details about calls to the BlockIDToHeight method.
		BlockIDToHeight []struct {
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// BlockchainSettings holds details about calls to the BlockchainSettings method.
		BlockchainSettings []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CurrentScore holds details about calls to the CurrentScore method.
		CurrentScore []struct {
		}
		// EffectiveBalance holds details about calls to the EffectiveBalance method.
		EffectiveBalance []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// StartHeight is the startHeight argument value.
			StartHeight uint64
			// EndHeight is the endHeight argument value.
			EndHeight uint64
		}
		// EnrichedFullAssetInfo holds details about calls to the EnrichedFullAssetInfo method.
		EnrichedFullAssetInfo []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// EstimatorVersion holds details about calls to the EstimatorVersion method.
		EstimatorVersion []struct {
		}
		// FullAssetInfo holds details about calls to the FullAssetInfo method.
		FullAssetInfo []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// FullWavesBalance holds details about calls to the FullWavesBalance method.
		FullWavesBalance []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
		// Header holds details about calls to the Header method.
		Header []struct {
			// BlockID is the blockID argument value.
			BlockID proto.BlockID
		}
		// HeaderByHeight holds details about calls to the HeaderByHeight method.
		HeaderByHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// Height holds details about calls to the Height method.
		Height []struct {
		}
		// HeightToBlockID holds details about calls to the HeightToBlockID method.
		HeightToBlockID []struct {
			// Height is the height argument value.
			Height uint64
		}
		// HitSourceAtHeight holds details about calls to the HitSourceAtHeight method.
		HitSourceAtHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// InvokeResultByID holds details about calls to the InvokeResultByID method.
		InvokeResultByID []struct {
			// InvokeID is the invokeID argument value.
			InvokeID crypto.Digest
		}
		// IsActivated holds details about calls to the IsActivated method.
		IsActivated []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
		}
		// IsActiveAtHeight holds details about calls to the IsActiveAtHeight method.
		IsActiveAtHeight []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
			// Height is the height argument value.
			Height uint64
		}
		// IsActiveLeasing holds details about calls to the IsActiveLeasing method.
		IsActiveLeasing []struct {
			// LeaseID is the leaseID argument value.
			LeaseID crypto.Digest
		}
		// IsApproved holds details about calls to the IsApproved method.
		IsApproved []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
		}
		// IsApprovedAtHeight holds details about calls to the IsApprovedAtHeight method.
		IsApprovedAtHeight []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
			// Height is the height argument value.
			Height uint64
		}
		// IsAssetExist holds details about calls to the IsAssetExist method.
		IsAssetExist []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// LegacyStateHashAtHeight holds details about calls to the LegacyStateHashAtHeight method.
		LegacyStateHashAtHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// Map holds details about calls to the Map method.
		Map []struct {
			// Fn is the fn argument value.
			Fn func(state state.State) error
		}
		// MapR holds details about calls to the MapR method.
		MapR []struct {
			// Fn is the fn argument value.
			Fn func(state.StateInfo) (interface{}, error)
		}
		// NFTList holds details about calls to the NFTList method.
		NFTList []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// Limit is the limit argument value.
			Limit uint64
			// AfterAssetID is the afterAssetID argument value.
			AfterAssetID *proto.AssetID
		}
		// NewAddrTransactionsIterator holds details about calls to the NewAddrTransactionsIterator method.
		NewAddrTransactionsIterator []struct {
			// Addr is the addr argument value.
			Addr proto.Address
		}
		// NewestScriptByAccount holds details about calls to the NewestScriptByAccount method.
		NewestScriptByAccount []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
		// NewestScriptBytesByAccount holds details about calls to the NewestScriptBytesByAccount method.
		NewestScriptBytesByAccount []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
		// PersistAddressTransactions holds details about calls to the PersistAddressTransactions method.
		PersistAddressTransactions []struct {
		}
		// ProvidesExtendedApi holds details about calls to the ProvidesExtendedApi method.
		ProvidesExtendedApi []struct {
		}
		// ProvidesStateHashes holds details about calls to the ProvidesStateHashes method.
		ProvidesStateHashes []struct {
		}
		// ResetValidationList holds details about calls to the ResetValidationList method.
		ResetValidationList []struct {
		}
		// RetrieveBinaryEntry holds details about calls to the RetrieveBinaryEntry method.
		RetrieveBinaryEntry []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// Key is the key argument value.
			Key string
		}
		// RetrieveBooleanEntry holds details about calls to the RetrieveBooleanEntry method.
		RetrieveBooleanEntry []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// Key is the key argument value.
			Key string
		}
		// RetrieveEntries holds details about calls to the RetrieveEntries method.
		RetrieveEntries []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
		// RetrieveEntry holds details about calls to the RetrieveEntry method.
		RetrieveEntry []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// Key is the key argument value.
			Key string
		}
		// RetrieveIntegerEntry holds details about calls to the RetrieveIntegerEntry method.
		RetrieveIntegerEntry []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// Key is the key argument value.
			Key string
		}
		// RetrieveStringEntry holds details about calls to the RetrieveStringEntry method.
		RetrieveStringEntry []struct {
			// Account is the account argument value.
			Account proto.Recipient
			// Key is the key argument value.
			Key string
		}
		// RewardAtHeight holds details about calls to the RewardAtHeight method.
		RewardAtHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// RewardVotes holds details about calls to the RewardVotes method.
		RewardVotes []struct {
			// Height is the height argument value.
			Height uint64
		}
		// RollbackTo holds details about calls to the RollbackTo method.
		RollbackTo []struct {
			// RemovalEdge is the removalEdge argument value.
			RemovalEdge proto.BlockID
		}
		// RollbackToHeight holds details about calls to the RollbackToHeight method.
		RollbackToHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// ScoreAtHeight holds details about calls to the ScoreAtHeight method.
		ScoreAtHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// ScriptBasicInfoByAccount holds details about calls to the ScriptBasicInfoByAccount method.
		ScriptBasicInfoByAccount []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
		// ScriptInfoByAccount holds details about calls to the ScriptInfoByAccount method.
		ScriptInfoByAccount []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
		// ScriptInfoByAsset holds details about calls to the ScriptInfoByAsset method.
		ScriptInfoByAsset []struct {
			// AssetID is the assetID argument value.
			AssetID proto.AssetID
		}
		// ShouldPersistAddressTransactions holds details about calls to the ShouldPersistAddressTransactions method.
		ShouldPersistAddressTransactions []struct {
		}
		// SnapshotStateHashAtHeight holds details about calls to the SnapshotStateHashAtHeight method.
		SnapshotStateHashAtHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// SnapshotsAtHeight holds details about calls to the SnapshotsAtHeight method.
		SnapshotsAtHeight []struct {
			// Height is the height argument value.
			Height uint64
		}
		// StartProvidingExtendedAPI holds details about calls to the StartProvidingExtendedAPI method.
		StartProvidingExtendedAPI []struct {
		}
		// TopBlock holds details about calls to the TopBlock method.
		TopBlock []struct {
		}
		// TotalWavesAmount holds details about calls to the TotalWavesAmount method.
		TotalWavesAmount []struct {
			// Height is the height argument value.
			Height uint64
		}
		// TransactionByID holds details about calls to the TransactionByID method.
		TransactionByID []struct {
			// ID is the id argument value.
			ID []byte
		}
		// TransactionByIDWithStatus holds details about calls to the TransactionByIDWithStatus method.
		TransactionByIDWithStatus []struct {
			// ID is the id argument value.
			ID []byte
		}
		// TransactionHeightByID holds details about calls to the TransactionHeightByID method.
		TransactionHeightByID []struct {
			// ID is the id argument value.
			ID []byte
		}
		// TxValidation holds details about calls to the TxValidation method.
		TxValidation []struct {
			// Fn is the fn argument value.
			Fn func(validation state.TxValidation) error
		}
		// ValidateNextTx holds details about calls to the ValidateNextTx method.
		ValidateNextTx []struct {
			// Tx is the tx argument value.
			Tx proto.Transaction
			// CurrentTimestamp is the currentTimestamp argument value.
			CurrentTimestamp uint64
			// ParentTimestamp is the parentTimestamp argument value.
			ParentTimestamp uint64
			// BlockVersion is the blockVersion argument value.
			BlockVersion proto.BlockVersion
			// AcceptFailed is the acceptFailed argument value.
			AcceptFailed bool
		}
		// VotesNum holds details about calls to the VotesNum method.
		VotesNum []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
		}
		// VotesNumAtHeight holds details about calls to the VotesNumAtHeight method.
		VotesNumAtHeight []struct {
			// FeatureID is the featureID argument value.
			FeatureID int16
			// Height is the height argument value.
			Height uint64
		}
		// WavesAddressesNumber holds details about calls to the WavesAddressesNumber method.
		WavesAddressesNumber []struct {
		}
		// WavesBalance holds details about calls to the WavesBalance method.
		WavesBalance []struct {
			// Account is the account argument value.
			Account proto.Recipient
		}
	}
	lockActivationHeight                 sync.RWMutex
	lockAddBlock                         sync.RWMutex
	lockAddBlocks                        sync.RWMutex
	lockAddDeserializedBlock             sync.RWMutex
	lockAddDeserializedBlocks            sync.RWMutex
	lockAddrByAlias                      sync.RWMutex
	lockAliasesByAddr                    sync.RWMutex
	lockAllFeatures                      sync.RWMutex
	lockApprovalHeight                   sync.RWMutex
	lockAssetBalance                     sync.RWMutex
	lockAssetInfo                        sync.RWMutex
	lockAssetIsSponsored                 sync.RWMutex
	lockBlock                            sync.RWMutex
	lockBlockByHeight                    sync.RWMutex
	lockBlockIDToHeight                  sync.RWMutex
	lockBlockchainSettings               sync.RWMutex
	lockClose                            sync.RWMutex
	lockCurrentScore                     sync.RWMutex
	lockEffectiveBalance                 sync.RWMutex
	lockEnrichedFullAssetInfo            sync.RWMutex
	lockEstimatorVersion                 sync.RWMutex
	lockFullAssetInfo                    sync.RWMutex
	lockFullWavesBalance                 sync.RWMutex
	lockHeader                           sync.RWMutex
	lockHeaderByHeight                   sync.RWMutex
	lockHeight                           sync.RWMutex
	lockHeightToBlockID                  sync.RWMutex
	lockHitSourceAtHeight                sync.RWMutex
	lockInvokeResultByID                 sync.RWMutex
	lockIsActivated                      sync.RWMutex
	lockIsActiveAtHeight                 sync.RWMutex
	lockIsActiveLeasing                  sync.RWMutex
	lockIsApproved                       sync.RWMutex
	lockIsApprovedAtHeight               sync.RWMutex
	lockIsAssetExist                     sync.RWMutex
	lockLegacyStateHashAtHeight          sync.RWMutex
	lockMap                              sync.RWMutex
	lockMapR                             sync.RWMutex
	lockNFTList                          sync.RWMutex
	lockNewAddrTransactionsIterator      sync.RWMutex
	lockNewestScriptByAccount            sync.RWMutex
	lockNewestScriptBytesByAccount       sync.RWMutex
	lockPersistAddressTransactions       sync.RWMutex
	lockProvidesExtendedApi              sync.RWMutex
	lockProvidesStateHashes              sync.RWMutex
	lockResetValidationList              sync.RWMutex
	lockRetrieveBinaryEntry              sync.RWMutex
	lockRetrieveBooleanEntry             sync.RWMutex
	lockRetrieveEntries                  sync.RWMutex
	lockRetrieveEntry                    sync.RWMutex
	lockRetrieveIntegerEntry             sync.RWMutex
	lockRetrieveStringEntry              sync.RWMutex
	lockRewardAtHeight                   sync.RWMutex
	lockRewardVotes                      sync.RWMutex
	lockRollbackTo                       sync.RWMutex
	lockRollbackToHeight                 sync.RWMutex
	lockScoreAtHeight                    sync.RWMutex
	lockScriptBasicInfoByAccount         sync.RWMutex
	lockScriptInfoByAccount              sync.RWMutex
	lockScriptInfoByAsset                sync.RWMutex
	lockShouldPersistAddressTransactions sync.RWMutex
	lockSnapshotStateHashAtHeight        sync.RWMutex
	lockSnapshotsAtHeight                sync.RWMutex
	lockStartProvidingExtendedAPI        sync.RWMutex
	lockTopBlock                         sync.RWMutex
	lockTotalWavesAmount                 sync.RWMutex
	lockTransactionByID                  sync.RWMutex
	lockTransactionByIDWithStatus        sync.RWMutex
	lockTransactionHeightByID            sync.RWMutex
	lockTxValidation                     sync.RWMutex
	lockValidateNextTx                   sync.RWMutex
	lockVotesNum                         sync.RWMutex
	lockVotesNumAtHeight                 sync.RWMutex
	lockWavesAddressesNumber             sync.RWMutex
	lockWavesBalance                     sync.RWMutex
}

// ActivationHeight calls ActivationHeightFunc.
func (mock *MockState) ActivationHeight(featureID int16) (uint64, error) {
	if mock.ActivationHeightFunc == nil {
		panic("MockState.ActivationHeightFunc: method is nil but State.ActivationHeight was just called")
	}
	callInfo := struct {
		FeatureID int16
	}{
		FeatureID: featureID,
	}
	mock.lockActivationHeight.Lock()
	mock.calls.ActivationHeight = append(mock.calls.ActivationHeight, callInfo)
	mock.lockActivationHeight.Unlock()
	return mock.ActivationHeightFunc(featureID)
}

// ActivationHeightCalls gets all the calls that were made to ActivationHeight.
// Check the length with:
//
//	len(mockedState.ActivationHeightCalls())
func (mock *MockState) ActivationHeightCalls() []struct {
	FeatureID int16
} {
	var calls []struct {
		FeatureID int16
	}
	mock.lockActivationHeight.RLock()
	calls = mock.calls.ActivationHeight
	mock.lockActivationHeight.RUnlock()
	return calls
}

// AddBlock calls AddBlockFunc.
func (mock *MockState) AddBlock(block []byte) (*proto.Block, error) {
	if mock.AddBlockFunc == nil {
		panic("MockState.AddBlockFunc: method is nil but State.AddBlock was just called")
	}
	callInfo := struct {
		Block []byte
	}{
		Block: block,
	}
	mock.lockAddBlock.Lock()
	mock.calls.AddBlock = append(mock.calls.AddBlock, callInfo)
	mock.lockAddBlock.Unlock()
	return mock.AddBlockFunc(block)
}

// AddBlockCalls gets all the calls that were made to AddBlock.
// Check the length with:
//
//	len(mockedState.AddBlockCalls())
func (mock *MockState) AddBlockCalls() []struct {
	Block []byte
} {
	var calls []struct {
		Block []byte
	}
	mock.lockAddBlock.RLock()
	calls = mock.calls.AddBlock
	mock.lockAddBlock.RUnlock()
	return calls
}

// AddBlocks calls AddBlocksFunc.
func (mock *MockState) AddBlocks(blocks [][]byte) error {
	if mock.AddBlocksFunc == nil {
		panic("MockState.AddBlocksFunc: method is nil but State.AddBlocks was just called")
	}
	callInfo := struct {
		Blocks [][]byte
	}{
		Blocks: blocks,
	}
	mock.lockAddBlocks.Lock()
	mock.calls.AddBlocks = append(mock.calls.AddBlocks, callInfo)
	mock.lockAddBlocks.Unlock()
	return mock.AddBlocksFunc(blocks)
}

// AddBlocksCalls gets all the calls that were made to AddBlocks.
// Check the length with:
//
//	len(mockedState.AddBlocksCalls())
func (mock *MockState) AddBlocksCalls() []struct {
	Blocks [][]byte
} {
	var calls []struct {
		Blocks [][]byte
	}
	mock.lockAddBlocks.RLock()
	calls = mock.calls.AddBlocks
	mock.lockAddBlocks.RUnlock()
	return calls
}

// AddDeserializedBlock calls AddDeserializedBlockFunc.
func (mock *MockState) AddDeserializedBlock(block *proto.Block) (*proto.Block, error) {
	if mock.AddDeserializedBlockFunc == nil {
		panic("MockState.AddDeserializedBlockFunc: method is nil but State.AddDeserializedBlock was just called")
	}
	callInfo := struct {
		Block *proto.Block
	}{
		Block: block,
	}
	mock.lockAddDeserializedBlock.Lock()
	mock.calls.AddDeserializedBlock = append(mock.calls.AddDeserializedBlock, callInfo)
	mock.lockAddDeserializedBlock.Unlock()
	return mock.AddDeserializedBlockFunc(block)
}

// AddDeserializedBlockCalls gets all the calls that were made to AddDeserializedBlock.
// Check the length with:
//
//	len(mockedState.AddDeserializedBlockCalls())
func (mock *MockState) AddDeserializedBlockCalls() []struct {
	Block *proto.Block
} {
	var calls []struct {
		Block *proto.Block
	}
	mock.lockAddDeserializedBlock.RLock()
	calls = mock.calls.AddDeserializedBlock
	mock.lockAddDeserializedBlock.RUnlock()
	return calls
}

// AddDeserializedBlocks calls AddDeserializedBlocksFunc.
func (mock *MockState) AddDeserializedBlocks(blocks []*proto.Block) (*proto.Block, error) {
	if mock.AddDeserializedBlocksFunc == nil {
		panic("MockState.AddDeserializedBlocksFunc: method is nil but State.AddDeserializedBlocks was just called")
	}
	callInfo := struct {
		Blocks []*proto.Block
	}{
		Blocks: blocks,
	}
	mock.lockAddDeserializedBlocks.Lock()
	mock.calls.AddDeserializedBlocks = append(mock.calls.AddDeserializedBlocks, callInfo)
	mock.lockAddDeserializedBlocks.Unlock()
	return mock.AddDeserializedBlocksFunc(blocks)
}

// AddDeserializedBlocksCalls gets all the calls that were made to AddDeserializedBlocks.
// Check the length with:
//
//	len(mockedState.AddDeserializedBlocksCalls())
func (mock *MockState) AddDeserializedBlocksCalls() []struct {
	Blocks []*proto.Block
} {
	var calls []struct {
		Blocks []*proto.Block
	}
	mock.lockAddDeserializedBlocks.RLock()
	calls = mock.calls.AddDeserializedBlocks
	mock.lockAddDeserializedBlocks.RUnlock()
	return calls
}

// AddrByAlias calls AddrByAliasFunc.
func (mock *MockState) AddrByAlias(alias proto.Alias) (proto.WavesAddress, error) {
	if mock.AddrByAliasFunc == nil {
		panic("MockState.AddrByAliasFunc: method is nil but State.AddrByAlias was just called")
	}
	callInfo := struct {
		Alias proto.Alias
	}{
		Alias: alias,
	}
	mock.lockAddrByAlias.Lock()
	mock.calls.AddrByAlias = append(mock.calls.AddrByAlias, callInfo)
	mock.lockAddrByAlias.Unlock()
	return mock.AddrByAliasFunc(alias)
}

// AddrByAliasCalls gets all the calls that were made to AddrByAlias.
// Check the length with:
//
//	len(mockedState.AddrByAliasCalls())
func (mock *MockState) AddrByAliasCalls() []struct {
	Alias proto.Alias
} {
	var calls []struct {
		Alias proto.Alias
	}
	mock.lockAddrByAlias.RLock()
	calls = mock.calls.AddrByAlias
	mock.lockAddrByAlias.RUnlock()
	return calls
}

// AliasesByAddr calls AliasesByAddrFunc.
func (mock *MockState) AliasesByAddr(addr proto.WavesAddress) ([]string, error) {
	if mock.AliasesByAddrFunc == nil {
		panic("MockState.AliasesByAddrFunc: method is nil but State.AliasesByAddr was just called")
	}
	callInfo := struct {
		Addr proto.WavesAddress
	}{
		Addr: addr,
	}
	mock.lockAliasesByAddr.Lock()
	mock.calls.AliasesByAddr = append(mock.calls.AliasesByAddr, callInfo)
	mock.lockAliasesByAddr.Unlock()
	return mock.AliasesByAddrFunc(addr)
}

// AliasesByAddrCalls gets all the calls that were made to AliasesByAddr.
// Check the length with:
//
//	len(mockedState.AliasesByAddrCalls())
func (mock *MockState) AliasesByAddrCalls() []struct {
	Addr proto.WavesAddress
} {
	var calls []struct {
		Addr proto.WavesAddress
	}
	mock.lockAliasesByAddr.RLock()
	calls = mock.calls.AliasesByAddr
	mock.lockAliasesByAddr.RUnlock()
	return calls
}

// AllFeatures calls AllFeaturesFunc.
func (mock *MockState) AllFeatures() ([]int16, error) {
	if mock.AllFeaturesFunc == nil {
		panic("MockState.AllFeaturesFunc: method is nil but State.AllFeatures was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAllFeatures.Lock()
	mock.calls.AllFeatures = append(mock.calls.AllFeatures, callInfo)
	mock.lockAllFeatures.Unlock()
	return mock.AllFeaturesFunc()
}

// AllFeaturesCalls gets all the calls that were made to AllFeatures.
// Check the length with:
//
//	len(mockedState.AllFeaturesCalls())
func (mock *MockState) AllFeaturesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAllFeatures.RLock()
	calls = mock.calls.AllFeatures
	mock.lockAllFeatures.RUnlock()
	return calls
}

// ApprovalHeight calls ApprovalHeightFunc.
func (mock *MockState) ApprovalHeight(featureID int16) (uint64, error) {
	if mock.ApprovalHeightFunc == nil {
		panic("MockState.ApprovalHeightFunc: method is nil but State.ApprovalHeight was just called")
	}
	callInfo := struct {
		FeatureID int16
	}{
		FeatureID: featureID,
	}
	mock.lockApprovalHeight.Lock()
	mock.calls.ApprovalHeight = append(mock.calls.ApprovalHeight, callInfo)
	mock.lockApprovalHeight.Unlock()
	return mock.ApprovalHeightFunc(featureID)
}

// ApprovalHeightCalls gets all the calls that were made to ApprovalHeight.
// Check the length with:
//
//	len(mockedState.ApprovalHeightCalls())
func (mock *MockState) ApprovalHeightCalls() []struct {
	FeatureID int16
} {
	var calls []struct {
		FeatureID int16
	}
	mock.lockApprovalHeight.RLock()
	calls = mock.calls.ApprovalHeight
	mock.lockApprovalHeight.RUnlock()
	return calls
}

// AssetBalance calls AssetBalanceFunc.
func (mock *MockState) AssetBalance(account proto.Recipient, assetID proto.AssetID) (uint64, error) {
	if mock.AssetBalanceFunc == nil {
		panic("MockState.AssetBalanceFunc: method is nil but State.AssetBalance was just called")
	}
	callInfo := struct {
		Account proto.Recipient
		AssetID proto.AssetID
	}{
		Account: account,
		AssetID: assetID,
	}
	mock.lockAssetBalance.Lock()
	mock.calls.AssetBalance = append(mock.calls.AssetBalance, callInfo)
	mock.lockAssetBalance.Unlock()
	return mock.AssetBalanceFunc(account, assetID)
}

// AssetBalanceCalls gets all the calls that were made to AssetBalance.
// Check the length with:
//
//	len(mockedState.AssetBalanceCalls())
func (mock *MockState) AssetBalanceCalls() []struct {
	Account proto.Recipient
	AssetID proto.AssetID
} {
	var calls []struct {
		Account proto.Recipient
		AssetID proto.AssetID
	}
	mock.lockAssetBalance.RLock()
	calls = mock.calls.AssetBalance
	mock.lockAssetBalance.RUnlock()
	return calls
}

// AssetInfo calls AssetInfoFunc.
func (mock *MockState) AssetInfo(assetID proto.AssetID) (*proto.AssetInfo, error) {
	if mock.AssetInfoFunc == nil {
		panic("MockState.AssetInfoFunc: method is nil but State.AssetInfo was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockAssetInfo.Lock()
	mock.calls.AssetInfo = append(mock.calls.AssetInfo, callInfo)
	mock.lockAssetInfo.Unlock()
	return mock.AssetInfoFunc(assetID)
}

// AssetInfoCalls gets all the calls that were made to AssetInfo.
// Check the length with:
//
//	len(mockedState.AssetInfoCalls())
func (mock *MockState) AssetInfoCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockAssetInfo.RLock()
	calls = mock.calls.AssetInfo
	mock.lockAssetInfo.RUnlock()
	return calls
}

// AssetIsSponsored calls AssetIsSponsoredFunc.
func (mock *MockState) AssetIsSponsored(assetID proto.AssetID) (bool, error) {
	if mock.AssetIsSponsoredFunc == nil {
		panic("MockState.AssetIsSponsoredFunc: method is nil but State.AssetIsSponsored was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockAssetIsSponsored.Lock()
	mock.calls.AssetIsSponsored = append(mock.calls.AssetIsSponsored, callInfo)
	mock.lockAssetIsSponsored.Unlock()
	return mock.AssetIsSponsoredFunc(assetID)
}

// AssetIsSponsoredCalls gets all the calls that were made to AssetIsSponsored.
// Check the length with:
//
//	len(mockedState.AssetIsSponsoredCalls())
func (mock *MockState) AssetIsSponsoredCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockAssetIsSponsored.RLock()
	calls = mock.calls.AssetIsSponsored
	mock.lockAssetIsSponsored.RUnlock()
	return calls
}

// Block calls BlockFunc.
func (mock *MockState) Block(blockID proto.BlockID) (*proto.Block, error) {
	if mock.BlockFunc == nil {
		panic("MockState.BlockFunc: method is nil but State.Block was just called")
	}
	callInfo := struct {
		BlockID proto.BlockID
	}{
		BlockID: blockID,
	}
	mock.lockBlock.Lock()
	mock.calls.Block = append(mock.calls.Block, callInfo)
	mock.lockBlock.Unlock()
	return mock.BlockFunc(blockID)
}

// BlockCalls gets all the calls that were made to Block.
// Check the length with:
//
//	len(mockedState.BlockCalls())
func (mock *MockState) BlockCalls() []struct {
	BlockID proto.BlockID
} {
	var calls []struct {
		BlockID proto.BlockID
	}
	mock.lockBlock.RLock()
	calls = mock.calls.Block
	mock.lockBlock.RUnlock()
	return calls
}

// BlockByHeight calls BlockByHeightFunc.
func (mock *MockState) BlockByHeight(height uint64) (*proto.Block, error) {
	if mock.BlockByHeightFunc == nil {
		panic("MockState.BlockByHeightFunc: method is nil but State.BlockByHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockBlockByHeight.Lock()
	mock.calls.BlockByHeight = append(mock.calls.BlockByHeight, callInfo)
	mock.lockBlockByHeight.Unlock()
	return mock.BlockByHeightFunc(height)
}

// BlockByHeightCalls gets all the calls that were made to BlockByHeight.
// Check the length with:
//
//	len(mockedState.BlockByHeightCalls())
func (mock *MockState) BlockByHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockBlockByHeight.RLock()
	calls = mock.calls.BlockByHeight
	mock.lockBlockByHeight.RUnlock()
	return calls
}

// BlockIDToHeight calls BlockIDToHeightFunc.
func (mock *MockState) BlockIDToHeight(blockID proto.BlockID) (uint64, error) {
	if mock.BlockIDToHeightFunc == nil {
		panic("MockState.BlockIDToHeightFunc: method is nil but State.BlockIDToHeight was just called")
	}
	callInfo := struct {
		BlockID proto.BlockID
	}{
		BlockID: blockID,
	}
	mock.lockBlockIDToHeight.Lock()
	mock.calls.BlockIDToHeight = append(mock.calls.BlockIDToHeight, callInfo)
	mock.lockBlockIDToHeight.Unlock()
	return mock.BlockIDToHeightFunc(blockID)
}

// BlockIDToHeightCalls gets all the calls that were made to BlockIDToHeight.
// Check the length with:
//
//	len(mockedState.BlockIDToHeightCalls())
func (mock *MockState) BlockIDToHeightCalls() []struct {
	BlockID proto.BlockID
} {
	var calls []struct {
		BlockID proto.BlockID
	}
	mock.lockBlockIDToHeight.RLock()
	calls = mock.calls.BlockIDToHeight
	mock.lockBlockIDToHeight.RUnlock()
	return calls
}

// BlockchainSettings calls BlockchainSettingsFunc.
func (mock *MockState) BlockchainSettings() (*settings.BlockchainSettings, error) {
	if mock.BlockchainSettingsFunc == nil {
		panic("MockState.BlockchainSettingsFunc: method is nil but State.BlockchainSettings was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlockchainSettings.Lock()
	mock.calls.BlockchainSettings = append(mock.calls.BlockchainSettings, callInfo)
	mock.lockBlockchainSettings.Unlock()
	return mock.BlockchainSettingsFunc()
}

// BlockchainSettingsCalls gets all the calls that were made to BlockchainSettings.
// Check the length with:
//
//	len(mockedState.BlockchainSettingsCalls())
func (mock *MockState) BlockchainSettingsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlockchainSettings.RLock()
	calls = mock.calls.BlockchainSettings
	mock.lockBlockchainSettings.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *MockState) Close() error {
	if mock.CloseFunc == nil {
		panic("MockState.CloseFunc: method is nil but State.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedState.CloseCalls())
func (mock *MockState) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CurrentScore calls CurrentScoreFunc.
func (mock *MockState) CurrentScore() (*big.Int, error) {
	if mock.CurrentScoreFunc == nil {
		panic("MockState.CurrentScoreFunc: method is nil but State.CurrentScore was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCurrentScore.Lock()
	mock.calls.CurrentScore = append(mock.calls.CurrentScore, callInfo)
	mock.lockCurrentScore.Unlock()
	return mock.CurrentScoreFunc()
}

// CurrentScoreCalls gets all the calls that were made to CurrentScore.
// Check the length with:
//
//	len(mockedState.CurrentScoreCalls())
func (mock *MockState) CurrentScoreCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCurrentScore.RLock()
	calls = mock.calls.CurrentScore
	mock.lockCurrentScore.RUnlock()
	return calls
}

// EffectiveBalance calls EffectiveBalanceFunc.
func (mock *MockState) EffectiveBalance(account proto.Recipient, startHeight uint64, endHeight uint64) (uint64, error) {
	if mock.EffectiveBalanceFunc == nil {
		panic("MockState.EffectiveBalanceFunc: method is nil but State.EffectiveBalance was just called")
	}
	callInfo := struct {
		Account     proto.Recipient
		StartHeight uint64
		EndHeight   uint64
	}{
		Account:     account,
		StartHeight: startHeight,
		EndHeight:   endHeight,
	}
	mock.lockEffectiveBalance.Lock()
	mock.calls.EffectiveBalance = append(mock.calls.EffectiveBalance, callInfo)
	mock.lockEffectiveBalance.Unlock()
	return mock.EffectiveBalanceFunc(account, startHeight, endHeight)
}

// EffectiveBalanceCalls gets all the calls that were made to EffectiveBalance.
// Check the length with:
//
//	len(mockedState.EffectiveBalanceCalls())
func (mock *MockState) EffectiveBalanceCalls() []struct {
	Account     proto.Recipient
	StartHeight uint64
	EndHeight   uint64
} {
	var calls []struct {
		Account     proto.Recipient
		StartHeight uint64
		EndHeight   uint64
	}
	mock.lockEffectiveBalance.RLock()
	calls = mock.calls.EffectiveBalance
	mock.lockEffectiveBalance.RUnlock()
	return calls
}

// EnrichedFullAssetInfo calls EnrichedFullAssetInfoFunc.
func (mock *MockState) EnrichedFullAssetInfo(assetID proto.AssetID) (*proto.EnrichedFullAssetInfo, error) {
	if mock.EnrichedFullAssetInfoFunc == nil {
		panic("MockState.EnrichedFullAssetInfoFunc: method is nil but State.EnrichedFullAssetInfo was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockEnrichedFullAssetInfo.Lock()
	mock.calls.EnrichedFullAssetInfo = append(mock.calls.EnrichedFullAssetInfo, callInfo)
	mock.lockEnrichedFullAssetInfo.Unlock()
	return mock.EnrichedFullAssetInfoFunc(assetID)
}

// EnrichedFullAssetInfoCalls gets all the calls that were made to EnrichedFullAssetInfo.
// Check the length with:
//
//	len(mockedState.EnrichedFullAssetInfoCalls())
func (mock *MockState) EnrichedFullAssetInfoCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockEnrichedFullAssetInfo.RLock()
	calls = mock.calls.EnrichedFullAssetInfo
	mock.lockEnrichedFullAssetInfo.RUnlock()
	return calls
}

// EstimatorVersion calls EstimatorVersionFunc.
func (mock *MockState) EstimatorVersion() (int, error) {
	if mock.EstimatorVersionFunc == nil {
		panic("MockState.EstimatorVersionFunc: method is nil but State.EstimatorVersion was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEstimatorVersion.Lock()
	mock.calls.EstimatorVersion = append(mock.calls.EstimatorVersion, callInfo)
	mock.lockEstimatorVersion.Unlock()
	return mock.EstimatorVersionFunc()
}

// EstimatorVersionCalls gets all the calls that were made to EstimatorVersion.
// Check the length with:
//
//	len(mockedState.EstimatorVersionCalls())
func (mock *MockState) EstimatorVersionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEstimatorVersion.RLock()
	calls = mock.calls.EstimatorVersion
	mock.lockEstimatorVersion.RUnlock()
	return calls
}

// FullAssetInfo calls FullAssetInfoFunc.
func (mock *MockState) FullAssetInfo(assetID proto.AssetID) (*proto.FullAssetInfo, error) {
	if mock.FullAssetInfoFunc == nil {
		panic("MockState.FullAssetInfoFunc: method is nil but State.FullAssetInfo was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockFullAssetInfo.Lock()
	mock.calls.FullAssetInfo = append(mock.calls.FullAssetInfo, callInfo)
	mock.lockFullAssetInfo.Unlock()
	return mock.FullAssetInfoFunc(assetID)
}

// FullAssetInfoCalls gets all the calls that were made to FullAssetInfo.
// Check the length with:
//
//	len(mockedState.FullAssetInfoCalls())
func (mock *MockState) FullAssetInfoCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockFullAssetInfo.RLock()
	calls = mock.calls.FullAssetInfo
	mock.lockFullAssetInfo.RUnlock()
	return calls
}

// FullWavesBalance calls FullWavesBalanceFunc.
func (mock *MockState) FullWavesBalance(account proto.Recipient) (*proto.FullWavesBalance, error) {
	if mock.FullWavesBalanceFunc == nil {
		panic("MockState.FullWavesBalanceFunc: method is nil but State.FullWavesBalance was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockFullWavesBalance.Lock()
	mock.calls.FullWavesBalance = append(mock.calls.FullWavesBalance, callInfo)
	mock.lockFullWavesBalance.Unlock()
	return mock.FullWavesBalanceFunc(account)
}

// FullWavesBalanceCalls gets all the calls that were made to FullWavesBalance.
// Check the length with:
//
//	len(mockedState.FullWavesBalanceCalls())
func (mock *MockState) FullWavesBalanceCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockFullWavesBalance.RLock()
	calls = mock.calls.FullWavesBalance
	mock.lockFullWavesBalance.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *MockState) Header(blockID proto.BlockID) (*proto.BlockHeader, error) {
	if mock.HeaderFunc == nil {
		panic("MockState.HeaderFunc: method is nil but State.Header was just called")
	}
	callInfo := struct {
		BlockID proto.BlockID
	}{
		BlockID: blockID,
	}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc(blockID)
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//
//	len(mockedState.HeaderCalls())
func (mock *MockState) HeaderCalls() []struct {
	BlockID proto.BlockID
} {
	var calls []struct {
		BlockID proto.BlockID
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// HeaderByHeight calls HeaderByHeightFunc.
func (mock *MockState) HeaderByHeight(height uint64) (*proto.BlockHeader, error) {
	if mock.HeaderByHeightFunc == nil {
		panic("MockState.HeaderByHeightFunc: method is nil but State.HeaderByHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockHeaderByHeight.Lock()
	mock.calls.HeaderByHeight = append(mock.calls.HeaderByHeight, callInfo)
	mock.lockHeaderByHeight.Unlock()
	return mock.HeaderByHeightFunc(height)
}

// HeaderByHeightCalls gets all the calls that were made to HeaderByHeight.
// Check the length with:
//
//	len(mockedState.HeaderByHeightCalls())
func (mock *MockState) HeaderByHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockHeaderByHeight.RLock()
	calls = mock.calls.HeaderByHeight
	mock.lockHeaderByHeight.RUnlock()
	return calls
}

// Height calls HeightFunc.
func (mock *MockState) Height() (uint64, error) {
	if mock.HeightFunc == nil {
		panic("MockState.HeightFunc: method is nil but State.Height was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeight.Lock()
	mock.calls.Height = append(mock.calls.Height, callInfo)
	mock.lockHeight.Unlock()
	return mock.HeightFunc()
}

// HeightCalls gets all the calls that were made to Height.
// Check the length with:
//
//	len(mockedState.HeightCalls())
func (mock *MockState) HeightCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeight.RLock()
	calls = mock.calls.Height
	mock.lockHeight.RUnlock()
	return calls
}

// HeightToBlockID calls HeightToBlockIDFunc.
func (mock *MockState) HeightToBlockID(height uint64) (proto.BlockID, error) {
	if mock.HeightToBlockIDFunc == nil {
		panic("MockState.HeightToBlockIDFunc: method is nil but State.HeightToBlockID was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockHeightToBlockID.Lock()
	mock.calls.HeightToBlockID = append(mock.calls.HeightToBlockID, callInfo)
	mock.lockHeightToBlockID.Unlock()
	return mock.HeightToBlockIDFunc(height)
}

// HeightToBlockIDCalls gets all the calls that were made to HeightToBlockID.
// Check the length with:
//
//	len(mockedState.HeightToBlockIDCalls())
func (mock *MockState) HeightToBlockIDCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockHeightToBlockID.RLock()
	calls = mock.calls.HeightToBlockID
	mock.lockHeightToBlockID.RUnlock()
	return calls
}

// HitSourceAtHeight calls HitSourceAtHeightFunc.
func (mock *MockState) HitSourceAtHeight(height uint64) ([]byte, error) {
	if mock.HitSourceAtHeightFunc == nil {
		panic("MockState.HitSourceAtHeightFunc: method is nil but State.HitSourceAtHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockHitSourceAtHeight.Lock()
	mock.calls.HitSourceAtHeight = append(mock.calls.HitSourceAtHeight, callInfo)
	mock.lockHitSourceAtHeight.Unlock()
	return mock.HitSourceAtHeightFunc(height)
}

// HitSourceAtHeightCalls gets all the calls that were made to HitSourceAtHeight.
// Check the length with:
//
//	len(mockedState.HitSourceAtHeightCalls())
func (mock *MockState) HitSourceAtHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockHitSourceAtHeight.RLock()
	calls = mock.calls.HitSourceAtHeight
	mock.lockHitSourceAtHeight.RUnlock()
	return calls
}

// InvokeResultByID calls InvokeResultByIDFunc.
func (mock *MockState) InvokeResultByID(invokeID crypto.Digest) (*proto.ScriptResult, error) {
	if mock.InvokeResultByIDFunc == nil {
		panic("MockState.InvokeResultByIDFunc: method is nil but State.InvokeResultByID was just called")
	}
	callInfo := struct {
		InvokeID crypto.Digest
	}{
		InvokeID: invokeID,
	}
	mock.lockInvokeResultByID.Lock()
	mock.calls.InvokeResultByID = append(mock.calls.InvokeResultByID, callInfo)
	mock.lockInvokeResultByID.Unlock()
	return mock.InvokeResultByIDFunc(invokeID)
}

// InvokeResultByIDCalls gets all the calls that were made to InvokeResultByID.
// Check the length with:
//
//	len(mockedState.InvokeResultByIDCalls())
func (mock *MockState) InvokeResultByIDCalls() []struct {
	InvokeID crypto.Digest
} {
	var calls []struct {
		InvokeID crypto.Digest
	}
	mock.lockInvokeResultByID.RLock()
	calls = mock.calls.InvokeResultByID
	mock.lockInvokeResultByID.RUnlock()
	return calls
}

// IsActivated calls IsActivatedFunc.
func (mock *MockState) IsActivated(featureID int16) (bool, error) {
	if mock.IsActivatedFunc == nil {
		panic("MockState.IsActivatedFunc: method is nil but State.IsActivated was just called")
	}
	callInfo := struct {
		FeatureID int16
	}{
		FeatureID: featureID,
	}
	mock.lockIsActivated.Lock()
	mock.calls.IsActivated = append(mock.calls.IsActivated, callInfo)
	mock.lockIsActivated.Unlock()
	return mock.IsActivatedFunc(featureID)
}

// IsActivatedCalls gets all the calls that were made to IsActivated.
// Check the length with:
//
//	len(mockedState.IsActivatedCalls())
func (mock *MockState) IsActivatedCalls() []struct {
	FeatureID int16
} {
	var calls []struct {
		FeatureID int16
	}
	mock.lockIsActivated.RLock()
	calls = mock.calls.IsActivated
	mock.lockIsActivated.RUnlock()
	return calls
}

// IsActiveAtHeight calls IsActiveAtHeightFunc.
func (mock *MockState) IsActiveAtHeight(featureID int16, height uint64) (bool, error) {
	if mock.IsActiveAtHeightFunc == nil {
		panic("MockState.IsActiveAtHeightFunc: method is nil but State.IsActiveAtHeight was just called")
	}
	callInfo := struct {
		FeatureID int16
		Height    uint64
	}{
		FeatureID: featureID,
		Height:    height,
	}
	mock.lockIsActiveAtHeight.Lock()
	mock.calls.IsActiveAtHeight = append(mock.calls.IsActiveAtHeight, callInfo)
	mock.lockIsActiveAtHeight.Unlock()
	return mock.IsActiveAtHeightFunc(featureID, height)
}

// IsActiveAtHeightCalls gets all the calls that were made to IsActiveAtHeight.
// Check the length with:
//
//	len(mockedState.IsActiveAtHeightCalls())
func (mock *MockState) IsActiveAtHeightCalls() []struct {
	FeatureID int16
	Height    uint64
} {
	var calls []struct {
		FeatureID int16
		Height    uint64
	}
	mock.lockIsActiveAtHeight.RLock()
	calls = mock.calls.IsActiveAtHeight
	mock.lockIsActiveAtHeight.RUnlock()
	return calls
}

// IsActiveLeasing calls IsActiveLeasingFunc.
func (mock *MockState) IsActiveLeasing(leaseID crypto.Digest) (bool, error) {
	if mock.IsActiveLeasingFunc == nil {
		panic("MockState.IsActiveLeasingFunc: method is nil but State.IsActiveLeasing was just called")
	}
	callInfo := struct {
		LeaseID crypto.Digest
	}{
		LeaseID: leaseID,
	}
	mock.lockIsActiveLeasing.Lock()
	mock.calls.IsActiveLeasing = append(mock.calls.IsActiveLeasing, callInfo)
	mock.lockIsActiveLeasing.Unlock()
	return mock.IsActiveLeasingFunc(leaseID)
}

// IsActiveLeasingCalls gets all the calls that were made to IsActiveLeasing.
// Check the length with:
//
//	len(mockedState.IsActiveLeasingCalls())
func (mock *MockState) IsActiveLeasingCalls() []struct {
	LeaseID crypto.Digest
} {
	var calls []struct {
		LeaseID crypto.Digest
	}
	mock.lockIsActiveLeasing.RLock()
	calls = mock.calls.IsActiveLeasing
	mock.lockIsActiveLeasing.RUnlock()
	return calls
}

// IsApproved calls IsApprovedFunc.
func (mock *MockState) IsApproved(featureID int16) (bool, error) {
	if mock.IsApprovedFunc == nil {
		panic("MockState.IsApprovedFunc: method is nil but State.IsApproved was just called")
	}
	callInfo := struct {
		FeatureID int16
	}{
		FeatureID: featureID,
	}
	mock.lockIsApproved.Lock()
	mock.calls.IsApproved = append(mock.calls.IsApproved, callInfo)
	mock.lockIsApproved.Unlock()
	return mock.IsApprovedFunc(featureID)
}

// IsApprovedCalls gets all the calls that were made to IsApproved.
// Check the length with:
//
//	len(mockedState.IsApprovedCalls())
func (mock *MockState) IsApprovedCalls() []struct {
	FeatureID int16
} {
	var calls []struct {
		FeatureID int16
	}
	mock.lockIsApproved.RLock()
	calls = mock.calls.IsApproved
	mock.lockIsApproved.RUnlock()
	return calls
}

// IsApprovedAtHeight calls IsApprovedAtHeightFunc.
func (mock *MockState) IsApprovedAtHeight(featureID int16, height uint64) (bool, error) {
	if mock.IsApprovedAtHeightFunc == nil {
		panic("MockState.IsApprovedAtHeightFunc: method is nil but State.IsApprovedAtHeight was just called")
	}
	callInfo := struct {
		FeatureID int16
		Height    uint64
	}{
		FeatureID: featureID,
		Height:    height,
	}
	mock.lockIsApprovedAtHeight.Lock()
	mock.calls.IsApprovedAtHeight = append(mock.calls.IsApprovedAtHeight, callInfo)
	mock.lockIsApprovedAtHeight.Unlock()
	return mock.IsApprovedAtHeightFunc(featureID, height)
}

// IsApprovedAtHeightCalls gets all the calls that were made to IsApprovedAtHeight.
// Check the length with:
//
//	len(mockedState.IsApprovedAtHeightCalls())
func (mock *MockState) IsApprovedAtHeightCalls() []struct {
	FeatureID int16
	Height    uint64
} {
	var calls []struct {
		FeatureID int16
		Height    uint64
	}
	mock.lockIsApprovedAtHeight.RLock()
	calls = mock.calls.IsApprovedAtHeight
	mock.lockIsApprovedAtHeight.RUnlock()
	return calls
}

// IsAssetExist calls IsAssetExistFunc.
func (mock *MockState) IsAssetExist(assetID proto.AssetID) (bool, error) {
	if mock.IsAssetExistFunc == nil {
		panic("MockState.IsAssetExistFunc: method is nil but State.IsAssetExist was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockIsAssetExist.Lock()
	mock.calls.IsAssetExist = append(mock.calls.IsAssetExist, callInfo)
	mock.lockIsAssetExist.Unlock()
	return mock.IsAssetExistFunc(assetID)
}

// IsAssetExistCalls gets all the calls that were made to IsAssetExist.
// Check the length with:
//
//	len(mockedState.IsAssetExistCalls())
func (mock *MockState) IsAssetExistCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockIsAssetExist.RLock()
	calls = mock.calls.IsAssetExist
	mock.lockIsAssetExist.RUnlock()
	return calls
}

// LegacyStateHashAtHeight calls LegacyStateHashAtHeightFunc.
func (mock *MockState) LegacyStateHashAtHeight(height uint64) (*proto.StateHash, error) {
	if mock.LegacyStateHashAtHeightFunc == nil {
		panic("MockState.LegacyStateHashAtHeightFunc: method is nil but State.LegacyStateHashAtHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockLegacyStateHashAtHeight.Lock()
	mock.calls.LegacyStateHashAtHeight = append(mock.calls.LegacyStateHashAtHeight, callInfo)
	mock.lockLegacyStateHashAtHeight.Unlock()
	return mock.LegacyStateHashAtHeightFunc(height)
}

// LegacyStateHashAtHeightCalls gets all the calls that were made to LegacyStateHashAtHeight.
// Check the length with:
//
//	len(mockedState.LegacyStateHashAtHeightCalls())
func (mock *MockState) LegacyStateHashAtHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockLegacyStateHashAtHeight.RLock()
	calls = mock.calls.LegacyStateHashAtHeight
	mock.lockLegacyStateHashAtHeight.RUnlock()
	return calls
}

// Map calls MapFunc.
func (mock *MockState) Map(fn func(state state.State) error) error {
	if mock.MapFunc == nil {
		panic("MockState.MapFunc: method is nil but State.Map was just called")
	}
	callInfo := struct {
		Fn func(state state.State) error
	}{
		Fn: fn,
	}
	mock.lockMap.Lock()
	mock.calls.Map = append(mock.calls.Map, callInfo)
	mock.lockMap.Unlock()
	return mock.MapFunc(fn)
}

// MapCalls gets all the calls that were made to Map.
// Check the length with:
//
//	len(mockedState.MapCalls())
func (mock *MockState) MapCalls() []struct {
	Fn func(state state.State) error
} {
	var calls []struct {
		Fn func(state state.State) error
	}
	mock.lockMap.RLock()
	calls = mock.calls.Map
	mock.lockMap.RUnlock()
	return calls
}

// MapR calls MapRFunc.
func (mock *MockState) MapR(fn func(state.StateInfo) (interface{}, error)) (interface{}, error) {
	if mock.MapRFunc == nil {
		panic("MockState.MapRFunc: method is nil but State.MapR was just called")
	}
	callInfo := struct {
		Fn func(state.StateInfo) (interface{}, error)
	}{
		Fn: fn,
	}
	mock.lockMapR.Lock()
	mock.calls.MapR = append(mock.calls.MapR, callInfo)
	mock.lockMapR.Unlock()
	return mock.MapRFunc(fn)
}

// MapRCalls gets all the calls that were made to MapR.
// Check the length with:
//
//	len(mockedState.MapRCalls())
func (mock *MockState) MapRCalls() []struct {
	Fn func(state.StateInfo) (interface{}, error)
} {
	var calls []struct {
		Fn func(state.StateInfo) (interface{}, error)
	}
	mock.lockMapR.RLock()
	calls = mock.calls.MapR
	mock.lockMapR.RUnlock()
	return calls
}

// NFTList calls NFTListFunc.
func (mock *MockState) NFTList(account proto.Recipient, limit uint64, afterAssetID *proto.AssetID) ([]*proto.FullAssetInfo, error) {
	if mock.NFTListFunc == nil {
		panic("MockState.NFTListFunc: method is nil but State.NFTList was just called")
	}
	callInfo := struct {
		Account      proto.Recipient
		Limit        uint64
		AfterAssetID *proto.AssetID
	}{
		Account:      account,
		Limit:        limit,
		AfterAssetID: afterAssetID,
	}
	mock.lockNFTList.Lock()
	mock.calls.NFTList = append(mock.calls.NFTList, callInfo)
	mock.lockNFTList.Unlock()
	return mock.NFTListFunc(account, limit, afterAssetID)
}

// NFTListCalls gets all the calls that were made to NFTList.
// Check the length with:
//
//	len(mockedState.NFTListCalls())
func (mock *MockState) NFTListCalls() []struct {
	Account      proto.Recipient
	Limit        uint64
	AfterAssetID *proto.AssetID
} {
	var calls []struct {
		Account      proto.Recipient
		Limit        uint64
		AfterAssetID *proto.AssetID
	}
	mock.lockNFTList.RLock()
	calls = mock.calls.NFTList
	mock.lockNFTList.RUnlock()
	return calls
}

// NewAddrTransactionsIterator calls NewAddrTransactionsIteratorFunc.
func (mock *MockState) NewAddrTransactionsIterator(addr proto.Address) (state.TransactionIterator, error) {
	if mock.NewAddrTransactionsIteratorFunc == nil {
		panic("MockState.NewAddrTransactionsIteratorFunc: method is nil but State.NewAddrTransactionsIterator was just called")
	}
	callInfo := struct {
		Addr proto.Address
	}{
		Addr: addr,
	}
	mock.lockNewAddrTransactionsIterator.Lock()
	mock.calls.NewAddrTransactionsIterator = append(mock.calls.NewAddrTransactionsIterator, callInfo)
	mock.lockNewAddrTransactionsIterator.Unlock()
	return mock.NewAddrTransactionsIteratorFunc(addr)
}

// NewAddrTransactionsIteratorCalls gets all the calls that were made to NewAddrTransactionsIterator.
// Check the length with:
//
//	len(mockedState.NewAddrTransactionsIteratorCalls())
func (mock *MockState) NewAddrTransactionsIteratorCalls() []struct {
	Addr proto.Address
} {
	var calls []struct {
		Addr proto.Address
	}
	mock.lockNewAddrTransactionsIterator.RLock()
	calls = mock.calls.NewAddrTransactionsIterator
	mock.lockNewAddrTransactionsIterator.RUnlock()
	return calls
}

// NewestScriptByAccount calls NewestScriptByAccountFunc.
func (mock *MockState) NewestScriptByAccount(account proto.Recipient) (*ast.Tree, error) {
	if mock.NewestScriptByAccountFunc == nil {
		panic("MockState.NewestScriptByAccountFunc: method is nil but State.NewestScriptByAccount was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockNewestScriptByAccount.Lock()
	mock.calls.NewestScriptByAccount = append(mock.calls.NewestScriptByAccount, callInfo)
	mock.lockNewestScriptByAccount.Unlock()
	return mock.NewestScriptByAccountFunc(account)
}

// NewestScriptByAccountCalls gets all the calls that were made to NewestScriptByAccount.
// Check the length with:
//
//	len(mockedState.NewestScriptByAccountCalls())
func (mock *MockState) NewestScriptByAccountCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockNewestScriptByAccount.RLock()
	calls = mock.calls.NewestScriptByAccount
	mock.lockNewestScriptByAccount.RUnlock()
	return calls
}

// NewestScriptBytesByAccount calls NewestScriptBytesByAccountFunc.
func (mock *MockState) NewestScriptBytesByAccount(account proto.Recipient) (proto.Script, error) {
	if mock.NewestScriptBytesByAccountFunc == nil {
		panic("MockState.NewestScriptBytesByAccountFunc: method is nil but State.NewestScriptBytesByAccount was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockNewestScriptBytesByAccount.Lock()
	mock.calls.NewestScriptBytesByAccount = append(mock.calls.NewestScriptBytesByAccount, callInfo)
	mock.lockNewestScriptBytesByAccount.Unlock()
	return mock.NewestScriptBytesByAccountFunc(account)
}

// NewestScriptBytesByAccountCalls gets all the calls that were made to NewestScriptBytesByAccount.
// Check the length with:
//
//	len(mockedState.NewestScriptBytesByAccountCalls())
func (mock *MockState) NewestScriptBytesByAccountCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockNewestScriptBytesByAccount.RLock()
	calls = mock.calls.NewestScriptBytesByAccount
	mock.lockNewestScriptBytesByAccount.RUnlock()
	return calls
}

// PersistAddressTransactions calls PersistAddressTransactionsFunc.
func (mock *MockState) PersistAddressTransactions() error {
	if mock.PersistAddressTransactionsFunc == nil {
		panic("MockState.PersistAddressTransactionsFunc: method is nil but State.PersistAddressTransactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPersistAddressTransactions.Lock()
	mock.calls.PersistAddressTransactions = append(mock.calls.PersistAddressTransactions, callInfo)
	mock.lockPersistAddressTransactions.Unlock()
	return mock.PersistAddressTransactionsFunc()
}

// PersistAddressTransactionsCalls gets all the calls that were made to PersistAddressTransactions.
// Check the length with:
//
//	len(mockedState.PersistAddressTransactionsCalls())
func (mock *MockState) PersistAddressTransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPersistAddressTransactions.RLock()
	calls = mock.calls.PersistAddressTransactions
	mock.lockPersistAddressTransactions.RUnlock()
	return calls
}

// ProvidesExtendedApi calls ProvidesExtendedApiFunc.
func (mock *MockState) ProvidesExtendedApi() (bool, error) {
	if mock.ProvidesExtendedApiFunc == nil {
		panic("MockState.ProvidesExtendedApiFunc: method is nil but State.ProvidesExtendedApi was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProvidesExtendedApi.Lock()
	mock.calls.ProvidesExtendedApi = append(mock.calls.ProvidesExtendedApi, callInfo)
	mock.lockProvidesExtendedApi.Unlock()
	return mock.ProvidesExtendedApiFunc()
}

// ProvidesExtendedApiCalls gets all the calls that were made to ProvidesExtendedApi.
// Check the length with:
//
//	len(mockedState.ProvidesExtendedApiCalls())
func (mock *MockState) ProvidesExtendedApiCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProvidesExtendedApi.RLock()
	calls = mock.calls.ProvidesExtendedApi
	mock.lockProvidesExtendedApi.RUnlock()
	return calls
}

// ProvidesStateHashes calls ProvidesStateHashesFunc.
func (mock *MockState) ProvidesStateHashes() (bool, error) {
	if mock.ProvidesStateHashesFunc == nil {
		panic("MockState.ProvidesStateHashesFunc: method is nil but State.ProvidesStateHashes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProvidesStateHashes.Lock()
	mock.calls.ProvidesStateHashes = append(mock.calls.ProvidesStateHashes, callInfo)
	mock.lockProvidesStateHashes.Unlock()
	return mock.ProvidesStateHashesFunc()
}

// ProvidesStateHashesCalls gets all the calls that were made to ProvidesStateHashes.
// Check the length with:
//
//	len(mockedState.ProvidesStateHashesCalls())
func (mock *MockState) ProvidesStateHashesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProvidesStateHashes.RLock()
	calls = mock.calls.ProvidesStateHashes
	mock.lockProvidesStateHashes.RUnlock()
	return calls
}

// ResetValidationList calls ResetValidationListFunc.
func (mock *MockState) ResetValidationList() {
	if mock.ResetValidationListFunc == nil {
		panic("MockState.ResetValidationListFunc: method is nil but State.ResetValidationList was just called")
	}
	callInfo := struct {
	}{}
	mock.lockResetValidationList.Lock()
	mock.calls.ResetValidationList = append(mock.calls.ResetValidationList, callInfo)
	mock.lockResetValidationList.Unlock()
	mock.ResetValidationListFunc()
}

// ResetValidationListCalls gets all the calls that were made to ResetValidationList.
// Check the length with:
//
//	len(mockedState.ResetValidationListCalls())
func (mock *MockState) ResetValidationListCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockResetValidationList.RLock()
	calls = mock.calls.ResetValidationList
	mock.lockResetValidationList.RUnlock()
	return calls
}

// RetrieveBinaryEntry calls RetrieveBinaryEntryFunc.
func (mock *MockState) RetrieveBinaryEntry(account proto.Recipient, key string) (*proto.BinaryDataEntry, error) {
	if mock.RetrieveBinaryEntryFunc == nil {
		panic("MockState.RetrieveBinaryEntryFunc: method is nil but State.RetrieveBinaryEntry was just called")
	}
	callInfo := struct {
		Account proto.Recipient
		Key     string
	}{
		Account: account,
		Key:     key,
	}
	mock.lockRetrieveBinaryEntry.Lock()
	mock.calls.RetrieveBinaryEntry = append(mock.calls.RetrieveBinaryEntry, callInfo)
	mock.lockRetrieveBinaryEntry.Unlock()
	return mock.RetrieveBinaryEntryFunc(account, key)
}

// RetrieveBinaryEntryCalls gets all the calls that were made to RetrieveBinaryEntry.
// Check the length with:
//
//	len(mockedState.RetrieveBinaryEntryCalls())
func (mock *MockState) RetrieveBinaryEntryCalls() []struct {
	Account proto.Recipient
	Key     string
} {
	var calls []struct {
		Account proto.Recipient
		Key     string
	}
	mock.lockRetrieveBinaryEntry.RLock()
	calls = mock.calls.RetrieveBinaryEntry
	mock.lockRetrieveBinaryEntry.RUnlock()
	return calls
}

// RetrieveBooleanEntry calls RetrieveBooleanEntryFunc.
func (mock *MockState) RetrieveBooleanEntry(account proto.Recipient, key string) (*proto.BooleanDataEntry, error) {
	if mock.RetrieveBooleanEntryFunc == nil {
		panic("MockState.RetrieveBooleanEntryFunc: method is nil but State.RetrieveBooleanEntry was just called")
	}
	callInfo := struct {
		Account proto.Recipient
		Key     string
	}{
		Account: account,
		Key:     key,
	}
	mock.lockRetrieveBooleanEntry.Lock()
	mock.calls.RetrieveBooleanEntry = append(mock.calls.RetrieveBooleanEntry, callInfo)
	mock.lockRetrieveBooleanEntry.Unlock()
	return mock.RetrieveBooleanEntryFunc(account, key)
}

// RetrieveBooleanEntryCalls gets all the calls that were made to RetrieveBooleanEntry.
// Check the length with:
//
//	len(mockedState.RetrieveBooleanEntryCalls())
func (mock *MockState) RetrieveBooleanEntryCalls() []struct {
	Account proto.Recipient
	Key     string
} {
	var calls []struct {
		Account proto.Recipient
		Key     string
	}
	mock.lockRetrieveBooleanEntry.RLock()
	calls = mock.calls.RetrieveBooleanEntry
	mock.lockRetrieveBooleanEntry.RUnlock()
	return calls
}

// RetrieveEntries calls RetrieveEntriesFunc.
func (mock *MockState) RetrieveEntries(account proto.Recipient) ([]proto.DataEntry, error) {
	if mock.RetrieveEntriesFunc == nil {
		panic("MockState.RetrieveEntriesFunc: method is nil but State.RetrieveEntries was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockRetrieveEntries.Lock()
	mock.calls.RetrieveEntries = append(mock.calls.RetrieveEntries, callInfo)
	mock.lockRetrieveEntries.Unlock()
	return mock.RetrieveEntriesFunc(account)
}

// RetrieveEntriesCalls gets all the calls that were made to RetrieveEntries.
// Check the length with:
//
//	len(mockedState.RetrieveEntriesCalls())
func (mock *MockState) RetrieveEntriesCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockRetrieveEntries.RLock()
	calls = mock.calls.RetrieveEntries
	mock.lockRetrieveEntries.RUnlock()
	return calls
}

// RetrieveEntry calls RetrieveEntryFunc.
func (mock *MockState) RetrieveEntry(account proto.Recipient, key string) (proto.DataEntry, error) {
	if mock.RetrieveEntryFunc == nil {
		panic("MockState.RetrieveEntryFunc: method is nil but State.RetrieveEntry was just called")
	}
	callInfo := struct {
		Account proto.Recipient
		Key     string
	}{
		Account: account,
		Key:     key,
	}
	mock.lockRetrieveEntry.Lock()
	mock.calls.RetrieveEntry = append(mock.calls.RetrieveEntry, callInfo)
	mock.lockRetrieveEntry.Unlock()
	return mock.RetrieveEntryFunc(account, key)
}

// RetrieveEntryCalls gets all the calls that were made to RetrieveEntry.
// Check the length with:
//
//	len(mockedState.RetrieveEntryCalls())
func (mock *MockState) RetrieveEntryCalls() []struct {
	Account proto.Recipient
	Key     string
} {
	var calls []struct {
		Account proto.Recipient
		Key     string
	}
	mock.lockRetrieveEntry.RLock()
	calls = mock.calls.RetrieveEntry
	mock.lockRetrieveEntry.RUnlock()
	return calls
}

// RetrieveIntegerEntry calls RetrieveIntegerEntryFunc.
func (mock *MockState) RetrieveIntegerEntry(account proto.Recipient, key string) (*proto.IntegerDataEntry, error) {
	if mock.RetrieveIntegerEntryFunc == nil {
		panic("MockState.RetrieveIntegerEntryFunc: method is nil but State.RetrieveIntegerEntry was just called")
	}
	callInfo := struct {
		Account proto.Recipient
		Key     string
	}{
		Account: account,
		Key:     key,
	}
	mock.lockRetrieveIntegerEntry.Lock()
	mock.calls.RetrieveIntegerEntry = append(mock.calls.RetrieveIntegerEntry, callInfo)
	mock.lockRetrieveIntegerEntry.Unlock()
	return mock.RetrieveIntegerEntryFunc(account, key)
}

// RetrieveIntegerEntryCalls gets all the calls that were made to RetrieveIntegerEntry.
// Check the length with:
//
//	len(mockedState.RetrieveIntegerEntryCalls())
func (mock *MockState) RetrieveIntegerEntryCalls() []struct {
	Account proto.Recipient
	Key     string
} {
	var calls []struct {
		Account proto.Recipient
		Key     string
	}
	mock.lockRetrieveIntegerEntry.RLock()
	calls = mock.calls.RetrieveIntegerEntry
	mock.lockRetrieveIntegerEntry.RUnlock()
	return calls
}

// RetrieveStringEntry calls RetrieveStringEntryFunc.
func (mock *MockState) RetrieveStringEntry(account proto.Recipient, key string) (*proto.StringDataEntry, error) {
	if mock.RetrieveStringEntryFunc == nil {
		panic("MockState.RetrieveStringEntryFunc: method is nil but State.RetrieveStringEntry was just called")
	}
	callInfo := struct {
		Account proto.Recipient
		Key     string
	}{
		Account: account,
		Key:     key,
	}
	mock.lockRetrieveStringEntry.Lock()
	mock.calls.RetrieveStringEntry = append(mock.calls.RetrieveStringEntry, callInfo)
	mock.lockRetrieveStringEntry.Unlock()
	return mock.RetrieveStringEntryFunc(account, key)
}

// RetrieveStringEntryCalls gets all the calls that were made to RetrieveStringEntry.
// Check the length with:
//
//	len(mockedState.RetrieveStringEntryCalls())
func (mock *MockState) RetrieveStringEntryCalls() []struct {
	Account proto.Recipient
	Key     string
} {
	var calls []struct {
		Account proto.Recipient
		Key     string
	}
	mock.lockRetrieveStringEntry.RLock()
	calls = mock.calls.RetrieveStringEntry
	mock.lockRetrieveStringEntry.RUnlock()
	return calls
}

// RewardAtHeight calls RewardAtHeightFunc.
func (mock *MockState) RewardAtHeight(height uint64) (uint64, error) {
	if mock.RewardAtHeightFunc == nil {
		panic("MockState.RewardAtHeightFunc: method is nil but State.RewardAtHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockRewardAtHeight.Lock()
	mock.calls.RewardAtHeight = append(mock.calls.RewardAtHeight, callInfo)
	mock.lockRewardAtHeight.Unlock()
	return mock.RewardAtHeightFunc(height)
}

// RewardAtHeightCalls gets all the calls that were made to RewardAtHeight.
// Check the length with:
//
//	len(mockedState.RewardAtHeightCalls())
func (mock *MockState) RewardAtHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockRewardAtHeight.RLock()
	calls = mock.calls.RewardAtHeight
	mock.lockRewardAtHeight.RUnlock()
	return calls
}

// RewardVotes calls RewardVotesFunc.
func (mock *MockState) RewardVotes(height uint64) (proto.RewardVotes, error) {
	if mock.RewardVotesFunc == nil {
		panic("MockState.RewardVotesFunc: method is nil but State.RewardVotes was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockRewardVotes.Lock()
	mock.calls.RewardVotes = append(mock.calls.RewardVotes, callInfo)
	mock.lockRewardVotes.Unlock()
	return mock.RewardVotesFunc(height)
}

// RewardVotesCalls gets all the calls that were made to RewardVotes.
// Check the length with:
//
//	len(mockedState.RewardVotesCalls())
func (mock *MockState) RewardVotesCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockRewardVotes.RLock()
	calls = mock.calls.RewardVotes
	mock.lockRewardVotes.RUnlock()
	return calls
}

// RollbackTo calls RollbackToFunc.
func (mock *MockState) RollbackTo(removalEdge proto.BlockID) error {
	if mock.RollbackToFunc == nil {
		panic("MockState.RollbackToFunc: method is nil but State.RollbackTo was just called")
	}
	callInfo := struct {
		RemovalEdge proto.BlockID
	}{
		RemovalEdge: removalEdge,
	}
	mock.lockRollbackTo.Lock()
	mock.calls.RollbackTo = append(mock.calls.RollbackTo, callInfo)
	mock.lockRollbackTo.Unlock()
	return mock.RollbackToFunc(removalEdge)
}

// RollbackToCalls gets all the calls that were made to RollbackTo.
// Check the length with:
//
//	len(mockedState.RollbackToCalls())
func (mock *MockState) RollbackToCalls() []struct {
	RemovalEdge proto.BlockID
} {
	var calls []struct {
		RemovalEdge proto.BlockID
	}
	mock.lockRollbackTo.RLock()
	calls = mock.calls.RollbackTo
	mock.lockRollbackTo.RUnlock()
	return calls
}

// RollbackToHeight calls RollbackToHeightFunc.
func (mock *MockState) RollbackToHeight(height uint64) error {
	if mock.RollbackToHeightFunc == nil {
		panic("MockState.RollbackToHeightFunc: method is nil but State.RollbackToHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockRollbackToHeight.Lock()
	mock.calls.RollbackToHeight = append(mock.calls.RollbackToHeight, callInfo)
	mock.lockRollbackToHeight.Unlock()
	return mock.RollbackToHeightFunc(height)
}

// RollbackToHeightCalls gets all the calls that were made to RollbackToHeight.
// Check the length with:
//
//	len(mockedState.RollbackToHeightCalls())
func (mock *MockState) RollbackToHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockRollbackToHeight.RLock()
	calls = mock.calls.RollbackToHeight
	mock.lockRollbackToHeight.RUnlock()
	return calls
}

// ScoreAtHeight calls ScoreAtHeightFunc.
func (mock *MockState) ScoreAtHeight(height uint64) (*big.Int, error) {
	if mock.ScoreAtHeightFunc == nil {
		panic("MockState.ScoreAtHeightFunc: method is nil but State.ScoreAtHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockScoreAtHeight.Lock()
	mock.calls.ScoreAtHeight = append(mock.calls.ScoreAtHeight, callInfo)
	mock.lockScoreAtHeight.Unlock()
	return mock.ScoreAtHeightFunc(height)
}

// ScoreAtHeightCalls gets all the calls that were made to ScoreAtHeight.
// Check the length with:
//
//	len(mockedState.ScoreAtHeightCalls())
func (mock *MockState) ScoreAtHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockScoreAtHeight.RLock()
	calls = mock.calls.ScoreAtHeight
	mock.lockScoreAtHeight.RUnlock()
	return calls
}

// ScriptBasicInfoByAccount calls ScriptBasicInfoByAccountFunc.
func (mock *MockState) ScriptBasicInfoByAccount(account proto.Recipient) (*proto.ScriptBasicInfo, error) {
	if mock.ScriptBasicInfoByAccountFunc == nil {
		panic("MockState.ScriptBasicInfoByAccountFunc: method is nil but State.ScriptBasicInfoByAccount was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockScriptBasicInfoByAccount.Lock()
	mock.calls.ScriptBasicInfoByAccount = append(mock.calls.ScriptBasicInfoByAccount, callInfo)
	mock.lockScriptBasicInfoByAccount.Unlock()
	return mock.ScriptBasicInfoByAccountFunc(account)
}

// ScriptBasicInfoByAccountCalls gets all the calls that were made to ScriptBasicInfoByAccount.
// Check the length with:
//
//	len(mockedState.ScriptBasicInfoByAccountCalls())
func (mock *MockState) ScriptBasicInfoByAccountCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockScriptBasicInfoByAccount.RLock()
	calls = mock.calls.ScriptBasicInfoByAccount
	mock.lockScriptBasicInfoByAccount.RUnlock()
	return calls
}

// ScriptInfoByAccount calls ScriptInfoByAccountFunc.
func (mock *MockState) ScriptInfoByAccount(account proto.Recipient) (*proto.ScriptInfo, error) {
	if mock.ScriptInfoByAccountFunc == nil {
		panic("MockState.ScriptInfoByAccountFunc: method is nil but State.ScriptInfoByAccount was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockScriptInfoByAccount.Lock()
	mock.calls.ScriptInfoByAccount = append(mock.calls.ScriptInfoByAccount, callInfo)
	mock.lockScriptInfoByAccount.Unlock()
	return mock.ScriptInfoByAccountFunc(account)
}

// ScriptInfoByAccountCalls gets all the calls that were made to ScriptInfoByAccount.
// Check the length with:
//
//	len(mockedState.ScriptInfoByAccountCalls())
func (mock *MockState) ScriptInfoByAccountCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockScriptInfoByAccount.RLock()
	calls = mock.calls.ScriptInfoByAccount
	mock.lockScriptInfoByAccount.RUnlock()
	return calls
}

// ScriptInfoByAsset calls ScriptInfoByAssetFunc.
func (mock *MockState) ScriptInfoByAsset(assetID proto.AssetID) (*proto.ScriptInfo, error) {
	if mock.ScriptInfoByAssetFunc == nil {
		panic("MockState.ScriptInfoByAssetFunc: method is nil but State.ScriptInfoByAsset was just called")
	}
	callInfo := struct {
		AssetID proto.AssetID
	}{
		AssetID: assetID,
	}
	mock.lockScriptInfoByAsset.Lock()
	mock.calls.ScriptInfoByAsset = append(mock.calls.ScriptInfoByAsset, callInfo)
	mock.lockScriptInfoByAsset.Unlock()
	return mock.ScriptInfoByAssetFunc(assetID)
}

// ScriptInfoByAssetCalls gets all the calls that were made to ScriptInfoByAsset.
// Check the length with:
//
//	len(mockedState.ScriptInfoByAssetCalls())
func (mock *MockState) ScriptInfoByAssetCalls() []struct {
	AssetID proto.AssetID
} {
	var calls []struct {
		AssetID proto.AssetID
	}
	mock.lockScriptInfoByAsset.RLock()
	calls = mock.calls.ScriptInfoByAsset
	mock.lockScriptInfoByAsset.RUnlock()
	return calls
}

// ShouldPersistAddressTransactions calls ShouldPersistAddressTransactionsFunc.
func (mock *MockState) ShouldPersistAddressTransactions() (bool, error) {
	if mock.ShouldPersistAddressTransactionsFunc == nil {
		panic("MockState.ShouldPersistAddressTransactionsFunc: method is nil but State.ShouldPersistAddressTransactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShouldPersistAddressTransactions.Lock()
	mock.calls.ShouldPersistAddressTransactions = append(mock.calls.ShouldPersistAddressTransactions, callInfo)
	mock.lockShouldPersistAddressTransactions.Unlock()
	return mock.ShouldPersistAddressTransactionsFunc()
}

// ShouldPersistAddressTransactionsCalls gets all the calls that were made to ShouldPersistAddressTransactions.
// Check the length with:
//
//	len(mockedState.ShouldPersistAddressTransactionsCalls())
func (mock *MockState) ShouldPersistAddressTransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShouldPersistAddressTransactions.RLock()
	calls = mock.calls.ShouldPersistAddressTransactions
	mock.lockShouldPersistAddressTransactions.RUnlock()
	return calls
}

// SnapshotStateHashAtHeight calls SnapshotStateHashAtHeightFunc.
func (mock *MockState) SnapshotStateHashAtHeight(height uint64) (crypto.Digest, error) {
	if mock.SnapshotStateHashAtHeightFunc == nil {
		panic("MockState.SnapshotStateHashAtHeightFunc: method is nil but State.SnapshotStateHashAtHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockSnapshotStateHashAtHeight.Lock()
	mock.calls.SnapshotStateHashAtHeight = append(mock.calls.SnapshotStateHashAtHeight, callInfo)
	mock.lockSnapshotStateHashAtHeight.Unlock()
	return mock.SnapshotStateHashAtHeightFunc(height)
}

// SnapshotStateHashAtHeightCalls gets all the calls that were made to SnapshotStateHashAtHeight.
// Check the length with:
//
//	len(mockedState.SnapshotStateHashAtHeightCalls())
func (mock *MockState) SnapshotStateHashAtHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockSnapshotStateHashAtHeight.RLock()
	calls = mock.calls.SnapshotStateHashAtHeight
	mock.lockSnapshotStateHashAtHeight.RUnlock()
	return calls
}

// SnapshotsAtHeight calls SnapshotsAtHeightFunc.
func (mock *MockState) SnapshotsAtHeight(height uint64) (proto.BlockSnapshot, error) {
	if mock.SnapshotsAtHeightFunc == nil {
		panic("MockState.SnapshotsAtHeightFunc: method is nil but State.SnapshotsAtHeight was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockSnapshotsAtHeight.Lock()
	mock.calls.SnapshotsAtHeight = append(mock.calls.SnapshotsAtHeight, callInfo)
	mock.lockSnapshotsAtHeight.Unlock()
	return mock.SnapshotsAtHeightFunc(height)
}

// SnapshotsAtHeightCalls gets all the calls that were made to SnapshotsAtHeight.
// Check the length with:
//
//	len(mockedState.SnapshotsAtHeightCalls())
func (mock *MockState) SnapshotsAtHeightCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockSnapshotsAtHeight.RLock()
	calls = mock.calls.SnapshotsAtHeight
	mock.lockSnapshotsAtHeight.RUnlock()
	return calls
}

// StartProvidingExtendedAPI calls StartProvidingExtendedAPIFunc.
func (mock *MockState) StartProvidingExtendedAPI() error {
	if mock.StartProvidingExtendedAPIFunc == nil {
		panic("MockState.StartProvidingExtendedAPIFunc: method is nil but State.StartProvidingExtendedAPI was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStartProvidingExtendedAPI.Lock()
	mock.calls.StartProvidingExtendedAPI = append(mock.calls.StartProvidingExtendedAPI, callInfo)
	mock.lockStartProvidingExtendedAPI.Unlock()
	return mock.StartProvidingExtendedAPIFunc()
}

// StartProvidingExtendedAPICalls gets all the calls that were made to StartProvidingExtendedAPI.
// Check the length with:
//
//	len(mockedState.StartProvidingExtendedAPICalls())
func (mock *MockState) StartProvidingExtendedAPICalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStartProvidingExtendedAPI.RLock()
	calls = mock.calls.StartProvidingExtendedAPI
	mock.lockStartProvidingExtendedAPI.RUnlock()
	return calls
}

// TopBlock calls TopBlockFunc.
func (mock *MockState) TopBlock() *proto.Block {
	if mock.TopBlockFunc == nil {
		panic("MockState.TopBlockFunc: method is nil but State.TopBlock was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTopBlock.Lock()
	mock.calls.TopBlock = append(mock.calls.TopBlock, callInfo)
	mock.lockTopBlock.Unlock()
	return mock.TopBlockFunc()
}

// TopBlockCalls gets all the calls that were made to TopBlock.
// Check the length with:
//
//	len(mockedState.TopBlockCalls())
func (mock *MockState) TopBlockCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTopBlock.RLock()
	calls = mock.calls.TopBlock
	mock.lockTopBlock.RUnlock()
	return calls
}

// TotalWavesAmount calls TotalWavesAmountFunc.
func (mock *MockState) TotalWavesAmount(height uint64) (uint64, error) {
	if mock.TotalWavesAmountFunc == nil {
		panic("MockState.TotalWavesAmountFunc: method is nil but State.TotalWavesAmount was just called")
	}
	callInfo := struct {
		Height uint64
	}{
		Height: height,
	}
	mock.lockTotalWavesAmount.Lock()
	mock.calls.TotalWavesAmount = append(mock.calls.TotalWavesAmount, callInfo)
	mock.lockTotalWavesAmount.Unlock()
	return mock.TotalWavesAmountFunc(height)
}

// TotalWavesAmountCalls gets all the calls that were made to TotalWavesAmount.
// Check the length with:
//
//	len(mockedState.TotalWavesAmountCalls())
func (mock *MockState) TotalWavesAmountCalls() []struct {
	Height uint64
} {
	var calls []struct {
		Height uint64
	}
	mock.lockTotalWavesAmount.RLock()
	calls = mock.calls.TotalWavesAmount
	mock.lockTotalWavesAmount.RUnlock()
	return calls
}

// TransactionByID calls TransactionByIDFunc.
func (mock *MockState) TransactionByID(id []byte) (proto.Transaction, error) {
	if mock.TransactionByIDFunc == nil {
		panic("MockState.TransactionByIDFunc: method is nil but State.TransactionByID was just called")
	}
	callInfo := struct {
		ID []byte
	}{
		ID: id,
	}
	mock.lockTransactionByID.Lock()
	mock.calls.TransactionByID = append(mock.calls.TransactionByID, callInfo)
	mock.lockTransactionByID.Unlock()
	return mock.TransactionByIDFunc(id)
}

// TransactionByIDCalls gets all the calls that were made to TransactionByID.
// Check the length with:
//
//	len(mockedState.TransactionByIDCalls())
func (mock *MockState) TransactionByIDCalls() []struct {
	ID []byte
} {
	var calls []struct {
		ID []byte
	}
	mock.lockTransactionByID.RLock()
	calls = mock.calls.TransactionByID
	mock.lockTransactionByID.RUnlock()
	return calls
}

// TransactionByIDWithStatus calls TransactionByIDWithStatusFunc.
func (mock *MockState) TransactionByIDWithStatus(id []byte) (proto.Transaction, proto.TransactionStatus, error) {
	if mock.TransactionByIDWithStatusFunc == nil {
		panic("MockState.TransactionByIDWithStatusFunc: method is nil but State.TransactionByIDWithStatus was just called")
	}
	callInfo := struct {
		ID []byte
	}{
		ID: id,
	}
	mock.lockTransactionByIDWithStatus.Lock()
	mock.calls.TransactionByIDWithStatus = append(mock.calls.TransactionByIDWithStatus, callInfo)
	mock.lockTransactionByIDWithStatus.Unlock()
	return mock.TransactionByIDWithStatusFunc(id)
}

// TransactionByIDWithStatusCalls gets all the calls that were made to TransactionByIDWithStatus.
// Check the length with:
//
//	len(mockedState.TransactionByIDWithStatusCalls())
func (mock *MockState) TransactionByIDWithStatusCalls() []struct {
	ID []byte
} {
	var calls []struct {
		ID []byte
	}
	mock.lockTransactionByIDWithStatus.RLock()
	calls = mock.calls.TransactionByIDWithStatus
	mock.lockTransactionByIDWithStatus.RUnlock()
	return calls
}

// TransactionHeightByID calls TransactionHeightByIDFunc.
func (mock *MockState) TransactionHeightByID(id []byte) (uint64, error) {
	if mock.TransactionHeightByIDFunc == nil {
		panic("MockState.TransactionHeightByIDFunc: method is nil but State.TransactionHeightByID was just called")
	}
	callInfo := struct {
		ID []byte
	}{
		ID: id,
	}
	mock.lockTransactionHeightByID.Lock()
	mock.calls.TransactionHeightByID = append(mock.calls.TransactionHeightByID, callInfo)
	mock.lockTransactionHeightByID.Unlock()
	return mock.TransactionHeightByIDFunc(id)
}

// TransactionHeightByIDCalls gets all the calls that were made to TransactionHeightByID.
// Check the length with:
//
//	len(mockedState.TransactionHeightByIDCalls())
func (mock *MockState) TransactionHeightByIDCalls() []struct {
	ID []byte
} {
	var calls []struct {
		ID []byte
	}
	mock.lockTransactionHeightByID.RLock()
	calls = mock.calls.TransactionHeightByID
	mock.lockTransactionHeightByID.RUnlock()
	return calls
}

// TxValidation calls TxValidationFunc.
func (mock *MockState) TxValidation(fn func(validation state.TxValidation) error) error {
	if mock.TxValidationFunc == nil {
		panic("MockState.TxValidationFunc: method is nil but State.TxValidation was just called")
	}
	callInfo := struct {
		Fn func(validation state.TxValidation) error
	}{
		Fn: fn,
	}
	mock.lockTxValidation.Lock()
	mock.calls.TxValidation = append(mock.calls.TxValidation, callInfo)
	mock.lockTxValidation.Unlock()
	return mock.TxValidationFunc(fn)
}

// TxValidationCalls gets all the calls that were made to TxValidation.
// Check the length with:
//
//	len(mockedState.TxValidationCalls())
func (mock *MockState) TxValidationCalls() []struct {
	Fn func(validation state.TxValidation) error
} {
	var calls []struct {
		Fn func(validation state.TxValidation) error
	}
	mock.lockTxValidation.RLock()
	calls = mock.calls.TxValidation
	mock.lockTxValidation.RUnlock()
	return calls
}

// ValidateNextTx calls ValidateNextTxFunc.
func (mock *MockState) ValidateNextTx(tx proto.Transaction, currentTimestamp uint64, parentTimestamp uint64, blockVersion proto.BlockVersion, acceptFailed bool) error {
	if mock.ValidateNextTxFunc == nil {
		panic("MockState.ValidateNextTxFunc: method is nil but State.ValidateNextTx was just called")
	}
	callInfo := struct {
		Tx               proto.Transaction
		CurrentTimestamp uint64
		ParentTimestamp  uint64
		BlockVersion     proto.BlockVersion
		AcceptFailed     bool
	}{
		Tx:               tx,
		CurrentTimestamp: currentTimestamp,
		ParentTimestamp:  parentTimestamp,
		BlockVersion:     blockVersion,
		AcceptFailed:     acceptFailed,
	}
	mock.lockValidateNextTx.Lock()
	mock.calls.ValidateNextTx = append(mock.calls.ValidateNextTx, callInfo)
	mock.lockValidateNextTx.Unlock()
	return mock.ValidateNextTxFunc(tx, currentTimestamp, parentTimestamp, blockVersion, acceptFailed)
}

// ValidateNextTxCalls gets all the calls that were made to ValidateNextTx.
// Check the length with:
//
//	len(mockedState.ValidateNextTxCalls())
func (mock *MockState) ValidateNextTxCalls() []struct {
	Tx               proto.Transaction
	CurrentTimestamp uint64
	ParentTimestamp  uint64
	BlockVersion     proto.BlockVersion
	AcceptFailed     bool
} {
	var calls []struct {
		Tx               proto.Transaction
		CurrentTimestamp uint64
		ParentTimestamp  uint64
		BlockVersion     proto.BlockVersion
		AcceptFailed     bool
	}
	mock.lockValidateNextTx.RLock()
	calls = mock.calls.ValidateNextTx
	mock.lockValidateNextTx.RUnlock()
	return calls
}

// VotesNum calls VotesNumFunc.
func (mock *MockState) VotesNum(featureID int16) (uint64, error) {
	if mock.VotesNumFunc == nil {
		panic("MockState.VotesNumFunc: method is nil but State.VotesNum was just called")
	}
	callInfo := struct {
		FeatureID int16
	}{
		FeatureID: featureID,
	}
	mock.lockVotesNum.Lock()
	mock.calls.VotesNum = append(mock.calls.VotesNum, callInfo)
	mock.lockVotesNum.Unlock()
	return mock.VotesNumFunc(featureID)
}

// VotesNumCalls gets all the calls that were made to VotesNum.
// Check the length with:
//
//	len(mockedState.VotesNumCalls())
func (mock *MockState) VotesNumCalls() []struct {
	FeatureID int16
} {
	var calls []struct {
		FeatureID int16
	}
	mock.lockVotesNum.RLock()
	calls = mock.calls.VotesNum
	mock.lockVotesNum.RUnlock()
	return calls
}

// VotesNumAtHeight calls VotesNumAtHeightFunc.
func (mock *MockState) VotesNumAtHeight(featureID int16, height uint64) (uint64, error) {
	if mock.VotesNumAtHeightFunc == nil {
		panic("MockState.VotesNumAtHeightFunc: method is nil but State.VotesNumAtHeight was just called")
	}
	callInfo := struct {
		FeatureID int16
		Height    uint64
	}{
		FeatureID: featureID,
		Height:    height,
	}
	mock.lockVotesNumAtHeight.Lock()
	mock.calls.VotesNumAtHeight = append(mock.calls.VotesNumAtHeight, callInfo)
	mock.lockVotesNumAtHeight.Unlock()
	return mock.VotesNumAtHeightFunc(featureID, height)
}

// VotesNumAtHeightCalls gets all the calls that were made to VotesNumAtHeight.
// Check the length with:
//
//	len(mockedState.VotesNumAtHeightCalls())
func (mock *MockState) VotesNumAtHeightCalls() []struct {
	FeatureID int16
	Height    uint64
} {
	var calls []struct {
		FeatureID int16
		Height    uint64
	}
	mock.lockVotesNumAtHeight.RLock()
	calls = mock.calls.VotesNumAtHeight
	mock.lockVotesNumAtHeight.RUnlock()
	return calls
}

// WavesAddressesNumber calls WavesAddressesNumberFunc.
func (mock *MockState) WavesAddressesNumber() (uint64, error) {
	if mock.WavesAddressesNumberFunc == nil {
		panic("MockState.WavesAddressesNumberFunc: method is nil but State.WavesAddressesNumber was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWavesAddressesNumber.Lock()
	mock.calls.WavesAddressesNumber = append(mock.calls.WavesAddressesNumber, callInfo)
	mock.lockWavesAddressesNumber.Unlock()
	return mock.WavesAddressesNumberFunc()
}

// WavesAddressesNumberCalls gets all the calls that were made to WavesAddressesNumber.
// Check the length with:
//
//	len(mockedState.WavesAddressesNumberCalls())
func (mock *MockState) WavesAddressesNumberCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWavesAddressesNumber.RLock()
	calls = mock.calls.WavesAddressesNumber
	mock.lockWavesAddressesNumber.RUnlock()
	return calls
}

// WavesBalance calls WavesBalanceFunc.
func (mock *MockState) WavesBalance(account proto.Recipient) (uint64, error) {
	if mock.WavesBalanceFunc == nil {
		panic("MockState.WavesBalanceFunc: method is nil but State.WavesBalance was just called")
	}
	callInfo := struct {
		Account proto.Recipient
	}{
		Account: account,
	}
	mock.lockWavesBalance.Lock()
	mock.calls.WavesBalance = append(mock.calls.WavesBalance, callInfo)
	mock.lockWavesBalance.Unlock()
	return mock.WavesBalanceFunc(account)
}

// WavesBalanceCalls gets all the calls that were made to WavesBalance.
// Check the length with:
//
//	len(mockedState.WavesBalanceCalls())
func (mock *MockState) WavesBalanceCalls() []struct {
	Account proto.Recipient
} {
	var calls []struct {
		Account proto.Recipient
	}
	mock.lockWavesBalance.RLock()
	calls = mock.calls.WavesBalance
	mock.lockWavesBalance.RUnlock()
	return calls
}
