// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package peers

import (
	"time"

	mock "github.com/stretchr/testify/mock"
	"github.com/wavesplatform/gowaves/pkg/node/peers/storage"
)

// NewMockPeerStorage creates a new instance of MockPeerStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPeerStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPeerStorage {
	mock := &MockPeerStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPeerStorage is an autogenerated mock type for the PeerStorage type
type MockPeerStorage struct {
	mock.Mock
}

type MockPeerStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPeerStorage) EXPECT() *MockPeerStorage_Expecter {
	return &MockPeerStorage_Expecter{mock: &_m.Mock}
}

// AddOrUpdateKnown provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) AddOrUpdateKnown(known []storage.KnownPeer, now time.Time) error {
	ret := _mock.Called(known, now)

	if len(ret) == 0 {
		panic("no return value specified for AddOrUpdateKnown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.KnownPeer, time.Time) error); ok {
		r0 = returnFunc(known, now)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_AddOrUpdateKnown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddOrUpdateKnown'
type MockPeerStorage_AddOrUpdateKnown_Call struct {
	*mock.Call
}

// AddOrUpdateKnown is a helper method to define mock.On call
//   - known []storage.KnownPeer
//   - now time.Time
func (_e *MockPeerStorage_Expecter) AddOrUpdateKnown(known interface{}, now interface{}) *MockPeerStorage_AddOrUpdateKnown_Call {
	return &MockPeerStorage_AddOrUpdateKnown_Call{Call: _e.mock.On("AddOrUpdateKnown", known, now)}
}

func (_c *MockPeerStorage_AddOrUpdateKnown_Call) Run(run func(known []storage.KnownPeer, now time.Time)) *MockPeerStorage_AddOrUpdateKnown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.KnownPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.KnownPeer)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerStorage_AddOrUpdateKnown_Call) Return(err error) *MockPeerStorage_AddOrUpdateKnown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_AddOrUpdateKnown_Call) RunAndReturn(run func(known []storage.KnownPeer, now time.Time) error) *MockPeerStorage_AddOrUpdateKnown_Call {
	_c.Call.Return(run)
	return _c
}

// AddSuspended provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) AddSuspended(suspended []storage.SuspendedPeer) error {
	ret := _mock.Called(suspended)

	if len(ret) == 0 {
		panic("no return value specified for AddSuspended")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.SuspendedPeer) error); ok {
		r0 = returnFunc(suspended)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_AddSuspended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSuspended'
type MockPeerStorage_AddSuspended_Call struct {
	*mock.Call
}

// AddSuspended is a helper method to define mock.On call
//   - suspended []storage.SuspendedPeer
func (_e *MockPeerStorage_Expecter) AddSuspended(suspended interface{}) *MockPeerStorage_AddSuspended_Call {
	return &MockPeerStorage_AddSuspended_Call{Call: _e.mock.On("AddSuspended", suspended)}
}

func (_c *MockPeerStorage_AddSuspended_Call) Run(run func(suspended []storage.SuspendedPeer)) *MockPeerStorage_AddSuspended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.SuspendedPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.SuspendedPeer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_AddSuspended_Call) Return(err error) *MockPeerStorage_AddSuspended_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_AddSuspended_Call) RunAndReturn(run func(suspended []storage.SuspendedPeer) error) *MockPeerStorage_AddSuspended_Call {
	_c.Call.Return(run)
	return _c
}

// AddToBlackList provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) AddToBlackList(blackListed []storage.BlackListedPeer) error {
	ret := _mock.Called(blackListed)

	if len(ret) == 0 {
		panic("no return value specified for AddToBlackList")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.BlackListedPeer) error); ok {
		r0 = returnFunc(blackListed)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_AddToBlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddToBlackList'
type MockPeerStorage_AddToBlackList_Call struct {
	*mock.Call
}

// AddToBlackList is a helper method to define mock.On call
//   - blackListed []storage.BlackListedPeer
func (_e *MockPeerStorage_Expecter) AddToBlackList(blackListed interface{}) *MockPeerStorage_AddToBlackList_Call {
	return &MockPeerStorage_AddToBlackList_Call{Call: _e.mock.On("AddToBlackList", blackListed)}
}

func (_c *MockPeerStorage_AddToBlackList_Call) Run(run func(blackListed []storage.BlackListedPeer)) *MockPeerStorage_AddToBlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.BlackListedPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.BlackListedPeer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_AddToBlackList_Call) Return(err error) *MockPeerStorage_AddToBlackList_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_AddToBlackList_Call) RunAndReturn(run func(blackListed []storage.BlackListedPeer) error) *MockPeerStorage_AddToBlackList_Call {
	_c.Call.Return(run)
	return _c
}

// BlackList provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) BlackList(now time.Time) []storage.BlackListedPeer {
	ret := _mock.Called(now)

	if len(ret) == 0 {
		panic("no return value specified for BlackList")
	}

	var r0 []storage.BlackListedPeer
	if returnFunc, ok := ret.Get(0).(func(time.Time) []storage.BlackListedPeer); ok {
		r0 = returnFunc(now)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.BlackListedPeer)
		}
	}
	return r0
}

// MockPeerStorage_BlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlackList'
type MockPeerStorage_BlackList_Call struct {
	*mock.Call
}

// BlackList is a helper method to define mock.On call
//   - now time.Time
func (_e *MockPeerStorage_Expecter) BlackList(now interface{}) *MockPeerStorage_BlackList_Call {
	return &MockPeerStorage_BlackList_Call{Call: _e.mock.On("BlackList", now)}
}

func (_c *MockPeerStorage_BlackList_Call) Run(run func(now time.Time)) *MockPeerStorage_BlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Time
		if args[0] != nil {
			arg0 = args[0].(time.Time)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_BlackList_Call) Return(vs []storage.BlackListedPeer) *MockPeerStorage_BlackList_Call {
	_c.Call.Return(vs)
	return _c
}

func (_c *MockPeerStorage_BlackList_Call) RunAndReturn(run func(now time.Time) []storage.BlackListedPeer) *MockPeerStorage_BlackList_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBlackListedByIP provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DeleteBlackListedByIP(blackListed []storage.BlackListedPeer) error {
	ret := _mock.Called(blackListed)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBlackListedByIP")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.BlackListedPeer) error); ok {
		r0 = returnFunc(blackListed)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DeleteBlackListedByIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBlackListedByIP'
type MockPeerStorage_DeleteBlackListedByIP_Call struct {
	*mock.Call
}

// DeleteBlackListedByIP is a helper method to define mock.On call
//   - blackListed []storage.BlackListedPeer
func (_e *MockPeerStorage_Expecter) DeleteBlackListedByIP(blackListed interface{}) *MockPeerStorage_DeleteBlackListedByIP_Call {
	return &MockPeerStorage_DeleteBlackListedByIP_Call{Call: _e.mock.On("DeleteBlackListedByIP", blackListed)}
}

func (_c *MockPeerStorage_DeleteBlackListedByIP_Call) Run(run func(blackListed []storage.BlackListedPeer)) *MockPeerStorage_DeleteBlackListedByIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.BlackListedPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.BlackListedPeer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_DeleteBlackListedByIP_Call) Return(err error) *MockPeerStorage_DeleteBlackListedByIP_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DeleteBlackListedByIP_Call) RunAndReturn(run func(blackListed []storage.BlackListedPeer) error) *MockPeerStorage_DeleteBlackListedByIP_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKnown provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DeleteKnown(known []storage.KnownPeer) error {
	ret := _mock.Called(known)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKnown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.KnownPeer) error); ok {
		r0 = returnFunc(known)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DeleteKnown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKnown'
type MockPeerStorage_DeleteKnown_Call struct {
	*mock.Call
}

// DeleteKnown is a helper method to define mock.On call
//   - known []storage.KnownPeer
func (_e *MockPeerStorage_Expecter) DeleteKnown(known interface{}) *MockPeerStorage_DeleteKnown_Call {
	return &MockPeerStorage_DeleteKnown_Call{Call: _e.mock.On("DeleteKnown", known)}
}

func (_c *MockPeerStorage_DeleteKnown_Call) Run(run func(known []storage.KnownPeer)) *MockPeerStorage_DeleteKnown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.KnownPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.KnownPeer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_DeleteKnown_Call) Return(err error) *MockPeerStorage_DeleteKnown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DeleteKnown_Call) RunAndReturn(run func(known []storage.KnownPeer) error) *MockPeerStorage_DeleteKnown_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSuspendedByIP provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DeleteSuspendedByIP(suspended []storage.SuspendedPeer) error {
	ret := _mock.Called(suspended)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSuspendedByIP")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.SuspendedPeer) error); ok {
		r0 = returnFunc(suspended)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DeleteSuspendedByIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSuspendedByIP'
type MockPeerStorage_DeleteSuspendedByIP_Call struct {
	*mock.Call
}

// DeleteSuspendedByIP is a helper method to define mock.On call
//   - suspended []storage.SuspendedPeer
func (_e *MockPeerStorage_Expecter) DeleteSuspendedByIP(suspended interface{}) *MockPeerStorage_DeleteSuspendedByIP_Call {
	return &MockPeerStorage_DeleteSuspendedByIP_Call{Call: _e.mock.On("DeleteSuspendedByIP", suspended)}
}

func (_c *MockPeerStorage_DeleteSuspendedByIP_Call) Run(run func(suspended []storage.SuspendedPeer)) *MockPeerStorage_DeleteSuspendedByIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.SuspendedPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.SuspendedPeer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_DeleteSuspendedByIP_Call) Return(err error) *MockPeerStorage_DeleteSuspendedByIP_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DeleteSuspendedByIP_Call) RunAndReturn(run func(suspended []storage.SuspendedPeer) error) *MockPeerStorage_DeleteSuspendedByIP_Call {
	_c.Call.Return(run)
	return _c
}

// DropBlackList provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DropBlackList() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DropBlackList")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DropBlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropBlackList'
type MockPeerStorage_DropBlackList_Call struct {
	*mock.Call
}

// DropBlackList is a helper method to define mock.On call
func (_e *MockPeerStorage_Expecter) DropBlackList() *MockPeerStorage_DropBlackList_Call {
	return &MockPeerStorage_DropBlackList_Call{Call: _e.mock.On("DropBlackList")}
}

func (_c *MockPeerStorage_DropBlackList_Call) Run(run func()) *MockPeerStorage_DropBlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerStorage_DropBlackList_Call) Return(err error) *MockPeerStorage_DropBlackList_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DropBlackList_Call) RunAndReturn(run func() error) *MockPeerStorage_DropBlackList_Call {
	_c.Call.Return(run)
	return _c
}

// DropKnown provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DropKnown() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DropKnown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DropKnown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropKnown'
type MockPeerStorage_DropKnown_Call struct {
	*mock.Call
}

// DropKnown is a helper method to define mock.On call
func (_e *MockPeerStorage_Expecter) DropKnown() *MockPeerStorage_DropKnown_Call {
	return &MockPeerStorage_DropKnown_Call{Call: _e.mock.On("DropKnown")}
}

func (_c *MockPeerStorage_DropKnown_Call) Run(run func()) *MockPeerStorage_DropKnown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerStorage_DropKnown_Call) Return(err error) *MockPeerStorage_DropKnown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DropKnown_Call) RunAndReturn(run func() error) *MockPeerStorage_DropKnown_Call {
	_c.Call.Return(run)
	return _c
}

// DropStorage provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DropStorage() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DropStorage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DropStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropStorage'
type MockPeerStorage_DropStorage_Call struct {
	*mock.Call
}

// DropStorage is a helper method to define mock.On call
func (_e *MockPeerStorage_Expecter) DropStorage() *MockPeerStorage_DropStorage_Call {
	return &MockPeerStorage_DropStorage_Call{Call: _e.mock.On("DropStorage")}
}

func (_c *MockPeerStorage_DropStorage_Call) Run(run func()) *MockPeerStorage_DropStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerStorage_DropStorage_Call) Return(err error) *MockPeerStorage_DropStorage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DropStorage_Call) RunAndReturn(run func() error) *MockPeerStorage_DropStorage_Call {
	_c.Call.Return(run)
	return _c
}

// DropSuspended provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) DropSuspended() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DropSuspended")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_DropSuspended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropSuspended'
type MockPeerStorage_DropSuspended_Call struct {
	*mock.Call
}

// DropSuspended is a helper method to define mock.On call
func (_e *MockPeerStorage_Expecter) DropSuspended() *MockPeerStorage_DropSuspended_Call {
	return &MockPeerStorage_DropSuspended_Call{Call: _e.mock.On("DropSuspended")}
}

func (_c *MockPeerStorage_DropSuspended_Call) Run(run func()) *MockPeerStorage_DropSuspended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerStorage_DropSuspended_Call) Return(err error) *MockPeerStorage_DropSuspended_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_DropSuspended_Call) RunAndReturn(run func() error) *MockPeerStorage_DropSuspended_Call {
	_c.Call.Return(run)
	return _c
}

// IsBlackListedIP provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) IsBlackListedIP(ip storage.IP, now time.Time) bool {
	ret := _mock.Called(ip, now)

	if len(ret) == 0 {
		panic("no return value specified for IsBlackListedIP")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(storage.IP, time.Time) bool); ok {
		r0 = returnFunc(ip, now)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPeerStorage_IsBlackListedIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsBlackListedIP'
type MockPeerStorage_IsBlackListedIP_Call struct {
	*mock.Call
}

// IsBlackListedIP is a helper method to define mock.On call
//   - ip storage.IP
//   - now time.Time
func (_e *MockPeerStorage_Expecter) IsBlackListedIP(ip interface{}, now interface{}) *MockPeerStorage_IsBlackListedIP_Call {
	return &MockPeerStorage_IsBlackListedIP_Call{Call: _e.mock.On("IsBlackListedIP", ip, now)}
}

func (_c *MockPeerStorage_IsBlackListedIP_Call) Run(run func(ip storage.IP, now time.Time)) *MockPeerStorage_IsBlackListedIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.IP
		if args[0] != nil {
			arg0 = args[0].(storage.IP)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerStorage_IsBlackListedIP_Call) Return(b bool) *MockPeerStorage_IsBlackListedIP_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPeerStorage_IsBlackListedIP_Call) RunAndReturn(run func(ip storage.IP, now time.Time) bool) *MockPeerStorage_IsBlackListedIP_Call {
	_c.Call.Return(run)
	return _c
}

// IsBlackListedIPs provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) IsBlackListedIPs(ips []storage.IP, now time.Time) []bool {
	ret := _mock.Called(ips, now)

	if len(ret) == 0 {
		panic("no return value specified for IsBlackListedIPs")
	}

	var r0 []bool
	if returnFunc, ok := ret.Get(0).(func([]storage.IP, time.Time) []bool); ok {
		r0 = returnFunc(ips, now)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}
	return r0
}

// MockPeerStorage_IsBlackListedIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsBlackListedIPs'
type MockPeerStorage_IsBlackListedIPs_Call struct {
	*mock.Call
}

// IsBlackListedIPs is a helper method to define mock.On call
//   - ips []storage.IP
//   - now time.Time
func (_e *MockPeerStorage_Expecter) IsBlackListedIPs(ips interface{}, now interface{}) *MockPeerStorage_IsBlackListedIPs_Call {
	return &MockPeerStorage_IsBlackListedIPs_Call{Call: _e.mock.On("IsBlackListedIPs", ips, now)}
}

func (_c *MockPeerStorage_IsBlackListedIPs_Call) Run(run func(ips []storage.IP, now time.Time)) *MockPeerStorage_IsBlackListedIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.IP
		if args[0] != nil {
			arg0 = args[0].([]storage.IP)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerStorage_IsBlackListedIPs_Call) Return(bools []bool) *MockPeerStorage_IsBlackListedIPs_Call {
	_c.Call.Return(bools)
	return _c
}

func (_c *MockPeerStorage_IsBlackListedIPs_Call) RunAndReturn(run func(ips []storage.IP, now time.Time) []bool) *MockPeerStorage_IsBlackListedIPs_Call {
	_c.Call.Return(run)
	return _c
}

// IsSuspendedIP provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) IsSuspendedIP(ip storage.IP, now time.Time) bool {
	ret := _mock.Called(ip, now)

	if len(ret) == 0 {
		panic("no return value specified for IsSuspendedIP")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(storage.IP, time.Time) bool); ok {
		r0 = returnFunc(ip, now)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPeerStorage_IsSuspendedIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSuspendedIP'
type MockPeerStorage_IsSuspendedIP_Call struct {
	*mock.Call
}

// IsSuspendedIP is a helper method to define mock.On call
//   - ip storage.IP
//   - now time.Time
func (_e *MockPeerStorage_Expecter) IsSuspendedIP(ip interface{}, now interface{}) *MockPeerStorage_IsSuspendedIP_Call {
	return &MockPeerStorage_IsSuspendedIP_Call{Call: _e.mock.On("IsSuspendedIP", ip, now)}
}

func (_c *MockPeerStorage_IsSuspendedIP_Call) Run(run func(ip storage.IP, now time.Time)) *MockPeerStorage_IsSuspendedIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 storage.IP
		if args[0] != nil {
			arg0 = args[0].(storage.IP)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerStorage_IsSuspendedIP_Call) Return(b bool) *MockPeerStorage_IsSuspendedIP_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPeerStorage_IsSuspendedIP_Call) RunAndReturn(run func(ip storage.IP, now time.Time) bool) *MockPeerStorage_IsSuspendedIP_Call {
	_c.Call.Return(run)
	return _c
}

// IsSuspendedIPs provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) IsSuspendedIPs(ips []storage.IP, now time.Time) []bool {
	ret := _mock.Called(ips, now)

	if len(ret) == 0 {
		panic("no return value specified for IsSuspendedIPs")
	}

	var r0 []bool
	if returnFunc, ok := ret.Get(0).(func([]storage.IP, time.Time) []bool); ok {
		r0 = returnFunc(ips, now)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bool)
		}
	}
	return r0
}

// MockPeerStorage_IsSuspendedIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSuspendedIPs'
type MockPeerStorage_IsSuspendedIPs_Call struct {
	*mock.Call
}

// IsSuspendedIPs is a helper method to define mock.On call
//   - ips []storage.IP
//   - now time.Time
func (_e *MockPeerStorage_Expecter) IsSuspendedIPs(ips interface{}, now interface{}) *MockPeerStorage_IsSuspendedIPs_Call {
	return &MockPeerStorage_IsSuspendedIPs_Call{Call: _e.mock.On("IsSuspendedIPs", ips, now)}
}

func (_c *MockPeerStorage_IsSuspendedIPs_Call) Run(run func(ips []storage.IP, now time.Time)) *MockPeerStorage_IsSuspendedIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.IP
		if args[0] != nil {
			arg0 = args[0].([]storage.IP)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerStorage_IsSuspendedIPs_Call) Return(bools []bool) *MockPeerStorage_IsSuspendedIPs_Call {
	_c.Call.Return(bools)
	return _c
}

func (_c *MockPeerStorage_IsSuspendedIPs_Call) RunAndReturn(run func(ips []storage.IP, now time.Time) []bool) *MockPeerStorage_IsSuspendedIPs_Call {
	_c.Call.Return(run)
	return _c
}

// Known provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) Known(limit int) []storage.KnownPeer {
	ret := _mock.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for Known")
	}

	var r0 []storage.KnownPeer
	if returnFunc, ok := ret.Get(0).(func(int) []storage.KnownPeer); ok {
		r0 = returnFunc(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.KnownPeer)
		}
	}
	return r0
}

// MockPeerStorage_Known_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Known'
type MockPeerStorage_Known_Call struct {
	*mock.Call
}

// Known is a helper method to define mock.On call
//   - limit int
func (_e *MockPeerStorage_Expecter) Known(limit interface{}) *MockPeerStorage_Known_Call {
	return &MockPeerStorage_Known_Call{Call: _e.mock.On("Known", limit)}
}

func (_c *MockPeerStorage_Known_Call) Run(run func(limit int)) *MockPeerStorage_Known_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_Known_Call) Return(knownPeers []storage.KnownPeer) *MockPeerStorage_Known_Call {
	_c.Call.Return(knownPeers)
	return _c
}

func (_c *MockPeerStorage_Known_Call) RunAndReturn(run func(limit int) []storage.KnownPeer) *MockPeerStorage_Known_Call {
	_c.Call.Return(run)
	return _c
}

// RefreshBlackList provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) RefreshBlackList(now time.Time) error {
	ret := _mock.Called(now)

	if len(ret) == 0 {
		panic("no return value specified for RefreshBlackList")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(time.Time) error); ok {
		r0 = returnFunc(now)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_RefreshBlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefreshBlackList'
type MockPeerStorage_RefreshBlackList_Call struct {
	*mock.Call
}

// RefreshBlackList is a helper method to define mock.On call
//   - now time.Time
func (_e *MockPeerStorage_Expecter) RefreshBlackList(now interface{}) *MockPeerStorage_RefreshBlackList_Call {
	return &MockPeerStorage_RefreshBlackList_Call{Call: _e.mock.On("RefreshBlackList", now)}
}

func (_c *MockPeerStorage_RefreshBlackList_Call) Run(run func(now time.Time)) *MockPeerStorage_RefreshBlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Time
		if args[0] != nil {
			arg0 = args[0].(time.Time)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_RefreshBlackList_Call) Return(err error) *MockPeerStorage_RefreshBlackList_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_RefreshBlackList_Call) RunAndReturn(run func(now time.Time) error) *MockPeerStorage_RefreshBlackList_Call {
	_c.Call.Return(run)
	return _c
}

// RefreshSuspended provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) RefreshSuspended(now time.Time) error {
	ret := _mock.Called(now)

	if len(ret) == 0 {
		panic("no return value specified for RefreshSuspended")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(time.Time) error); ok {
		r0 = returnFunc(now)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerStorage_RefreshSuspended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefreshSuspended'
type MockPeerStorage_RefreshSuspended_Call struct {
	*mock.Call
}

// RefreshSuspended is a helper method to define mock.On call
//   - now time.Time
func (_e *MockPeerStorage_Expecter) RefreshSuspended(now interface{}) *MockPeerStorage_RefreshSuspended_Call {
	return &MockPeerStorage_RefreshSuspended_Call{Call: _e.mock.On("RefreshSuspended", now)}
}

func (_c *MockPeerStorage_RefreshSuspended_Call) Run(run func(now time.Time)) *MockPeerStorage_RefreshSuspended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Time
		if args[0] != nil {
			arg0 = args[0].(time.Time)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_RefreshSuspended_Call) Return(err error) *MockPeerStorage_RefreshSuspended_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerStorage_RefreshSuspended_Call) RunAndReturn(run func(now time.Time) error) *MockPeerStorage_RefreshSuspended_Call {
	_c.Call.Return(run)
	return _c
}

// Suspended provides a mock function for the type MockPeerStorage
func (_mock *MockPeerStorage) Suspended(now time.Time) []storage.SuspendedPeer {
	ret := _mock.Called(now)

	if len(ret) == 0 {
		panic("no return value specified for Suspended")
	}

	var r0 []storage.SuspendedPeer
	if returnFunc, ok := ret.Get(0).(func(time.Time) []storage.SuspendedPeer); ok {
		r0 = returnFunc(now)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.SuspendedPeer)
		}
	}
	return r0
}

// MockPeerStorage_Suspended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Suspended'
type MockPeerStorage_Suspended_Call struct {
	*mock.Call
}

// Suspended is a helper method to define mock.On call
//   - now time.Time
func (_e *MockPeerStorage_Expecter) Suspended(now interface{}) *MockPeerStorage_Suspended_Call {
	return &MockPeerStorage_Suspended_Call{Call: _e.mock.On("Suspended", now)}
}

func (_c *MockPeerStorage_Suspended_Call) Run(run func(now time.Time)) *MockPeerStorage_Suspended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 time.Time
		if args[0] != nil {
			arg0 = args[0].(time.Time)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerStorage_Suspended_Call) Return(vs []storage.SuspendedPeer) *MockPeerStorage_Suspended_Call {
	_c.Call.Return(vs)
	return _c
}

func (_c *MockPeerStorage_Suspended_Call) RunAndReturn(run func(now time.Time) []storage.SuspendedPeer) *MockPeerStorage_Suspended_Call {
	_c.Call.Return(run)
	return _c
}
