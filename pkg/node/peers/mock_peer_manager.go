// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package peers

import (
	"context"
	"net"
	"time"

	mock "github.com/stretchr/testify/mock"
	"github.com/wavesplatform/gowaves/pkg/node/peers/storage"
	"github.com/wavesplatform/gowaves/pkg/p2p/peer"
	"github.com/wavesplatform/gowaves/pkg/proto"
)

// NewMockPeerManager creates a new instance of MockPeerManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPeerManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPeerManager {
	mock := &MockPeerManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPeerManager is an autogenerated mock type for the PeerManager type
type MockPeerManager struct {
	mock.Mock
}

type MockPeerManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPeerManager) EXPECT() *MockPeerManager_Expecter {
	return &MockPeerManager_Expecter{mock: &_m.Mock}
}

// AddToBlackList provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) AddToBlackList(peer1 peer.Peer, blockTime time.Time, reason string) {
	_mock.Called(peer1, blockTime, reason)
	return
}

// MockPeerManager_AddToBlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddToBlackList'
type MockPeerManager_AddToBlackList_Call struct {
	*mock.Call
}

// AddToBlackList is a helper method to define mock.On call
//   - peer1 peer.Peer
//   - blockTime time.Time
//   - reason string
func (_e *MockPeerManager_Expecter) AddToBlackList(peer1 interface{}, blockTime interface{}, reason interface{}) *MockPeerManager_AddToBlackList_Call {
	return &MockPeerManager_AddToBlackList_Call{Call: _e.mock.On("AddToBlackList", peer1, blockTime, reason)}
}

func (_c *MockPeerManager_AddToBlackList_Call) Run(run func(peer1 peer.Peer, blockTime time.Time, reason string)) *MockPeerManager_AddToBlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPeerManager_AddToBlackList_Call) Return() *MockPeerManager_AddToBlackList_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeerManager_AddToBlackList_Call) RunAndReturn(run func(peer1 peer.Peer, blockTime time.Time, reason string)) *MockPeerManager_AddToBlackList_Call {
	_c.Run(run)
	return _c
}

// AskPeers provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) AskPeers() {
	_mock.Called()
	return
}

// MockPeerManager_AskPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AskPeers'
type MockPeerManager_AskPeers_Call struct {
	*mock.Call
}

// AskPeers is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) AskPeers() *MockPeerManager_AskPeers_Call {
	return &MockPeerManager_AskPeers_Call{Call: _e.mock.On("AskPeers")}
}

func (_c *MockPeerManager_AskPeers_Call) Run(run func()) *MockPeerManager_AskPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_AskPeers_Call) Return() *MockPeerManager_AskPeers_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeerManager_AskPeers_Call) RunAndReturn(run func()) *MockPeerManager_AskPeers_Call {
	_c.Run(run)
	return _c
}

// BlackList provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) BlackList() []storage.BlackListedPeer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for BlackList")
	}

	var r0 []storage.BlackListedPeer
	if returnFunc, ok := ret.Get(0).(func() []storage.BlackListedPeer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.BlackListedPeer)
		}
	}
	return r0
}

// MockPeerManager_BlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlackList'
type MockPeerManager_BlackList_Call struct {
	*mock.Call
}

// BlackList is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) BlackList() *MockPeerManager_BlackList_Call {
	return &MockPeerManager_BlackList_Call{Call: _e.mock.On("BlackList")}
}

func (_c *MockPeerManager_BlackList_Call) Run(run func()) *MockPeerManager_BlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_BlackList_Call) Return(vs []storage.BlackListedPeer) *MockPeerManager_BlackList_Call {
	_c.Call.Return(vs)
	return _c
}

func (_c *MockPeerManager_BlackList_Call) RunAndReturn(run func() []storage.BlackListedPeer) *MockPeerManager_BlackList_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPeerInLargestScoreGroup provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) CheckPeerInLargestScoreGroup(p peer.Peer) (peer.Peer, bool) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for CheckPeerInLargestScoreGroup")
	}

	var r0 peer.Peer
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) (peer.Peer, bool)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) peer.Peer); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(peer.Peer)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.Peer) bool); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockPeerManager_CheckPeerInLargestScoreGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPeerInLargestScoreGroup'
type MockPeerManager_CheckPeerInLargestScoreGroup_Call struct {
	*mock.Call
}

// CheckPeerInLargestScoreGroup is a helper method to define mock.On call
//   - p peer.Peer
func (_e *MockPeerManager_Expecter) CheckPeerInLargestScoreGroup(p interface{}) *MockPeerManager_CheckPeerInLargestScoreGroup_Call {
	return &MockPeerManager_CheckPeerInLargestScoreGroup_Call{Call: _e.mock.On("CheckPeerInLargestScoreGroup", p)}
}

func (_c *MockPeerManager_CheckPeerInLargestScoreGroup_Call) Run(run func(p peer.Peer)) *MockPeerManager_CheckPeerInLargestScoreGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_CheckPeerInLargestScoreGroup_Call) Return(peer1 peer.Peer, b bool) *MockPeerManager_CheckPeerInLargestScoreGroup_Call {
	_c.Call.Return(peer1, b)
	return _c
}

func (_c *MockPeerManager_CheckPeerInLargestScoreGroup_Call) RunAndReturn(run func(p peer.Peer) (peer.Peer, bool)) *MockPeerManager_CheckPeerInLargestScoreGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPeerWithMaxScore provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) CheckPeerWithMaxScore(p peer.Peer) (peer.Peer, bool) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for CheckPeerWithMaxScore")
	}

	var r0 peer.Peer
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) (peer.Peer, bool)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) peer.Peer); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(peer.Peer)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.Peer) bool); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockPeerManager_CheckPeerWithMaxScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPeerWithMaxScore'
type MockPeerManager_CheckPeerWithMaxScore_Call struct {
	*mock.Call
}

// CheckPeerWithMaxScore is a helper method to define mock.On call
//   - p peer.Peer
func (_e *MockPeerManager_Expecter) CheckPeerWithMaxScore(p interface{}) *MockPeerManager_CheckPeerWithMaxScore_Call {
	return &MockPeerManager_CheckPeerWithMaxScore_Call{Call: _e.mock.On("CheckPeerWithMaxScore", p)}
}

func (_c *MockPeerManager_CheckPeerWithMaxScore_Call) Run(run func(p peer.Peer)) *MockPeerManager_CheckPeerWithMaxScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_CheckPeerWithMaxScore_Call) Return(peer1 peer.Peer, b bool) *MockPeerManager_CheckPeerWithMaxScore_Call {
	_c.Call.Return(peer1, b)
	return _c
}

func (_c *MockPeerManager_CheckPeerWithMaxScore_Call) RunAndReturn(run func(p peer.Peer) (peer.Peer, bool)) *MockPeerManager_CheckPeerWithMaxScore_Call {
	_c.Call.Return(run)
	return _c
}

// ClearBlackList provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) ClearBlackList() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClearBlackList")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_ClearBlackList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearBlackList'
type MockPeerManager_ClearBlackList_Call struct {
	*mock.Call
}

// ClearBlackList is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) ClearBlackList() *MockPeerManager_ClearBlackList_Call {
	return &MockPeerManager_ClearBlackList_Call{Call: _e.mock.On("ClearBlackList")}
}

func (_c *MockPeerManager_ClearBlackList_Call) Run(run func()) *MockPeerManager_ClearBlackList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_ClearBlackList_Call) Return(err error) *MockPeerManager_ClearBlackList_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_ClearBlackList_Call) RunAndReturn(run func() error) *MockPeerManager_ClearBlackList_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockPeerManager_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) Close() *MockPeerManager_Close_Call {
	return &MockPeerManager_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockPeerManager_Close_Call) Run(run func()) *MockPeerManager_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_Close_Call) Return(err error) *MockPeerManager_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_Close_Call) RunAndReturn(run func() error) *MockPeerManager_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Connect provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Connect(context1 context.Context, tCPAddr proto.TCPAddr) error {
	ret := _mock.Called(context1, tCPAddr)

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, proto.TCPAddr) error); ok {
		r0 = returnFunc(context1, tCPAddr)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type MockPeerManager_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
//   - context1 context.Context
//   - tCPAddr proto.TCPAddr
func (_e *MockPeerManager_Expecter) Connect(context1 interface{}, tCPAddr interface{}) *MockPeerManager_Connect_Call {
	return &MockPeerManager_Connect_Call{Call: _e.mock.On("Connect", context1, tCPAddr)}
}

func (_c *MockPeerManager_Connect_Call) Run(run func(context1 context.Context, tCPAddr proto.TCPAddr)) *MockPeerManager_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 proto.TCPAddr
		if args[1] != nil {
			arg1 = args[1].(proto.TCPAddr)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerManager_Connect_Call) Return(err error) *MockPeerManager_Connect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_Connect_Call) RunAndReturn(run func(context1 context.Context, tCPAddr proto.TCPAddr) error) *MockPeerManager_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectedCount provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) ConnectedCount() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConnectedCount")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockPeerManager_ConnectedCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectedCount'
type MockPeerManager_ConnectedCount_Call struct {
	*mock.Call
}

// ConnectedCount is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) ConnectedCount() *MockPeerManager_ConnectedCount_Call {
	return &MockPeerManager_ConnectedCount_Call{Call: _e.mock.On("ConnectedCount")}
}

func (_c *MockPeerManager_ConnectedCount_Call) Run(run func()) *MockPeerManager_ConnectedCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_ConnectedCount_Call) Return(n int) *MockPeerManager_ConnectedCount_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockPeerManager_ConnectedCount_Call) RunAndReturn(run func() int) *MockPeerManager_ConnectedCount_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Disconnect(peer1 peer.Peer) {
	_mock.Called(peer1)
	return
}

// MockPeerManager_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type MockPeerManager_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
//   - peer1 peer.Peer
func (_e *MockPeerManager_Expecter) Disconnect(peer1 interface{}) *MockPeerManager_Disconnect_Call {
	return &MockPeerManager_Disconnect_Call{Call: _e.mock.On("Disconnect", peer1)}
}

func (_c *MockPeerManager_Disconnect_Call) Run(run func(peer1 peer.Peer)) *MockPeerManager_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_Disconnect_Call) Return() *MockPeerManager_Disconnect_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeerManager_Disconnect_Call) RunAndReturn(run func(peer1 peer.Peer)) *MockPeerManager_Disconnect_Call {
	_c.Run(run)
	return _c
}

// EachConnected provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) EachConnected(fn func(peer.Peer, *proto.Score)) {
	_mock.Called(fn)
	return
}

// MockPeerManager_EachConnected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EachConnected'
type MockPeerManager_EachConnected_Call struct {
	*mock.Call
}

// EachConnected is a helper method to define mock.On call
//   - fn func(peer.Peer, *proto.Score)
func (_e *MockPeerManager_Expecter) EachConnected(fn interface{}) *MockPeerManager_EachConnected_Call {
	return &MockPeerManager_EachConnected_Call{Call: _e.mock.On("EachConnected", fn)}
}

func (_c *MockPeerManager_EachConnected_Call) Run(run func(fn func(peer.Peer, *proto.Score))) *MockPeerManager_EachConnected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(peer.Peer, *proto.Score)
		if args[0] != nil {
			arg0 = args[0].(func(peer.Peer, *proto.Score))
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_EachConnected_Call) Return() *MockPeerManager_EachConnected_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeerManager_EachConnected_Call) RunAndReturn(run func(fn func(peer.Peer, *proto.Score))) *MockPeerManager_EachConnected_Call {
	_c.Run(run)
	return _c
}

// KnownPeers provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) KnownPeers() []storage.KnownPeer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for KnownPeers")
	}

	var r0 []storage.KnownPeer
	if returnFunc, ok := ret.Get(0).(func() []storage.KnownPeer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.KnownPeer)
		}
	}
	return r0
}

// MockPeerManager_KnownPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KnownPeers'
type MockPeerManager_KnownPeers_Call struct {
	*mock.Call
}

// KnownPeers is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) KnownPeers() *MockPeerManager_KnownPeers_Call {
	return &MockPeerManager_KnownPeers_Call{Call: _e.mock.On("KnownPeers")}
}

func (_c *MockPeerManager_KnownPeers_Call) Run(run func()) *MockPeerManager_KnownPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_KnownPeers_Call) Return(knownPeers []storage.KnownPeer) *MockPeerManager_KnownPeers_Call {
	_c.Call.Return(knownPeers)
	return _c
}

func (_c *MockPeerManager_KnownPeers_Call) RunAndReturn(run func() []storage.KnownPeer) *MockPeerManager_KnownPeers_Call {
	_c.Call.Return(run)
	return _c
}

// NewConnection provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) NewConnection(peer1 peer.Peer) error {
	ret := _mock.Called(peer1)

	if len(ret) == 0 {
		panic("no return value specified for NewConnection")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) error); ok {
		r0 = returnFunc(peer1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_NewConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewConnection'
type MockPeerManager_NewConnection_Call struct {
	*mock.Call
}

// NewConnection is a helper method to define mock.On call
//   - peer1 peer.Peer
func (_e *MockPeerManager_Expecter) NewConnection(peer1 interface{}) *MockPeerManager_NewConnection_Call {
	return &MockPeerManager_NewConnection_Call{Call: _e.mock.On("NewConnection", peer1)}
}

func (_c *MockPeerManager_NewConnection_Call) Run(run func(peer1 peer.Peer)) *MockPeerManager_NewConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_NewConnection_Call) Return(err error) *MockPeerManager_NewConnection_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_NewConnection_Call) RunAndReturn(run func(peer1 peer.Peer) error) *MockPeerManager_NewConnection_Call {
	_c.Call.Return(run)
	return _c
}

// Score provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Score(p peer.Peer) (*proto.Score, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Score")
	}

	var r0 *proto.Score
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) (*proto.Score, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func(peer.Peer) *proto.Score); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.Score)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(peer.Peer) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPeerManager_Score_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Score'
type MockPeerManager_Score_Call struct {
	*mock.Call
}

// Score is a helper method to define mock.On call
//   - p peer.Peer
func (_e *MockPeerManager_Expecter) Score(p interface{}) *MockPeerManager_Score_Call {
	return &MockPeerManager_Score_Call{Call: _e.mock.On("Score", p)}
}

func (_c *MockPeerManager_Score_Call) Run(run func(p peer.Peer)) *MockPeerManager_Score_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_Score_Call) Return(v *proto.Score, err error) *MockPeerManager_Score_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockPeerManager_Score_Call) RunAndReturn(run func(p peer.Peer) (*proto.Score, error)) *MockPeerManager_Score_Call {
	_c.Call.Return(run)
	return _c
}

// SpawnIncomingConnection provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) SpawnIncomingConnection(ctx context.Context, conn net.Conn) error {
	ret := _mock.Called(ctx, conn)

	if len(ret) == 0 {
		panic("no return value specified for SpawnIncomingConnection")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, net.Conn) error); ok {
		r0 = returnFunc(ctx, conn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_SpawnIncomingConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpawnIncomingConnection'
type MockPeerManager_SpawnIncomingConnection_Call struct {
	*mock.Call
}

// SpawnIncomingConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - conn net.Conn
func (_e *MockPeerManager_Expecter) SpawnIncomingConnection(ctx interface{}, conn interface{}) *MockPeerManager_SpawnIncomingConnection_Call {
	return &MockPeerManager_SpawnIncomingConnection_Call{Call: _e.mock.On("SpawnIncomingConnection", ctx, conn)}
}

func (_c *MockPeerManager_SpawnIncomingConnection_Call) Run(run func(ctx context.Context, conn net.Conn)) *MockPeerManager_SpawnIncomingConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 net.Conn
		if args[1] != nil {
			arg1 = args[1].(net.Conn)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerManager_SpawnIncomingConnection_Call) Return(err error) *MockPeerManager_SpawnIncomingConnection_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_SpawnIncomingConnection_Call) RunAndReturn(run func(ctx context.Context, conn net.Conn) error) *MockPeerManager_SpawnIncomingConnection_Call {
	_c.Call.Return(run)
	return _c
}

// SpawnOutgoingConnections provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) SpawnOutgoingConnections(context1 context.Context) {
	_mock.Called(context1)
	return
}

// MockPeerManager_SpawnOutgoingConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpawnOutgoingConnections'
type MockPeerManager_SpawnOutgoingConnections_Call struct {
	*mock.Call
}

// SpawnOutgoingConnections is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockPeerManager_Expecter) SpawnOutgoingConnections(context1 interface{}) *MockPeerManager_SpawnOutgoingConnections_Call {
	return &MockPeerManager_SpawnOutgoingConnections_Call{Call: _e.mock.On("SpawnOutgoingConnections", context1)}
}

func (_c *MockPeerManager_SpawnOutgoingConnections_Call) Run(run func(context1 context.Context)) *MockPeerManager_SpawnOutgoingConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_SpawnOutgoingConnections_Call) Return() *MockPeerManager_SpawnOutgoingConnections_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeerManager_SpawnOutgoingConnections_Call) RunAndReturn(run func(context1 context.Context)) *MockPeerManager_SpawnOutgoingConnections_Call {
	_c.Run(run)
	return _c
}

// Spawned provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Spawned() []proto.IpPort {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Spawned")
	}

	var r0 []proto.IpPort
	if returnFunc, ok := ret.Get(0).(func() []proto.IpPort); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]proto.IpPort)
		}
	}
	return r0
}

// MockPeerManager_Spawned_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Spawned'
type MockPeerManager_Spawned_Call struct {
	*mock.Call
}

// Spawned is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) Spawned() *MockPeerManager_Spawned_Call {
	return &MockPeerManager_Spawned_Call{Call: _e.mock.On("Spawned")}
}

func (_c *MockPeerManager_Spawned_Call) Run(run func()) *MockPeerManager_Spawned_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_Spawned_Call) Return(ipPorts []proto.IpPort) *MockPeerManager_Spawned_Call {
	_c.Call.Return(ipPorts)
	return _c
}

func (_c *MockPeerManager_Spawned_Call) RunAndReturn(run func() []proto.IpPort) *MockPeerManager_Spawned_Call {
	_c.Call.Return(run)
	return _c
}

// Suspend provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Suspend(peer1 peer.Peer, suspendTime time.Time, reason string) {
	_mock.Called(peer1, suspendTime, reason)
	return
}

// MockPeerManager_Suspend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Suspend'
type MockPeerManager_Suspend_Call struct {
	*mock.Call
}

// Suspend is a helper method to define mock.On call
//   - peer1 peer.Peer
//   - suspendTime time.Time
//   - reason string
func (_e *MockPeerManager_Expecter) Suspend(peer1 interface{}, suspendTime interface{}, reason interface{}) *MockPeerManager_Suspend_Call {
	return &MockPeerManager_Suspend_Call{Call: _e.mock.On("Suspend", peer1, suspendTime, reason)}
}

func (_c *MockPeerManager_Suspend_Call) Run(run func(peer1 peer.Peer, suspendTime time.Time, reason string)) *MockPeerManager_Suspend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPeerManager_Suspend_Call) Return() *MockPeerManager_Suspend_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPeerManager_Suspend_Call) RunAndReturn(run func(peer1 peer.Peer, suspendTime time.Time, reason string)) *MockPeerManager_Suspend_Call {
	_c.Run(run)
	return _c
}

// Suspended provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) Suspended() []storage.SuspendedPeer {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Suspended")
	}

	var r0 []storage.SuspendedPeer
	if returnFunc, ok := ret.Get(0).(func() []storage.SuspendedPeer); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.SuspendedPeer)
		}
	}
	return r0
}

// MockPeerManager_Suspended_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Suspended'
type MockPeerManager_Suspended_Call struct {
	*mock.Call
}

// Suspended is a helper method to define mock.On call
func (_e *MockPeerManager_Expecter) Suspended() *MockPeerManager_Suspended_Call {
	return &MockPeerManager_Suspended_Call{Call: _e.mock.On("Suspended")}
}

func (_c *MockPeerManager_Suspended_Call) Run(run func()) *MockPeerManager_Suspended_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPeerManager_Suspended_Call) Return(vs []storage.SuspendedPeer) *MockPeerManager_Suspended_Call {
	_c.Call.Return(vs)
	return _c
}

func (_c *MockPeerManager_Suspended_Call) RunAndReturn(run func() []storage.SuspendedPeer) *MockPeerManager_Suspended_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateKnownPeers provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) UpdateKnownPeers(knownPeers []storage.KnownPeer) error {
	ret := _mock.Called(knownPeers)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKnownPeers")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func([]storage.KnownPeer) error); ok {
		r0 = returnFunc(knownPeers)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_UpdateKnownPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateKnownPeers'
type MockPeerManager_UpdateKnownPeers_Call struct {
	*mock.Call
}

// UpdateKnownPeers is a helper method to define mock.On call
//   - knownPeers []storage.KnownPeer
func (_e *MockPeerManager_Expecter) UpdateKnownPeers(knownPeers interface{}) *MockPeerManager_UpdateKnownPeers_Call {
	return &MockPeerManager_UpdateKnownPeers_Call{Call: _e.mock.On("UpdateKnownPeers", knownPeers)}
}

func (_c *MockPeerManager_UpdateKnownPeers_Call) Run(run func(knownPeers []storage.KnownPeer)) *MockPeerManager_UpdateKnownPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []storage.KnownPeer
		if args[0] != nil {
			arg0 = args[0].([]storage.KnownPeer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPeerManager_UpdateKnownPeers_Call) Return(err error) *MockPeerManager_UpdateKnownPeers_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_UpdateKnownPeers_Call) RunAndReturn(run func(knownPeers []storage.KnownPeer) error) *MockPeerManager_UpdateKnownPeers_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateScore provides a mock function for the type MockPeerManager
func (_mock *MockPeerManager) UpdateScore(p peer.Peer, score *proto.Score) error {
	ret := _mock.Called(p, score)

	if len(ret) == 0 {
		panic("no return value specified for UpdateScore")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(peer.Peer, *proto.Score) error); ok {
		r0 = returnFunc(p, score)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPeerManager_UpdateScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateScore'
type MockPeerManager_UpdateScore_Call struct {
	*mock.Call
}

// UpdateScore is a helper method to define mock.On call
//   - p peer.Peer
//   - score *proto.Score
func (_e *MockPeerManager_Expecter) UpdateScore(p interface{}, score interface{}) *MockPeerManager_UpdateScore_Call {
	return &MockPeerManager_UpdateScore_Call{Call: _e.mock.On("UpdateScore", p, score)}
}

func (_c *MockPeerManager_UpdateScore_Call) Run(run func(p peer.Peer, score *proto.Score)) *MockPeerManager_UpdateScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 peer.Peer
		if args[0] != nil {
			arg0 = args[0].(peer.Peer)
		}
		var arg1 *proto.Score
		if args[1] != nil {
			arg1 = args[1].(*proto.Score)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPeerManager_UpdateScore_Call) Return(err error) *MockPeerManager_UpdateScore_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPeerManager_UpdateScore_Call) RunAndReturn(run func(p peer.Peer, score *proto.Score) error) *MockPeerManager_UpdateScore_Call {
	_c.Call.Return(run)
	return _c
}
